{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 18, 'end_line': 19, 'offset_start': 711, 'offset_end': 769, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 21, 'end_line': 22, 'offset_start': 776, 'offset_end': 844, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 23, 'end_line': 25, 'offset_start': 850, 'offset_end': 945, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 27, 'end_line': 29, 'offset_start': 952, 'offset_end': 1050, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 78, 'end_line': 80, 'offset_start': 3214, 'offset_end': 3324, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 82, 'end_line': 84, 'offset_start': 3331, 'offset_end': 3439, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 99, 'end_line': 105, 'offset_start': 3926, 'offset_end': 4212, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 107, 'end_line': 111, 'offset_start': 4219, 'offset_end': 4427, 'content': 'function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 117, 'end_line': 119, 'offset_start': 4607, 'offset_end': 4713, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 152, 'end_line': 153, 'offset_start': 5871, 'offset_end': 5928, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 155, 'end_line': 156, 'offset_start': 5935, 'offset_end': 6002, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 160, 'end_line': 162, 'offset_start': 6069, 'offset_end': 6234, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.getL2ERC20Address', 'start_line': 225, 'end_line': 225, 'offset_start': 8475, 'offset_end': 8551, 'content': 'function getL2ERC20Address(address _l1Token) external view returns (address);', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.depositERC20', 'start_line': 236, 'end_line': 240, 'offset_start': 8980, 'offset_end': 9100, 'content': 'function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.depositERC20', 'start_line': 248, 'end_line': 253, 'offset_start': 9486, 'offset_end': 9627, 'content': 'function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.depositERC20AndCall', 'start_line': 262, 'end_line': 268, 'offset_start': 10092, 'offset_end': 10268, 'content': 'function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.finalizeWithdrawERC20', 'start_line': 280, 'end_line': 287, 'offset_start': 10996, 'offset_end': 11200, 'content': 'function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165Upgradeable.supportsInterface', 'start_line': 313, 'end_line': 313, 'offset_start': 11990, 'offset_end': 12065, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165Upgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.tor', 'start_line': 487, 'end_line': 499, 'offset_start': 18901, 'offset_end': 19183, 'content': 'constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.initialize', 'start_line': 503, 'end_line': 512, 'offset_start': 19316, 'offset_end': 19790, 'content': 'function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.', 'start_line': 519, 'end_line': 523, 'offset_start': 19967, 'offset_end': 20097, 'content': 'receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.depositETH', 'start_line': 526, 'end_line': 529, 'offset_start': 20133, 'offset_end': 20324, 'content': 'function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.depositERC20', 'start_line': 535, 'end_line': 544, 'offset_start': 20544, 'offset_end': 21073, 'content': 'function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.setBatchConfig', 'start_line': 556, 'end_line': 565, 'offset_start': 21449, 'offset_end': 21837, 'content': 'function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway.executeBatchDeposit', 'start_line': 569, 'end_line': 648, 'offset_start': 21959, 'offset_end': 25318, 'content': 'function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway._deposit', 'start_line': 658, 'end_line': 695, 'offset_start': 25619, 'offset_end': 27228, 'content': 'function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway._tryFinalizeCurrentBatch', 'start_line': 702, 'end_line': 721, 'offset_start': 27591, 'offset_end': 28450, 'content': 'function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L1BatchBridgeGateway._transferToken', 'start_line': 727, 'end_line': 738, 'offset_start': 28675, 'offset_end': 29047, 'content': 'function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }', 'contract_name': 'L1BatchBridgeGateway', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchBridgeGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchBridgeGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable nonReentrant {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external nonReentrant {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig calldata newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}("");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.permit', 'start_line': 776, 'end_line': 784, 'offset_start': 30518, 'offset_end': 30700, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.nonces', 'start_line': 793, 'end_line': 793, 'offset_start': 31006, 'offset_end': 31068, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.DOMAIN_SEPARATOR', 'start_line': 799, 'end_line': 799, 'offset_start': 31261, 'offset_end': 31320, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.hasRole', 'start_line': 841, 'end_line': 841, 'offset_start': 32757, 'offset_end': 32833, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.getRoleAdmin', 'start_line': 849, 'end_line': 849, 'offset_start': 33029, 'offset_end': 33096, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.grantRole', 'start_line': 861, 'end_line': 861, 'offset_start': 33347, 'offset_end': 33405, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.revokeRole', 'start_line': 872, 'end_line': 872, 'offset_start': 33640, 'offset_end': 33699, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.renounceRole', 'start_line': 888, 'end_line': 888, 'offset_start': 34191, 'offset_end': 34252, 'content': 'function renounceRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'BatchBridgeCodec.encodeInitialNode', 'start_line': 897, 'end_line': 901, 'offset_start': 34417, 'offset_end': 34602, 'content': 'function encodeInitialNode(address token, uint64 batchIndex) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, token), batchIndex)\n        }\n    }', 'contract_name': 'BatchBridgeCodec', 'contract_code': '{\n    /// @dev Encode the `token` and `batchIndex` to single `bytes32`.\n    function encodeInitialNode(address token, uint64 batchIndex) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, token), batchIndex)\n        }\n    }\n\n    /// @dev Encode the `sender` and `amount` to single `bytes32`.\n    function encodeNode(address sender, uint96 amount) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, sender), amount)\n        }\n    }\n\n    /// @dev Decode `bytes32` `node` to `receiver` and `amount`.\n    function decodeNode(bytes32 node) internal pure returns (address receiver, uint256 amount) {\n        receiver = address(uint160(uint256(node) >> 96));\n        amount = uint256(node) & 0xffffffffffffffffffffffff;\n    }\n\n    /// @dev Compute `keccak256(concat(a, b))`.\n    function hash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'BatchBridgeCodec.encodeNode', 'start_line': 904, 'end_line': 908, 'offset_start': 34676, 'offset_end': 34848, 'content': 'function encodeNode(address sender, uint96 amount) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, sender), amount)\n        }\n    }', 'contract_name': 'BatchBridgeCodec', 'contract_code': '{\n    /// @dev Encode the `token` and `batchIndex` to single `bytes32`.\n    function encodeInitialNode(address token, uint64 batchIndex) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, token), batchIndex)\n        }\n    }\n\n    /// @dev Encode the `sender` and `amount` to single `bytes32`.\n    function encodeNode(address sender, uint96 amount) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, sender), amount)\n        }\n    }\n\n    /// @dev Decode `bytes32` `node` to `receiver` and `amount`.\n    function decodeNode(bytes32 node) internal pure returns (address receiver, uint256 amount) {\n        receiver = address(uint160(uint256(node) >> 96));\n        amount = uint256(node) & 0xffffffffffffffffffffffff;\n    }\n\n    /// @dev Compute `keccak256(concat(a, b))`.\n    function hash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'BatchBridgeCodec.decodeNode', 'start_line': 911, 'end_line': 914, 'offset_start': 34920, 'offset_end': 35136, 'content': 'function decodeNode(bytes32 node) internal pure returns (address receiver, uint256 amount) {\n        receiver = address(uint160(uint256(node) >> 96));\n        amount = uint256(node) & 0xffffffffffffffffffffffff;\n    }', 'contract_name': 'BatchBridgeCodec', 'contract_code': '{\n    /// @dev Encode the `token` and `batchIndex` to single `bytes32`.\n    function encodeInitialNode(address token, uint64 batchIndex) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, token), batchIndex)\n        }\n    }\n\n    /// @dev Encode the `sender` and `amount` to single `bytes32`.\n    function encodeNode(address sender, uint96 amount) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, sender), amount)\n        }\n    }\n\n    /// @dev Decode `bytes32` `node` to `receiver` and `amount`.\n    function decodeNode(bytes32 node) internal pure returns (address receiver, uint256 amount) {\n        receiver = address(uint160(uint256(node) >> 96));\n        amount = uint256(node) & 0xffffffffffffffffffffffff;\n    }\n\n    /// @dev Compute `keccak256(concat(a, b))`.\n    function hash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'BatchBridgeCodec.hash', 'start_line': 917, 'end_line': 924, 'offset_start': 35191, 'offset_end': 35455, 'content': 'function hash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'BatchBridgeCodec', 'contract_code': '{\n    /// @dev Encode the `token` and `batchIndex` to single `bytes32`.\n    function encodeInitialNode(address token, uint64 batchIndex) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, token), batchIndex)\n        }\n    }\n\n    /// @dev Encode the `sender` and `amount` to single `bytes32`.\n    function encodeNode(address sender, uint96 amount) internal pure returns (bytes32 node) {\n        assembly {\n            node := add(shl(96, sender), amount)\n        }\n    }\n\n    /// @dev Decode `bytes32` `node` to `receiver` and `amount`.\n    function decodeNode(bytes32 node) internal pure returns (address receiver, uint256 amount) {\n        receiver = address(uint160(uint256(node) >> 96));\n        amount = uint256(node) & 0xffffffffffffffffffffffff;\n    }\n\n    /// @dev Compute `keccak256(concat(a, b))`.\n    function hash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.depositETH', 'start_line': 962, 'end_line': 962, 'offset_start': 36946, 'offset_end': 37016, 'content': 'function depositETH(uint256 amount, uint256 gasLimit) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.depositETH', 'start_line': 968, 'end_line': 972, 'offset_start': 37277, 'offset_end': 37389, 'content': 'function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.depositETHAndCall', 'start_line': 979, 'end_line': 984, 'offset_start': 37748, 'offset_end': 37896, 'content': 'function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.finalizeWithdrawETH', 'start_line': 993, 'end_line': 998, 'offset_start': 38401, 'offset_end': 38547, 'content': 'function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2ScrollMessenger.relayMessage', 'start_line': 1028, 'end_line': 1034, 'offset_start': 39726, 'offset_end': 39882, 'content': 'function relayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes calldata message\n    ) external;', 'contract_name': 'IL2ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can fail in L2 is updated.\n    /// @param oldMaxFailedExecutionTimes The old maximum number of times each message can fail in L2.\n    /// @param newMaxFailedExecutionTimes The new maximum number of times each message can fail in L2.\n    event UpdateMaxFailedExecutionTimes(uint256 oldMaxFailedExecutionTimes, uint256 newMaxFailedExecutionTimes);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice execute L1 => L2 message\n    /// @dev Make sure this is only called by privileged accounts.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    function relayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes calldata message\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.getERC20Gateway', 'start_line': 1071, 'end_line': 1071, 'offset_start': 41416, 'offset_end': 41488, 'content': 'function getERC20Gateway(address _token) external view returns (address);', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] calldata _tokens, address[] calldata _gateways) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.requestERC20', 'start_line': 1081, 'end_line': 1085, 'offset_start': 41840, 'offset_end': 41965, 'content': 'function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] calldata _tokens, address[] calldata _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.setETHGateway', 'start_line': 1094, 'end_line': 1094, 'offset_start': 42242, 'offset_end': 42294, 'content': 'function setETHGateway(address _ethGateway) external;', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] calldata _tokens, address[] calldata _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.setDefaultERC20Gateway', 'start_line': 1099, 'end_line': 1099, 'offset_start': 42498, 'offset_end': 42568, 'content': 'function setDefaultERC20Gateway(address _defaultERC20Gateway) external;', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] calldata _tokens, address[] calldata _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.setERC20Gateway', 'start_line': 1105, 'end_line': 1105, 'offset_start': 42853, 'offset_end': 42944, 'content': 'function setERC20Gateway(address[] calldata _tokens, address[] calldata _gateways) external;', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] calldata _tokens, address[] calldata _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlEnumerableUpgradeable.getRoleMember', 'start_line': 1131, 'end_line': 1131, 'offset_start': 43881, 'offset_end': 43964, 'content': 'function getRoleMember(bytes32 role, uint256 index) external view returns (address);', 'contract_name': 'IAccessControlEnumerableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlEnumerableUpgradeable.getRoleMemberCount', 'start_line': 1137, 'end_line': 1137, 'offset_start': 44133, 'offset_end': 44206, 'content': 'function getRoleMemberCount(bytes32 role) external view returns (uint256);', 'contract_name': 'IAccessControlEnumerableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransfer', 'start_line': 1165, 'end_line': 1167, 'offset_start': 45207, 'offset_end': 45392, 'content': 'function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransferFrom', 'start_line': 1173, 'end_line': 1175, 'offset_start': 45632, 'offset_end': 45845, 'content': 'function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeApprove', 'start_line': 1184, 'end_line': 1193, 'offset_start': 46106, 'offset_end': 46689, 'content': 'function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeIncreaseAllowance', 'start_line': 1199, 'end_line': 1202, 'offset_start': 46881, 'offset_end': 47171, 'content': 'function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeDecreaseAllowance', 'start_line': 1208, 'end_line': 1214, 'offset_start': 47363, 'offset_end': 47780, 'content': 'function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.forceApprove', 'start_line': 1221, 'end_line': 1228, 'offset_start': 48100, 'offset_end': 48520, 'content': 'function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safePermit', 'start_line': 1234, 'end_line': 1248, 'offset_start': 48673, 'offset_end': 49155, 'content': 'function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturn', 'start_line': 1256, 'end_line': 1263, 'offset_start': 49539, 'offset_end': 50191, 'content': 'function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturnBool', 'start_line': 1273, 'end_line': 1281, 'offset_start': 50693, 'offset_end': 51308, 'content': "function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }", 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 1428, 'end_line': 1434, 'offset_start': 57252, 'offset_end': 57531, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 1439, 'end_line': 1441, 'offset_start': 57642, 'offset_end': 57741, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 1446, 'end_line': 1448, 'offset_start': 57858, 'offset_end': 57950, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 1490, 'end_line': 1496, 'offset_start': 59378, 'offset_end': 59697, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 1514, 'end_line': 1519, 'offset_start': 60613, 'offset_end': 60924, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1539, 'end_line': 1541, 'offset_start': 61667, 'offset_end': 61851, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1549, 'end_line': 1555, 'offset_start': 62074, 'offset_end': 62296, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1568, 'end_line': 1570, 'offset_start': 62659, 'offset_end': 62882, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1578, 'end_line': 1587, 'offset_start': 63131, 'offset_end': 63576, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1595, 'end_line': 1597, 'offset_start': 63754, 'offset_end': 63950, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1605, 'end_line': 1612, 'offset_start': 64135, 'offset_end': 64460, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1620, 'end_line': 1622, 'offset_start': 64640, 'offset_end': 64837, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1630, 'end_line': 1637, 'offset_start': 65024, 'offset_end': 65348, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 1645, 'end_line': 1661, 'offset_start': 65637, 'offset_end': 66264, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 1669, 'end_line': 1679, 'offset_start': 66486, 'offset_end': 66780, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 1681, 'end_line': 1693, 'offset_start': 66787, 'offset_end': 67326, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 1714, 'end_line': 1734, 'offset_start': 67811, 'offset_end': 68517, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 1739, 'end_line': 1741, 'offset_start': 68618, 'offset_end': 68801, 'content': 'function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 1746, 'end_line': 1750, 'offset_start': 68907, 'offset_end': 69091, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 1755, 'end_line': 1765, 'offset_start': 69215, 'offset_end': 69651, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 1770, 'end_line': 1772, 'offset_start': 69804, 'offset_end': 69952, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.equal', 'start_line': 1777, 'end_line': 1779, 'offset_start': 70030, 'offset_end': 70173, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable._add', 'start_line': 1846, 'end_line': 1856, 'offset_start': 72403, 'offset_end': 72806, 'content': 'function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable._remove', 'start_line': 1864, 'end_line': 1896, 'offset_start': 72975, 'offset_end': 74362, 'content': "function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }", 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable._contains', 'start_line': 1901, 'end_line': 1903, 'offset_start': 74444, 'offset_end': 74570, 'content': 'function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable._length', 'start_line': 1908, 'end_line': 1910, 'offset_start': 74652, 'offset_end': 74758, 'content': 'function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable._at', 'start_line': 1922, 'end_line': 1924, 'offset_start': 75101, 'offset_end': 75218, 'content': 'function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable._values', 'start_line': 1934, 'end_line': 1936, 'offset_start': 75759, 'offset_end': 75867, 'content': 'function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.add', 'start_line': 1950, 'end_line': 1952, 'offset_start': 76108, 'offset_end': 76230, 'content': 'function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.remove', 'start_line': 1960, 'end_line': 1962, 'offset_start': 76399, 'offset_end': 76527, 'content': 'function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.contains', 'start_line': 1967, 'end_line': 1969, 'offset_start': 76609, 'offset_end': 76746, 'content': 'function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.length', 'start_line': 1974, 'end_line': 1976, 'offset_start': 76828, 'offset_end': 76942, 'content': 'function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.at', 'start_line': 1988, 'end_line': 1990, 'offset_start': 77285, 'offset_end': 77413, 'content': 'function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.values', 'start_line': 2000, 'end_line': 2010, 'offset_start': 77954, 'offset_end': 78253, 'content': 'function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.add', 'start_line': 2024, 'end_line': 2026, 'offset_start': 78494, 'offset_end': 78643, 'content': 'function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.remove', 'start_line': 2034, 'end_line': 2036, 'offset_start': 78812, 'offset_end': 78967, 'content': 'function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.contains', 'start_line': 2041, 'end_line': 2043, 'offset_start': 79049, 'offset_end': 79213, 'content': 'function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.length', 'start_line': 2048, 'end_line': 2050, 'offset_start': 79295, 'offset_end': 79409, 'content': 'function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.at', 'start_line': 2062, 'end_line': 2064, 'offset_start': 79752, 'offset_end': 79907, 'content': 'function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.values', 'start_line': 2074, 'end_line': 2084, 'offset_start': 80448, 'offset_end': 80747, 'content': 'function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.add', 'start_line': 2098, 'end_line': 2100, 'offset_start': 80982, 'offset_end': 81110, 'content': 'function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.remove', 'start_line': 2108, 'end_line': 2110, 'offset_start': 81279, 'offset_end': 81413, 'content': 'function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.contains', 'start_line': 2115, 'end_line': 2117, 'offset_start': 81495, 'offset_end': 81638, 'content': 'function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.length', 'start_line': 2122, 'end_line': 2124, 'offset_start': 81720, 'offset_end': 81831, 'content': 'function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.at', 'start_line': 2136, 'end_line': 2138, 'offset_start': 82174, 'offset_end': 82308, 'content': 'function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSetUpgradeable.values', 'start_line': 2148, 'end_line': 2158, 'offset_start': 82849, 'offset_end': 83145, 'content': 'function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }', 'contract_name': 'EnumerableSetUpgradeable', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway.tor', 'start_line': 2273, 'end_line': 2278, 'offset_start': 87376, 'offset_end': 87537, 'content': 'constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }', 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway.initialize', 'start_line': 2281, 'end_line': 2288, 'offset_start': 87610, 'offset_end': 87968, 'content': 'function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }', 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway.', 'start_line': 2295, 'end_line': 2297, 'offset_start': 88150, 'offset_end': 88214, 'content': 'receive() external payable onlyMessenger {\n        // empty\n    }', 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway.finalizeBatchDeposit', 'start_line': 2304, 'end_line': 2327, 'offset_start': 88492, 'offset_end': 89408, 'content': "function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won't happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }", 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway.withdrawFailedAmount', 'start_line': 2336, 'end_line': 2342, 'offset_start': 89670, 'offset_end': 89967, 'content': 'function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }', 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway.distribute', 'start_line': 2348, 'end_line': 2377, 'offset_start': 90207, 'offset_end': 91319, 'content': 'function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }', 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'L2BatchBridgeGateway._transferToken', 'start_line': 2388, 'end_line': 2405, 'offset_start': 91690, 'offset_end': 92539, 'content': 'function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }', 'contract_name': 'L2BatchBridgeGateway', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won\'t happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}("");\n        } else {\n            // We perform a low level call here, to bypass Solidity\'s return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 2434, 'end_line': 2434, 'offset_start': 93329, 'offset_end': 93383, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 2439, 'end_line': 2439, 'offset_start': 93467, 'offset_end': 93534, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 2448, 'end_line': 2448, 'offset_start': 93748, 'offset_end': 93817, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 2457, 'end_line': 2457, 'offset_start': 94093, 'offset_end': 94175, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 2473, 'end_line': 2473, 'offset_start': 94829, 'offset_end': 94902, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 2484, 'end_line': 2484, 'offset_start': 95201, 'offset_end': 95288, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.max', 'start_line': 2499, 'end_line': 2501, 'offset_start': 95615, 'offset_end': 95715, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.min', 'start_line': 2506, 'end_line': 2508, 'offset_start': 95794, 'offset_end': 95894, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.average', 'start_line': 2514, 'end_line': 2518, 'offset_start': 96032, 'offset_end': 96261, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.abs', 'start_line': 2523, 'end_line': 2528, 'offset_start': 96351, 'offset_end': 96563, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ScrollMessenger.relayMessageWithProof', 'start_line': 2569, 'end_line': 2576, 'offset_start': 98009, 'offset_end': 98209, 'content': 'function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;', 'contract_name': 'IL1ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ScrollMessenger.replayMessage', 'start_line': 2586, 'end_line': 2594, 'offset_start': 98721, 'offset_end': 98950, 'content': 'function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;', 'contract_name': 'IL1ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ScrollMessenger.dropMessage', 'start_line': 2602, 'end_line': 2608, 'offset_start': 99299, 'offset_end': 99459, 'content': 'function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;', 'contract_name': 'IL1ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.pendingQueueIndex', 'start_line': 2668, 'end_line': 2668, 'offset_start': 101651, 'offset_end': 101711, 'content': 'function pendingQueueIndex() external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.nextCrossDomainMessageIndex', 'start_line': 2672, 'end_line': 2672, 'offset_start': 101834, 'offset_end': 101904, 'content': 'function nextCrossDomainMessageIndex() external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.getCrossDomainMessage', 'start_line': 2676, 'end_line': 2676, 'offset_start': 102012, 'offset_end': 102094, 'content': 'function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.estimateCrossDomainMessageFee', 'start_line': 2680, 'end_line': 2680, 'offset_start': 102259, 'offset_end': 102347, 'content': 'function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.calculateIntrinsicGasFee', 'start_line': 2684, 'end_line': 2684, 'offset_start': 102513, 'offset_end': 102604, 'content': 'function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.computeTransactionHash', 'start_line': 2693, 'end_line': 2700, 'offset_start': 102977, 'offset_end': 103200, 'content': 'function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.isMessageSkipped', 'start_line': 2704, 'end_line': 2704, 'offset_start': 103329, 'offset_end': 103403, 'content': 'function isMessageSkipped(uint256 queueIndex) external view returns (bool);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.isMessageDropped', 'start_line': 2708, 'end_line': 2708, 'offset_start': 103532, 'offset_end': 103606, 'content': 'function isMessageDropped(uint256 queueIndex) external view returns (bool);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.appendCrossDomainMessage', 'start_line': 2718, 'end_line': 2722, 'offset_start': 103995, 'offset_end': 104122, 'content': 'function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.appendEnforcedTransaction', 'start_line': 2731, 'end_line': 2737, 'offset_start': 104582, 'offset_end': 104757, 'content': 'function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.popCrossDomainMessage', 'start_line': 2747, 'end_line': 2751, 'offset_start': 105156, 'offset_end': 105283, 'content': 'function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.dropCrossDomainMessage', 'start_line': 2754, 'end_line': 2754, 'offset_start': 105345, 'offset_end': 105400, 'content': 'function dropCrossDomainMessage(uint256 index) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollMessenger.xDomainMessageSender', 'start_line': 2802, 'end_line': 2802, 'offset_start': 106869, 'offset_end': 106932, 'content': 'function xDomainMessageSender() external view returns (address);', 'contract_name': 'IScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollMessenger.sendMessage', 'start_line': 2813, 'end_line': 2818, 'offset_start': 107407, 'offset_end': 107555, 'content': 'function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;', 'contract_name': 'IScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollMessenger.sendMessage', 'start_line': 2826, 'end_line': 2832, 'offset_start': 108010, 'offset_end': 108189, 'content': 'function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;', 'contract_name': 'IScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.max', 'start_line': 2853, 'end_line': 2855, 'offset_start': 108618, 'offset_end': 108721, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.min', 'start_line': 2860, 'end_line': 2862, 'offset_start': 108793, 'offset_end': 108896, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.average', 'start_line': 2868, 'end_line': 2871, 'offset_start': 109010, 'offset_end': 109162, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.ceilDiv', 'start_line': 2879, 'end_line': 2882, 'offset_start': 109362, 'offset_end': 109555, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 2889, 'end_line': 2968, 'offset_start': 109872, 'offset_end': 114084, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 2973, 'end_line': 2979, 'offset_start': 114217, 'offset_end': 114515, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 2986, 'end_line': 3017, 'offset_start': 114735, 'offset_end': 116372, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 3022, 'end_line': 3027, 'offset_start': 116473, 'offset_end': 116709, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 3033, 'end_line': 3069, 'offset_start': 116834, 'offset_end': 117816, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 3075, 'end_line': 3080, 'offset_start': 117970, 'offset_end': 118214, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 3086, 'end_line': 3118, 'offset_start': 118340, 'offset_end': 119255, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 3124, 'end_line': 3129, 'offset_start': 119410, 'offset_end': 119657, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 3137, 'end_line': 3161, 'offset_start': 119909, 'offset_end': 120571, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 3167, 'end_line': 3172, 'offset_start': 120727, 'offset_end': 120982, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init', 'start_line': 3189, 'end_line': 3190, 'offset_start': 121557, 'offset_end': 121631, 'content': 'function __AccessControlEnumerable_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained', 'start_line': 3192, 'end_line': 3193, 'offset_start': 121638, 'offset_end': 121722, 'content': 'function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable.supportsInterface', 'start_line': 3201, 'end_line': 3203, 'offset_start': 121949, 'offset_end': 122171, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable.getRoleMember', 'start_line': 3217, 'end_line': 3219, 'offset_start': 122757, 'offset_end': 122907, 'content': 'function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable.getRoleMemberCount', 'start_line': 3225, 'end_line': 3227, 'offset_start': 123076, 'offset_end': 123215, 'content': 'function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable._grantRole', 'start_line': 3232, 'end_line': 3235, 'offset_start': 123304, 'offset_end': 123469, 'content': 'function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlEnumerableUpgradeable._revokeRole', 'start_line': 3240, 'end_line': 3243, 'offset_start': 123559, 'offset_end': 123729, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }', 'contract_name': 'AccessControlEnumerableUpgradeable', 'contract_code': '{\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 3304, 'end_line': 3305, 'offset_start': 126176, 'offset_end': 126240, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 3307, 'end_line': 3308, 'offset_start': 126247, 'offset_end': 126321, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 3336, 'end_line': 3338, 'offset_start': 127054, 'offset_end': 127266, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 3343, 'end_line': 3345, 'offset_start': 127354, 'offset_end': 127498, 'content': 'function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 3355, 'end_line': 3357, 'offset_start': 127793, 'offset_end': 127895, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 3366, 'end_line': 3379, 'offset_start': 128177, 'offset_end': 128677, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 3387, 'end_line': 3389, 'offset_start': 128859, 'offset_end': 128987, 'content': 'function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 3403, 'end_line': 3405, 'offset_start': 129284, 'offset_end': 129428, 'content': 'function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 3418, 'end_line': 3420, 'offset_start': 129709, 'offset_end': 129855, 'content': 'function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 3438, 'end_line': 3442, 'offset_start': 130393, 'offset_end': 130606, 'content': 'function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setupRole', 'start_line': 3464, 'end_line': 3466, 'offset_start': 131292, 'offset_end': 131401, 'content': 'function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 3473, 'end_line': 3477, 'offset_start': 131527, 'offset_end': 131773, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 3486, 'end_line': 3491, 'offset_start': 131942, 'offset_end': 132174, 'content': 'function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 3500, 'end_line': 3505, 'offset_start': 132346, 'offset_end': 132579, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4/0x5bcfd99c34cf7e06fc756f6f5ae7400504852bc4.sol'}
