{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 18, 'end_line': 19, 'offset_start': 747, 'offset_end': 805, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 21, 'end_line': 22, 'offset_start': 812, 'offset_end': 880, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 23, 'end_line': 25, 'offset_start': 886, 'offset_end': 981, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 27, 'end_line': 29, 'offset_start': 988, 'offset_end': 1086, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 31, 'end_line': 33, 'offset_start': 1093, 'offset_end': 1189, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.tor', 'start_line': 108, 'end_line': 110, 'offset_start': 4402, 'offset_end': 4448, 'content': 'constructor() {\n    _disableInitializers();\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.initialize', 'start_line': 126, 'end_line': 161, 'offset_start': 5478, 'offset_end': 6665, 'content': 'function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.initializeParentShnarfsAndFinalizedState', 'start_line': 171, 'end_line': 188, 'offset_start': 7258, 'offset_end': 7865, 'content': 'function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.setVerifierAddress', 'start_line': 196, 'end_line': 204, 'offset_start': 8142, 'offset_end': 8504, 'content': 'function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.unsetVerifierAddress', 'start_line': 211, 'end_line': 215, 'offset_start': 8700, 'offset_end': 8921, 'content': 'function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.submitBlobs', 'start_line': 225, 'end_line': 296, 'offset_start': 9418, 'offset_end': 12028, 'content': "function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven't submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don't need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }", 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.submitDataAsCalldata', 'start_line': 305, 'end_line': 345, 'offset_start': 12478, 'offset_end': 14070, 'content': 'function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._validateSubmissionData', 'start_line': 353, 'end_line': 380, 'offset_start': 14404, 'offset_end': 15496, 'content': 'function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._computeLastFinalizedState', 'start_line': 389, 'end_line': 401, 'offset_start': 15883, 'offset_end': 16288, 'content': 'function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._computeShnarf', 'start_line': 412, 'end_line': 428, 'offset_start': 16867, 'offset_end': 17410, 'content': 'function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._verifyPointEvaluation', 'start_line': 439, 'end_line': 471, 'offset_start': 17885, 'offset_end': 19053, 'content': 'function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.finalizeBlocksWithProof', 'start_line': 480, 'end_line': 518, 'offset_start': 19318, 'offset_end': 20559, 'content': 'function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup.finalizeBlocksWithoutProof', 'start_line': 525, 'end_line': 529, 'offset_start': 20742, 'offset_end': 20982, 'content': 'function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._finalizeBlocks', 'start_line': 538, 'end_line': 613, 'offset_start': 21301, 'offset_end': 24002, 'content': 'function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._validateL2ComputedRollingHash', 'start_line': 620, 'end_line': 633, 'offset_start': 24244, 'offset_end': 24824, 'content': 'function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._calculateY', 'start_line': 644, 'end_line': 673, 'offset_start': 25440, 'offset_end': 26320, 'content': 'function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'LineaRollup._computePublicInput', 'start_line': 725, 'end_line': 769, 'offset_start': 28421, 'offset_end': 30231, 'content': 'function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }', 'contract_name': 'LineaRollup', 'contract_code': '{\n  using Utils for *;\n\n  bytes32 public constant VERIFIER_SETTER_ROLE = keccak256("VERIFIER_SETTER_ROLE");\n  bytes32 public constant GENESIS_SHNARF =\n    keccak256(\n      abi.encode(\n        EMPTY_HASH,\n        EMPTY_HASH,\n        0x072ead6777750dc20232d1cee8dc9a395c2d350df4bbaa5096c6f59b214dcecd,\n        EMPTY_HASH,\n        EMPTY_HASH\n      )\n    );\n\n  bytes32 internal constant EMPTY_HASH = 0x0;\n  uint256 internal constant BLS_CURVE_MODULUS =\n    52435875175126190479447740508185965837690552500527637822603658699938581184513;\n  address internal constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0a);\n  uint256 internal constant POINT_EVALUATION_RETURN_DATA_LENGTH = 64;\n  uint256 internal constant POINT_EVALUATION_FIELD_ELEMENTS_LENGTH = 4096;\n\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 finalStateRootHash) public dataFinalStateRootHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 parentHash) public dataParents;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => bytes32 shnarfHash) public dataShnarfHashes;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 startingBlock) public dataStartingBlock;\n  /// @dev DEPRECATED in favor of the single shnarfFinalBlockNumbers mapping.\n  mapping(bytes32 dataHash => uint256 endingBlock) public dataEndingBlock;\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentL2StoredL1MessageNumber;\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  bytes32 public currentL2StoredL1RollingHash;\n\n  bytes32 public currentFinalizedShnarf;\n\n  /**\n   * @dev NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.\n   */\n  mapping(bytes32 shnarf => uint256 finalBlockNumber) public shnarfFinalBlockNumbers;\n\n  /// @dev Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.\n  bytes32 public currentFinalizedState;\n\n  /// @dev Total contract storage is 10 slots.\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes LineaRollup and underlying service dependencies - used for new networks only.\n   * @dev DEFAULT_ADMIN_ROLE is set for the security council.\n   * @dev OPERATOR_ROLE is set for operators.\n   * @dev Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts.\n   * @param _initialStateRootHash The initial hash at migration used for proof verification.\n   * @param _initialL2BlockNumber The initial block number at migration.\n   * @param _defaultVerifier The default verifier for rollup proofs.\n   * @param _securityCouncil The address for the security council performing admin operations.\n   * @param _operators The allowed rollup operators at initialization.\n   * @param _rateLimitPeriodInSeconds The period in which withdrawal amounts and fees will be accumulated.\n   * @param _rateLimitAmountInWei The limit allowed for withdrawing in the rate limit period.\n   * @param _genesisTimestamp The L2 genesis timestamp for first finalization.\n   */\n  function initialize(\n    bytes32 _initialStateRootHash,\n    uint256 _initialL2BlockNumber,\n    address _defaultVerifier,\n    address _securityCouncil,\n    address[] calldata _operators,\n    uint256 _rateLimitPeriodInSeconds,\n    uint256 _rateLimitAmountInWei,\n    uint256 _genesisTimestamp\n  ) external initializer {\n    if (_defaultVerifier == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    for (uint256 i; i < _operators.length; ++i) {\n      if (_operators[i] == address(0)) {\n        revert ZeroAddressNotAllowed();\n      }\n      _grantRole(OPERATOR_ROLE, _operators[i]);\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(VERIFIER_SETTER_ROLE, _securityCouncil);\n\n    __MessageService_init(_securityCouncil, _securityCouncil, _rateLimitPeriodInSeconds, _rateLimitAmountInWei);\n\n    verifiers[0] = _defaultVerifier;\n\n    currentL2BlockNumber = _initialL2BlockNumber;\n    stateRootHashes[_initialL2BlockNumber] = _initialStateRootHash;\n\n    shnarfFinalBlockNumbers[GENESIS_SHNARF] = _initialL2BlockNumber;\n\n    currentFinalizedShnarf = GENESIS_SHNARF;\n    currentFinalizedState = _computeLastFinalizedState(0, EMPTY_HASH, _genesisTimestamp);\n  }\n\n  /**\n   * @notice Initializes LineaRollup, sets the expected shnarfFinalBlockNumbers final block number(s) and sets finalization state.\n   * @dev The initialization will only do the last finalized shnarf and the unfinalized shnarfs of unfinalized data submissions.\n   * @dev Data submission and finalization will be paused temporarily to avoid missing submissions.\n   * @dev currentFinalizedState will also be initialized with existing storage values.\n   * @param _shnarfs The shnarfs to reset.\n   * @param _finalBlockNumbers The final blocks number to reset 1:1 with the shnarfs.\n   */\n  function initializeParentShnarfsAndFinalizedState(\n    bytes32[] calldata _shnarfs,\n    uint256[] calldata _finalBlockNumbers\n  ) external reinitializer(5) {\n    if (_shnarfs.length != _finalBlockNumbers.length) {\n      revert ShnarfAndFinalBlockNumberLengthsMismatched(_shnarfs.length, _finalBlockNumbers.length);\n    }\n\n    for (uint256 i; i < _shnarfs.length; i++) {\n      shnarfFinalBlockNumbers[_shnarfs[i]] = _finalBlockNumbers[i];\n    }\n\n    currentFinalizedState = _computeLastFinalizedState(\n      currentL2StoredL1MessageNumber,\n      currentL2StoredL1RollingHash,\n      currentTimestamp\n    );\n  }\n\n  /**\n   * @notice Adds or updates the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    emit VerifierAddressChanged(_newVerifierAddress, _proofType, msg.sender, verifiers[_proofType]);\n\n    verifiers[_proofType] = _newVerifierAddress;\n  }\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external onlyRole(VERIFIER_SETTER_ROLE) {\n    emit VerifierAddressChanged(address(0), _proofType, msg.sender, verifiers[_proofType]);\n\n    delete verifiers[_proofType];\n  }\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    uint256 blobSubmissionLength = _blobSubmissionData.length;\n\n    if (blobSubmissionLength == 0) {\n      revert BlobSubmissionDataIsMissing();\n    }\n\n    bytes32 currentDataEvaluationPoint;\n    bytes32 currentDataHash;\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    /// @dev Assigning in memory saves a lot of gas vs. calldata reading.\n    BlobSubmissionData memory blobSubmissionData;\n\n    bytes32 computedShnarf = _parentShnarf;\n\n    uint256 blobFinalBlockNumber = shnarfFinalBlockNumbers[computedShnarf];\n\n    for (uint256 i; i < blobSubmissionLength; i++) {\n      blobSubmissionData = _blobSubmissionData[i];\n\n      currentDataHash = blobhash(i);\n\n      if (currentDataHash == EMPTY_HASH) {\n        revert EmptyBlobDataAtIndex(i);\n      }\n\n      _validateSubmissionData(blobSubmissionData.submissionData, blobFinalBlockNumber, lastFinalizedBlockNumber);\n\n      currentDataEvaluationPoint = Utils._efficientKeccak(blobSubmissionData.submissionData.snarkHash, currentDataHash);\n\n      _verifyPointEvaluation(\n        currentDataHash,\n        uint256(currentDataEvaluationPoint),\n        blobSubmissionData.dataEvaluationClaim,\n        blobSubmissionData.kzgCommitment,\n        blobSubmissionData.kzgProof\n      );\n\n      computedShnarf = _computeShnarf(\n        computedShnarf,\n        blobSubmissionData.submissionData.snarkHash,\n        blobSubmissionData.submissionData.finalStateRootHash,\n        currentDataEvaluationPoint,\n        bytes32(blobSubmissionData.dataEvaluationClaim)\n      );\n\n      blobFinalBlockNumber = blobSubmissionData.submissionData.finalBlockInData;\n    }\n\n    if (_finalBlobShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_finalBlobShnarf, computedShnarf);\n    }\n\n    /**\n     * @dev validate we haven\'t submitted the last shnarf.\n     * Note: As only the last shnarf is stored, we don\'t need to validate shnarfs,\n     * computed for any previous blobs in the submission (if multiple are submitted).\n     */\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    /// @dev use the last shnarf as the submission to store as technically it becomes the next parent shnarf.\n    shnarfFinalBlockNumbers[computedShnarf] = blobFinalBlockNumber;\n\n    emit DataSubmittedV2(computedShnarf, _blobSubmissionData[0].submissionData.firstBlockInData, blobFinalBlockNumber);\n  }\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_submissionData.compressedData.length == 0) {\n      revert EmptySubmissionData();\n    }\n\n    SupportingSubmissionDataV2 memory submissionData = SupportingSubmissionDataV2({\n      finalStateRootHash: _submissionData.finalStateRootHash,\n      firstBlockInData: _submissionData.firstBlockInData,\n      finalBlockInData: _submissionData.finalBlockInData,\n      snarkHash: _submissionData.snarkHash\n    });\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    _validateSubmissionData(submissionData, shnarfFinalBlockNumbers[_parentShnarf], currentL2BlockNumber);\n\n    bytes32 dataEvaluationPoint = Utils._efficientKeccak(_submissionData.snarkHash, currentDataHash);\n    bytes32 computedShnarf = _computeShnarf(\n      _parentShnarf,\n      _submissionData.snarkHash,\n      _submissionData.finalStateRootHash,\n      dataEvaluationPoint,\n      _calculateY(_submissionData.compressedData, dataEvaluationPoint)\n    );\n\n    if (_expectedShnarf != computedShnarf) {\n      revert FinalShnarfWrong(_expectedShnarf, computedShnarf);\n    }\n\n    if (shnarfFinalBlockNumbers[computedShnarf] != 0) {\n      revert DataAlreadySubmitted(computedShnarf);\n    }\n\n    shnarfFinalBlockNumbers[computedShnarf] = _submissionData.finalBlockInData;\n\n    emit DataSubmittedV2(computedShnarf, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n  }\n\n  /**\n   * @notice Internal function to validate submission data.\n   * @param _submissionData The supporting data for compressed data submission excluding compressed data.\n   * @param _parentFinalBlockNumber The final block number for the parent blob.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _validateSubmissionData(\n    SupportingSubmissionDataV2 memory _submissionData,\n    uint256 _parentFinalBlockNumber,\n    uint256 _lastFinalizedBlockNumber\n  ) internal pure {\n    if (_submissionData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    if (_submissionData.snarkHash == EMPTY_HASH) {\n      revert SnarkHashIsZeroHash();\n    }\n\n    // for it to be equal the number would have to wrap round twice in overflow..\n    unchecked {\n      if (_parentFinalBlockNumber + 1 != _submissionData.firstBlockInData) {\n        revert DataStartingBlockDoesNotMatch(_parentFinalBlockNumber + 1, _submissionData.firstBlockInData);\n      }\n    }\n\n    if (_submissionData.firstBlockInData <= _lastFinalizedBlockNumber) {\n      revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, _lastFinalizedBlockNumber);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n      revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n  }\n\n  /**\n   * @notice Internal function to compute and save the finalization state.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _messageNumber Is the last L2 computed L1 message number in the finalization.\n   * @param _rollingHash Is the last L2 computed L1 rolling hash in the finalization.\n   * @param _timestamp The final timestamp in the finalization.\n   */\n  function _computeLastFinalizedState(\n    uint256 _messageNumber,\n    bytes32 _rollingHash,\n    uint256 _timestamp\n  ) internal pure returns (bytes32 hashedFinalizationState) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _messageNumber)\n      mstore(add(mPtr, 0x20), _rollingHash)\n      mstore(add(mPtr, 0x40), _timestamp)\n      hashedFinalizationState := keccak256(mPtr, 0x60)\n    }\n  }\n\n  /**\n   * @notice Internal function to compute the shnarf more efficiently.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @param _parentShnarf The shnarf of the parent data item.\n   * @param _snarkHash Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @param _finalStateRootHash The final state root hash of the data being submitted.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   */\n  function _computeShnarf(\n    bytes32 _parentShnarf,\n    bytes32 _snarkHash,\n    bytes32 _finalStateRootHash,\n    bytes32 _dataEvaluationPoint,\n    bytes32 _dataEvaluationClaim\n  ) internal pure returns (bytes32 shnarf) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _parentShnarf)\n      mstore(add(mPtr, 0x20), _snarkHash)\n      mstore(add(mPtr, 0x40), _finalStateRootHash)\n      mstore(add(mPtr, 0x60), _dataEvaluationPoint)\n      mstore(add(mPtr, 0x80), _dataEvaluationClaim)\n      shnarf := keccak256(mPtr, 0xA0)\n    }\n  }\n\n  /**\n   * @notice Performs point evaluation for the compressed blob.\n   * @dev _dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks.\n   * @param _currentDataHash The current blob versioned hash.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @param _dataEvaluationClaim The data evaluation claim.\n   * @param _kzgCommitment The blob KZG commitment.\n   * @param _kzgProof The blob KZG point proof.\n   */\n  function _verifyPointEvaluation(\n    bytes32 _currentDataHash,\n    uint256 _dataEvaluationPoint,\n    uint256 _dataEvaluationClaim,\n    bytes memory _kzgCommitment,\n    bytes memory _kzgProof\n  ) internal view {\n    assembly {\n      _dataEvaluationPoint := mod(_dataEvaluationPoint, BLS_CURVE_MODULUS)\n    }\n\n    (bool success, bytes memory returnData) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n      abi.encodePacked(_currentDataHash, _dataEvaluationPoint, _dataEvaluationClaim, _kzgCommitment, _kzgProof)\n    );\n\n    if (!success) {\n      revert PointEvaluationFailed();\n    }\n\n    if (returnData.length != POINT_EVALUATION_RETURN_DATA_LENGTH) {\n      revert PrecompileReturnDataLengthWrong(POINT_EVALUATION_RETURN_DATA_LENGTH, returnData.length);\n    }\n\n    uint256 fieldElements;\n    uint256 blsCurveModulus;\n    assembly {\n      fieldElements := mload(add(returnData, 32))\n      blsCurveModulus := mload(add(returnData, POINT_EVALUATION_RETURN_DATA_LENGTH))\n    }\n    if (fieldElements != POINT_EVALUATION_FIELD_ELEMENTS_LENGTH || blsCurveModulus != BLS_CURVE_MODULUS) {\n      revert PointEvaluationResponseInvalid(fieldElements, blsCurveModulus);\n    }\n  }\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeAndGeneralNotPaused(PROVING_SYSTEM_PAUSE_TYPE) onlyRole(OPERATOR_ROLE) {\n    if (_aggregatedProof.length == 0) {\n      revert ProofIsEmpty();\n    }\n\n    uint256 lastFinalizedBlockNumber = currentL2BlockNumber;\n\n    if (stateRootHashes[lastFinalizedBlockNumber] != _finalizationData.parentStateRootHash) {\n      revert StartingRootHashDoesNotMatch();\n    }\n\n    bytes32 lastFinalizedShnarf = currentFinalizedShnarf;\n\n    if (_finalizationData.lastFinalizedShnarf != lastFinalizedShnarf) {\n      revert LastFinalizedShnarfWrong(lastFinalizedShnarf, _finalizationData.lastFinalizedShnarf);\n    }\n\n    bytes32 finalShnarf = _finalizeBlocks(_finalizationData, lastFinalizedBlockNumber, true);\n\n    uint256 publicInput = _computePublicInput(\n      _finalizationData,\n      lastFinalizedShnarf,\n      finalShnarf,\n      lastFinalizedBlockNumber\n    );\n\n    _verifyProof(\n      publicInput,\n      _proofType,\n      _aggregatedProof,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.finalBlockInData,\n      _finalizationData.shnarfData.finalStateRootHash\n    );\n  }\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(\n    FinalizationDataV2 calldata _finalizationData\n  ) external whenTypeNotPaused(GENERAL_PAUSE_TYPE) onlyRole(DEFAULT_ADMIN_ROLE) {\n    _finalizeBlocks(_finalizationData, currentL2BlockNumber, false);\n  }\n\n  /**\n   * @notice Internal function to finalize compressed blocks.\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedBlock The last finalized block.\n   * @param _withProof If we are finalizing with a proof.\n   * @return finalShnarf The final computed shnarf in finalizing.\n   */\n  function _finalizeBlocks(\n    FinalizationDataV2 calldata _finalizationData,\n    uint256 _lastFinalizedBlock,\n    bool _withProof\n  ) internal returns (bytes32 finalShnarf) {\n    if (_finalizationData.finalBlockInData <= _lastFinalizedBlock) {\n      revert FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(\n        _finalizationData.finalBlockInData,\n        _lastFinalizedBlock\n      );\n    }\n\n    _validateL2ComputedRollingHash(_finalizationData.l1RollingHashMessageNumber, _finalizationData.l1RollingHash);\n\n    if (\n      _computeLastFinalizedState(\n        _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n        _finalizationData.lastFinalizedL1RollingHash,\n        _finalizationData.lastFinalizedTimestamp\n      ) != currentFinalizedState\n    ) {\n      revert FinalizationStateIncorrect(\n        _computeLastFinalizedState(\n          _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n          _finalizationData.lastFinalizedL1RollingHash,\n          _finalizationData.lastFinalizedTimestamp\n        ),\n        currentFinalizedState\n      );\n    }\n\n    if (_finalizationData.finalTimestamp >= block.timestamp) {\n      revert FinalizationInTheFuture(_finalizationData.finalTimestamp, block.timestamp);\n    }\n\n    if (_finalizationData.shnarfData.finalStateRootHash == EMPTY_HASH) {\n      revert FinalBlockStateEqualsZeroHash();\n    }\n\n    finalShnarf = _computeShnarf(\n      _finalizationData.shnarfData.parentShnarf,\n      _finalizationData.shnarfData.snarkHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _finalizationData.shnarfData.dataEvaluationPoint,\n      _finalizationData.shnarfData.dataEvaluationClaim\n    );\n\n    if (shnarfFinalBlockNumbers[finalShnarf] != _finalizationData.finalBlockInData) {\n      revert FinalBlockDoesNotMatchShnarfFinalBlock(\n        _finalizationData.finalBlockInData,\n        shnarfFinalBlockNumbers[finalShnarf]\n      );\n    }\n\n    _addL2MerkleRoots(_finalizationData.l2MerkleRoots, _finalizationData.l2MerkleTreesDepth);\n    _anchorL2MessagingBlocks(_finalizationData.l2MessagingBlocksOffsets, _lastFinalizedBlock);\n\n    stateRootHashes[_finalizationData.finalBlockInData] = _finalizationData.shnarfData.finalStateRootHash;\n\n    currentL2BlockNumber = _finalizationData.finalBlockInData;\n\n    currentFinalizedShnarf = finalShnarf;\n\n    currentFinalizedState = _computeLastFinalizedState(\n      _finalizationData.l1RollingHashMessageNumber,\n      _finalizationData.l1RollingHash,\n      _finalizationData.finalTimestamp\n    );\n\n    emit DataFinalized(\n      _finalizationData.finalBlockInData,\n      _finalizationData.parentStateRootHash,\n      _finalizationData.shnarfData.finalStateRootHash,\n      _withProof\n    );\n  }\n\n  /**\n   * @notice Internal function to validate l1 rolling hash.\n   * @param _rollingHashMessageNumber Message number associated with the rolling hash as computed on L2.\n   * @param _rollingHash L1 rolling hash as computed on L2.\n   */\n  function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view {\n    if (_rollingHashMessageNumber == 0) {\n      if (_rollingHash != EMPTY_HASH) {\n        revert MissingMessageNumberForRollingHash(_rollingHash);\n      }\n    } else {\n      if (_rollingHash == EMPTY_HASH) {\n        revert MissingRollingHashForMessageNumber(_rollingHashMessageNumber);\n      }\n      if (rollingHashes[_rollingHashMessageNumber] != _rollingHash) {\n        revert L1RollingHashDoesNotExistOnL1(_rollingHashMessageNumber, _rollingHash);\n      }\n    }\n  }\n\n  /**\n   * @notice Internal function to calculate Y for public input generation.\n   * @param _data Compressed data from submission data.\n   * @param _dataEvaluationPoint The data evaluation point.\n   * @dev Each chunk of 32 bytes must start with a 0 byte.\n   * @dev The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.\n   * @dev There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844.\n   * @return compressedDataComputedY The Y calculated value using the Horner method.\n   */\n  function _calculateY(\n    bytes calldata _data,\n    bytes32 _dataEvaluationPoint\n  ) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20 != 0) {\n      revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n      for {\n        let i := _data.length\n      } gt(i, 0) {\n\n      } {\n        i := sub(i, 0x20)\n        let chunk := calldataload(add(_data.offset, i))\n        if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n          let ptr := mload(0x40)\n          mstore(ptr, errorSelector)\n          revert(ptr, 0x4)\n        }\n        compressedDataComputedY := addmod(\n          mulmod(compressedDataComputedY, _dataEvaluationPoint, BLS_CURVE_MODULUS),\n          chunk,\n          BLS_CURVE_MODULUS\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Compute the public input.\n   * @dev Using assembly this way is cheaper gas wise.\n   * @dev NB: the dynamic sized fields are placed last in _finalizationData on purpose to optimise hashing ranges.\n   * @dev Computing the public input as the following:\n   * keccak256(\n   *  abi.encode(\n   *     _lastFinalizedShnarf,\n   *     _finalShnarf,\n   *     _finalizationData.lastFinalizedTimestamp,\n   *     _finalizationData.finalTimestamp,\n   *     _lastFinalizedBlockNumber,\n   *     _finalizationData.finalBlockInData,\n   *     _finalizationData.lastFinalizedL1RollingHash,\n   *     _finalizationData.l1RollingHash,\n   *     _finalizationData.lastFinalizedL1RollingHashMessageNumber,\n   *     _finalizationData.l1RollingHashMessageNumber,\n   *     _finalizationData.l2MerkleTreesDepth,\n   *     keccak256(\n   *         abi.encodePacked(_finalizationData.l2MerkleRoots)\n   *     )\n   *   )\n   * )\n   * Data is found at the following offsets:\n   * 0x00    parentStateRootHash\n   * 0x20    lastFinalizedShnarf\n   * 0x40    finalBlockInData\n   * 0x60    shnarfData.parentShnarf\n   * 0x80    shnarfData.snarkHash\n   * 0xa0    shnarfData.finalStateRootHash\n   * 0xc0    shnarfData.dataEvaluationPoint\n   * 0xe0    shnarfData.dataEvaluationClaim\n   * 0x100   lastFinalizedTimestamp\n   * 0x120   finalTimestamp\n   * 0x140   lastFinalizedL1RollingHash\n   * 0x160   l1RollingHash\n   * 0x180   lastFinalizedL1RollingHashMessageNumber\n   * 0x1a0   l1RollingHashMessageNumber\n   * 0x1c0   l2MerkleTreesDepth\n   * 0x1e0   l2MerkleRootsLengthLocation\n   * 0x200   l2MessagingBlocksOffsetsLengthLocation\n   * 0x220   l2MerkleRootsLength\n   * 0x240   l2MerkleRoots\n   * Dynamic l2MessagingBlocksOffsetsLength (location depends on where l2MerkleRoots ends)\n   * Dynamic l2MessagingBlocksOffsets (location depends on where l2MerkleRoots ends)\n   * @param _finalizationData The full finalization data.\n   * @param _lastFinalizedShnarf The last finalized shnarf.\n   * @param _finalShnarf The final shnarf in the finalization.\n   * @param _lastFinalizedBlockNumber The last finalized block number.\n   */\n  function _computePublicInput(\n    FinalizationDataV2 calldata _finalizationData,\n    bytes32 _lastFinalizedShnarf,\n    bytes32 _finalShnarf,\n    uint256 _lastFinalizedBlockNumber\n  ) private pure returns (uint256 publicInput) {\n    assembly {\n      let mPtr := mload(0x40)\n      mstore(mPtr, _lastFinalizedShnarf)\n      mstore(add(mPtr, 0x20), _finalShnarf)\n\n      /**\n       * _finalizationData.lastFinalizedTimestamp\n       * _finalizationData.finalTimestamp\n       */\n      calldatacopy(add(mPtr, 0x40), add(_finalizationData, 0x100), 0x40)\n\n      mstore(add(mPtr, 0x80), _lastFinalizedBlockNumber)\n\n      // _finalizationData.finalBlockInData\n      calldatacopy(add(mPtr, 0xA0), add(_finalizationData, 0x40), 0x20)\n\n      /**\n       * _finalizationData.lastFinalizedL1RollingHash\n       * _finalizationData.l1RollingHash\n       * _finalizationData.lastFinalizedL1RollingHashMessageNumber\n       * _finalizationData.l1RollingHashMessageNumber\n       * _finalizationData.l2MerkleTreesDepth\n       */\n      calldatacopy(add(mPtr, 0xC0), add(_finalizationData, 0x140), 0xA0)\n\n      /**\n       * @dev Note the following in hashing the _finalizationData.l2MerkleRoots array:\n       * The second memory pointer and free pointer are offset by 0x20 to temporarily hash the array outside the scope of working memory,\n       * as we need the space left for the array hash to be stored at 0x160.\n       */\n      let mPtrMerkleRoot := add(mPtr, 0x180)\n      let merkleRootsLen := calldataload(add(_finalizationData, 0x220))\n      calldatacopy(mPtrMerkleRoot, add(_finalizationData, 0x240), mul(merkleRootsLen, 0x20))\n      let l2MerkleRootsHash := keccak256(mPtrMerkleRoot, mul(merkleRootsLen, 0x20))\n      mstore(add(mPtr, 0x160), l2MerkleRootsHash)\n\n      publicInput := mod(keccak256(mPtr, 0x180), MODULO_R)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IRateLimiter.resetRateLimitAmount', 'start_line': 830, 'end_line': 830, 'offset_start': 32400, 'offset_end': 32455, 'content': 'function resetRateLimitAmount(uint256 _amount) external;', 'contract_name': 'IRateLimiter', 'contract_code': '{\n  /**\n   * @notice Emitted when the Rate Limit is initialized.\n   * @param periodInSeconds The time period in seconds the rate limiter has been initialized to.\n   * @param limitInWei The limit in Wei the rate limiter has been initialized to.\n   * @param currentPeriodEnd The time the current rate limit period will end.\n   */\n  event RateLimitInitialized(uint256 periodInSeconds, uint256 limitInWei, uint256 currentPeriodEnd);\n\n  /**\n   * @notice Emitted when the amount in the period is reset to zero.\n   * @param resettingAddress The indexed address of who reset the used amount back to zero.\n   */\n  event AmountUsedInPeriodReset(address indexed resettingAddress);\n\n  /**\n   * @notice Emitted when the limit is changed.\n   * @param amountChangeBy The indexed address of who changed the rate limit.\n   * @param amount The rate limited amount in Wei that was set.\n   * @param amountUsedLoweredToLimit Indicates if the amount used was lowered to the limit to avoid confusion.\n   * @param usedAmountResetToZero Indicates if the amount used was set to zero because of the current period expiring.\n   * @dev If the current used amount is higher than the new limit, the used amount is lowered to the limit.\n   * @dev amountUsedLoweredToLimit and usedAmountResetToZero cannot be true at the same time.\n   */\n  event LimitAmountChanged(\n    address indexed amountChangeBy,\n    uint256 amount,\n    bool amountUsedLoweredToLimit,\n    bool usedAmountResetToZero\n  );\n\n  /**\n   * @dev Thrown when an amount breaches the limit in the period.\n   */\n  error RateLimitExceeded();\n\n  /**\n   * @dev Thrown when the period is initialised to zero.\n   */\n  error PeriodIsZero();\n\n  /**\n   * @dev Thrown when the limit is initialised to zero.\n   */\n  error LimitIsZero();\n\n  /**\n   * @notice Resets the rate limit amount to the amount specified.\n   * @param _amount sets the new limit amount.\n   */\n  function resetRateLimitAmount(uint256 _amount) external;\n\n  /**\n   * @notice Resets the amount used in the period to zero.\n   */\n  function resetAmountUsedInPeriod() external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IRateLimiter.resetAmountUsedInPeriod', 'start_line': 835, 'end_line': 835, 'offset_start': 32531, 'offset_end': 32574, 'content': 'function resetAmountUsedInPeriod() external;', 'contract_name': 'IRateLimiter', 'contract_code': '{\n  /**\n   * @notice Emitted when the Rate Limit is initialized.\n   * @param periodInSeconds The time period in seconds the rate limiter has been initialized to.\n   * @param limitInWei The limit in Wei the rate limiter has been initialized to.\n   * @param currentPeriodEnd The time the current rate limit period will end.\n   */\n  event RateLimitInitialized(uint256 periodInSeconds, uint256 limitInWei, uint256 currentPeriodEnd);\n\n  /**\n   * @notice Emitted when the amount in the period is reset to zero.\n   * @param resettingAddress The indexed address of who reset the used amount back to zero.\n   */\n  event AmountUsedInPeriodReset(address indexed resettingAddress);\n\n  /**\n   * @notice Emitted when the limit is changed.\n   * @param amountChangeBy The indexed address of who changed the rate limit.\n   * @param amount The rate limited amount in Wei that was set.\n   * @param amountUsedLoweredToLimit Indicates if the amount used was lowered to the limit to avoid confusion.\n   * @param usedAmountResetToZero Indicates if the amount used was set to zero because of the current period expiring.\n   * @dev If the current used amount is higher than the new limit, the used amount is lowered to the limit.\n   * @dev amountUsedLoweredToLimit and usedAmountResetToZero cannot be true at the same time.\n   */\n  event LimitAmountChanged(\n    address indexed amountChangeBy,\n    uint256 amount,\n    bool amountUsedLoweredToLimit,\n    bool usedAmountResetToZero\n  );\n\n  /**\n   * @dev Thrown when an amount breaches the limit in the period.\n   */\n  error RateLimitExceeded();\n\n  /**\n   * @dev Thrown when the period is initialised to zero.\n   */\n  error PeriodIsZero();\n\n  /**\n   * @dev Thrown when the limit is initialised to zero.\n   */\n  error LimitIsZero();\n\n  /**\n   * @notice Resets the rate limit amount to the amount specified.\n   * @param _amount sets the new limit amount.\n   */\n  function resetRateLimitAmount(uint256 _amount) external;\n\n  /**\n   * @notice Resets the amount used in the period to zero.\n   */\n  function resetAmountUsedInPeriod() external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageService.__MessageService_init', 'start_line': 879, 'end_line': 902, 'offset_start': 34387, 'offset_end': 35042, 'content': 'function __MessageService_init(\n    address _limitManagerAddress,\n    address _pauseManagerAddress,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) internal onlyInitializing {\n    if (_limitManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_pauseManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _limitManagerAddress);\n    _grantRole(PAUSE_MANAGER_ROLE, _pauseManagerAddress);\n\n    nextMessageNumber = 1;\n  }', 'contract_name': 'L1MessageService', 'contract_code': '{\n  using SparseMerkleTreeVerifier for *;\n  using TransientStorageHelpers for *;\n\n  /// @dev This is currently not in use, but is reserved for future upgrades.\n  uint256 public systemMigrationBlock;\n\n  /// @dev Total contract storage is 51 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageService;\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @dev _messageSender is initialised to a non-zero value for gas efficiency on claiming.\n   * @param _limitManagerAddress The address owning the rate limiting management role.\n   * @param _pauseManagerAddress The address owning the pause management role.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   */\n  function __MessageService_init(\n    address _limitManagerAddress,\n    address _pauseManagerAddress,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) internal onlyInitializing {\n    if (_limitManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_pauseManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _limitManagerAddress);\n    _grantRole(PAUSE_MANAGER_ROLE, _pauseManagerAddress);\n\n    nextMessageNumber = 1;\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits MessageSent.\n   * @dev The message number is preset (nextMessageNumber) and only incremented at the end if successful for the next caller.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   */\n  function sendMessage(\n    address _to,\n    uint256 _fee,\n    bytes calldata _calldata\n  ) external payable whenTypeAndGeneralNotPaused(L1_L2_PAUSE_TYPE) {\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 messageNumber = nextMessageNumber++;\n    uint256 valueSent = msg.value - _fee;\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, _fee, valueSent, messageNumber, _calldata));\n\n    _addRollingHash(messageNumber, messageHash);\n\n    emit MessageSent(msg.sender, _to, _fee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message using merkle proof.\n   * @dev if merkle depth is empty, it will revert with L2MerkleRootDoesNotExist.\n   * @dev if merkle depth is different than proof size, it will revert with ProofLengthDifferentThanMerkleDepth.\n   * @param _params Collection of claim data with proof and supporting data.\n   */\n  function claimMessageWithProof(\n    ClaimMessageWithProofParams calldata _params\n  ) external nonReentrant distributeFees(_params.fee, _params.to, _params.data, _params.feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    uint256 merkleDepth = l2MerkleRootsDepths[_params.merkleRoot];\n\n    if (merkleDepth == 0) {\n      revert L2MerkleRootDoesNotExist();\n    }\n\n    if (merkleDepth != _params.proof.length) {\n      revert ProofLengthDifferentThanMerkleDepth(merkleDepth, _params.proof.length);\n    }\n\n    _setL2L1MessageToClaimed(_params.messageNumber);\n\n    _addUsedAmount(_params.fee + _params.value);\n\n    bytes32 messageLeafHash = keccak256(\n      abi.encode(_params.from, _params.to, _params.fee, _params.value, _params.messageNumber, _params.data)\n    );\n\n    if (\n      !SparseMerkleTreeVerifier._verifyMerkleProof(\n        messageLeafHash,\n        _params.proof,\n        _params.leafIndex,\n        _params.merkleRoot\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _params.from);\n\n    (bool callSuccess, bytes memory returnData) = _params.to.call{ value: _params.value }(_params.data);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_params.to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageLeafHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev The message sender address is set temporarily in the transient storage when claiming.\n   * @return addr The message sender address that is stored temporarily in the transient storage when claiming.\n   */\n  function sender() external view returns (address addr) {\n    return TransientStorageHelpers.tloadAddress(MESSAGE_SENDER_TRANSIENT_KEY);\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageService.sendMessage', 'start_line': 912, 'end_line': 933, 'offset_start': 35562, 'offset_end': 36207, 'content': 'function sendMessage(\n    address _to,\n    uint256 _fee,\n    bytes calldata _calldata\n  ) external payable whenTypeAndGeneralNotPaused(L1_L2_PAUSE_TYPE) {\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 messageNumber = nextMessageNumber++;\n    uint256 valueSent = msg.value - _fee;\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, _fee, valueSent, messageNumber, _calldata));\n\n    _addRollingHash(messageNumber, messageHash);\n\n    emit MessageSent(msg.sender, _to, _fee, valueSent, messageNumber, _calldata, messageHash);\n  }', 'contract_name': 'L1MessageService', 'contract_code': '{\n  using SparseMerkleTreeVerifier for *;\n  using TransientStorageHelpers for *;\n\n  /// @dev This is currently not in use, but is reserved for future upgrades.\n  uint256 public systemMigrationBlock;\n\n  /// @dev Total contract storage is 51 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageService;\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @dev _messageSender is initialised to a non-zero value for gas efficiency on claiming.\n   * @param _limitManagerAddress The address owning the rate limiting management role.\n   * @param _pauseManagerAddress The address owning the pause management role.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   */\n  function __MessageService_init(\n    address _limitManagerAddress,\n    address _pauseManagerAddress,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) internal onlyInitializing {\n    if (_limitManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_pauseManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _limitManagerAddress);\n    _grantRole(PAUSE_MANAGER_ROLE, _pauseManagerAddress);\n\n    nextMessageNumber = 1;\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits MessageSent.\n   * @dev The message number is preset (nextMessageNumber) and only incremented at the end if successful for the next caller.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   */\n  function sendMessage(\n    address _to,\n    uint256 _fee,\n    bytes calldata _calldata\n  ) external payable whenTypeAndGeneralNotPaused(L1_L2_PAUSE_TYPE) {\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 messageNumber = nextMessageNumber++;\n    uint256 valueSent = msg.value - _fee;\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, _fee, valueSent, messageNumber, _calldata));\n\n    _addRollingHash(messageNumber, messageHash);\n\n    emit MessageSent(msg.sender, _to, _fee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message using merkle proof.\n   * @dev if merkle depth is empty, it will revert with L2MerkleRootDoesNotExist.\n   * @dev if merkle depth is different than proof size, it will revert with ProofLengthDifferentThanMerkleDepth.\n   * @param _params Collection of claim data with proof and supporting data.\n   */\n  function claimMessageWithProof(\n    ClaimMessageWithProofParams calldata _params\n  ) external nonReentrant distributeFees(_params.fee, _params.to, _params.data, _params.feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    uint256 merkleDepth = l2MerkleRootsDepths[_params.merkleRoot];\n\n    if (merkleDepth == 0) {\n      revert L2MerkleRootDoesNotExist();\n    }\n\n    if (merkleDepth != _params.proof.length) {\n      revert ProofLengthDifferentThanMerkleDepth(merkleDepth, _params.proof.length);\n    }\n\n    _setL2L1MessageToClaimed(_params.messageNumber);\n\n    _addUsedAmount(_params.fee + _params.value);\n\n    bytes32 messageLeafHash = keccak256(\n      abi.encode(_params.from, _params.to, _params.fee, _params.value, _params.messageNumber, _params.data)\n    );\n\n    if (\n      !SparseMerkleTreeVerifier._verifyMerkleProof(\n        messageLeafHash,\n        _params.proof,\n        _params.leafIndex,\n        _params.merkleRoot\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _params.from);\n\n    (bool callSuccess, bytes memory returnData) = _params.to.call{ value: _params.value }(_params.data);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_params.to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageLeafHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev The message sender address is set temporarily in the transient storage when claiming.\n   * @return addr The message sender address that is stored temporarily in the transient storage when claiming.\n   */\n  function sender() external view returns (address addr) {\n    return TransientStorageHelpers.tloadAddress(MESSAGE_SENDER_TRANSIENT_KEY);\n  }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageService.claimMessageWithProof', 'start_line': 941, 'end_line': 992, 'offset_start': 36571, 'offset_end': 38189, 'content': 'function claimMessageWithProof(\n    ClaimMessageWithProofParams calldata _params\n  ) external nonReentrant distributeFees(_params.fee, _params.to, _params.data, _params.feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    uint256 merkleDepth = l2MerkleRootsDepths[_params.merkleRoot];\n\n    if (merkleDepth == 0) {\n      revert L2MerkleRootDoesNotExist();\n    }\n\n    if (merkleDepth != _params.proof.length) {\n      revert ProofLengthDifferentThanMerkleDepth(merkleDepth, _params.proof.length);\n    }\n\n    _setL2L1MessageToClaimed(_params.messageNumber);\n\n    _addUsedAmount(_params.fee + _params.value);\n\n    bytes32 messageLeafHash = keccak256(\n      abi.encode(_params.from, _params.to, _params.fee, _params.value, _params.messageNumber, _params.data)\n    );\n\n    if (\n      !SparseMerkleTreeVerifier._verifyMerkleProof(\n        messageLeafHash,\n        _params.proof,\n        _params.leafIndex,\n        _params.merkleRoot\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _params.from);\n\n    (bool callSuccess, bytes memory returnData) = _params.to.call{ value: _params.value }(_params.data);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_params.to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageLeafHash);\n  }', 'contract_name': 'L1MessageService', 'contract_code': '{\n  using SparseMerkleTreeVerifier for *;\n  using TransientStorageHelpers for *;\n\n  /// @dev This is currently not in use, but is reserved for future upgrades.\n  uint256 public systemMigrationBlock;\n\n  /// @dev Total contract storage is 51 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageService;\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @dev _messageSender is initialised to a non-zero value for gas efficiency on claiming.\n   * @param _limitManagerAddress The address owning the rate limiting management role.\n   * @param _pauseManagerAddress The address owning the pause management role.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   */\n  function __MessageService_init(\n    address _limitManagerAddress,\n    address _pauseManagerAddress,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) internal onlyInitializing {\n    if (_limitManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_pauseManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _limitManagerAddress);\n    _grantRole(PAUSE_MANAGER_ROLE, _pauseManagerAddress);\n\n    nextMessageNumber = 1;\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits MessageSent.\n   * @dev The message number is preset (nextMessageNumber) and only incremented at the end if successful for the next caller.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   */\n  function sendMessage(\n    address _to,\n    uint256 _fee,\n    bytes calldata _calldata\n  ) external payable whenTypeAndGeneralNotPaused(L1_L2_PAUSE_TYPE) {\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 messageNumber = nextMessageNumber++;\n    uint256 valueSent = msg.value - _fee;\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, _fee, valueSent, messageNumber, _calldata));\n\n    _addRollingHash(messageNumber, messageHash);\n\n    emit MessageSent(msg.sender, _to, _fee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message using merkle proof.\n   * @dev if merkle depth is empty, it will revert with L2MerkleRootDoesNotExist.\n   * @dev if merkle depth is different than proof size, it will revert with ProofLengthDifferentThanMerkleDepth.\n   * @param _params Collection of claim data with proof and supporting data.\n   */\n  function claimMessageWithProof(\n    ClaimMessageWithProofParams calldata _params\n  ) external nonReentrant distributeFees(_params.fee, _params.to, _params.data, _params.feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    uint256 merkleDepth = l2MerkleRootsDepths[_params.merkleRoot];\n\n    if (merkleDepth == 0) {\n      revert L2MerkleRootDoesNotExist();\n    }\n\n    if (merkleDepth != _params.proof.length) {\n      revert ProofLengthDifferentThanMerkleDepth(merkleDepth, _params.proof.length);\n    }\n\n    _setL2L1MessageToClaimed(_params.messageNumber);\n\n    _addUsedAmount(_params.fee + _params.value);\n\n    bytes32 messageLeafHash = keccak256(\n      abi.encode(_params.from, _params.to, _params.fee, _params.value, _params.messageNumber, _params.data)\n    );\n\n    if (\n      !SparseMerkleTreeVerifier._verifyMerkleProof(\n        messageLeafHash,\n        _params.proof,\n        _params.leafIndex,\n        _params.merkleRoot\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _params.from);\n\n    (bool callSuccess, bytes memory returnData) = _params.to.call{ value: _params.value }(_params.data);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_params.to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageLeafHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev The message sender address is set temporarily in the transient storage when claiming.\n   * @return addr The message sender address that is stored temporarily in the transient storage when claiming.\n   */\n  function sender() external view returns (address addr) {\n    return TransientStorageHelpers.tloadAddress(MESSAGE_SENDER_TRANSIENT_KEY);\n  }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageService.sender', 'start_line': 999, 'end_line': 1001, 'offset_start': 38470, 'offset_end': 38608, 'content': 'function sender() external view returns (address addr) {\n    return TransientStorageHelpers.tloadAddress(MESSAGE_SENDER_TRANSIENT_KEY);\n  }', 'contract_name': 'L1MessageService', 'contract_code': '{\n  using SparseMerkleTreeVerifier for *;\n  using TransientStorageHelpers for *;\n\n  /// @dev This is currently not in use, but is reserved for future upgrades.\n  uint256 public systemMigrationBlock;\n\n  /// @dev Total contract storage is 51 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageService;\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @dev _messageSender is initialised to a non-zero value for gas efficiency on claiming.\n   * @param _limitManagerAddress The address owning the rate limiting management role.\n   * @param _pauseManagerAddress The address owning the pause management role.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   */\n  function __MessageService_init(\n    address _limitManagerAddress,\n    address _pauseManagerAddress,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) internal onlyInitializing {\n    if (_limitManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_pauseManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _limitManagerAddress);\n    _grantRole(PAUSE_MANAGER_ROLE, _pauseManagerAddress);\n\n    nextMessageNumber = 1;\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits MessageSent.\n   * @dev The message number is preset (nextMessageNumber) and only incremented at the end if successful for the next caller.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   */\n  function sendMessage(\n    address _to,\n    uint256 _fee,\n    bytes calldata _calldata\n  ) external payable whenTypeAndGeneralNotPaused(L1_L2_PAUSE_TYPE) {\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 messageNumber = nextMessageNumber++;\n    uint256 valueSent = msg.value - _fee;\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, _fee, valueSent, messageNumber, _calldata));\n\n    _addRollingHash(messageNumber, messageHash);\n\n    emit MessageSent(msg.sender, _to, _fee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message using merkle proof.\n   * @dev if merkle depth is empty, it will revert with L2MerkleRootDoesNotExist.\n   * @dev if merkle depth is different than proof size, it will revert with ProofLengthDifferentThanMerkleDepth.\n   * @param _params Collection of claim data with proof and supporting data.\n   */\n  function claimMessageWithProof(\n    ClaimMessageWithProofParams calldata _params\n  ) external nonReentrant distributeFees(_params.fee, _params.to, _params.data, _params.feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    uint256 merkleDepth = l2MerkleRootsDepths[_params.merkleRoot];\n\n    if (merkleDepth == 0) {\n      revert L2MerkleRootDoesNotExist();\n    }\n\n    if (merkleDepth != _params.proof.length) {\n      revert ProofLengthDifferentThanMerkleDepth(merkleDepth, _params.proof.length);\n    }\n\n    _setL2L1MessageToClaimed(_params.messageNumber);\n\n    _addUsedAmount(_params.fee + _params.value);\n\n    bytes32 messageLeafHash = keccak256(\n      abi.encode(_params.from, _params.to, _params.fee, _params.value, _params.messageNumber, _params.data)\n    );\n\n    if (\n      !SparseMerkleTreeVerifier._verifyMerkleProof(\n        messageLeafHash,\n        _params.proof,\n        _params.leafIndex,\n        _params.merkleRoot\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _params.from);\n\n    (bool callSuccess, bytes memory returnData) = _params.to.call{ value: _params.value }(_params.data);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_params.to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageLeafHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev The message sender address is set temporarily in the transient storage when claiming.\n   * @return addr The message sender address that is stored temporarily in the transient storage when claiming.\n   */\n  function sender() external view returns (address addr) {\n    return TransientStorageHelpers.tloadAddress(MESSAGE_SENDER_TRANSIENT_KEY);\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'TransientStorageReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1038, 'end_line': 1044, 'offset_start': 39737, 'offset_end': 39996, 'content': 'function _nonReentrantBefore() private {\n    if (TransientStorageHelpers.tloadUint256(REENTRANCY_GUARD_TRANSIENT_KEY) != NOT_ENTERED) {\n      revert ReentrantCall();\n    }\n\n    TransientStorageHelpers.tstoreUint256(REENTRANCY_GUARD_TRANSIENT_KEY, ENTERED);\n  }', 'contract_name': 'TransientStorageReentrancyGuardUpgradeable', 'contract_code': '{\n  using TransientStorageHelpers for *;\n\n  bytes32 private constant REENTRANCY_GUARD_TRANSIENT_KEY =\n    bytes32(uint256(keccak256("eip1967.reentrancy.guard.transient.key")) - 1);\n\n  uint256 private constant NOT_ENTERED = 0;\n  uint256 private constant ENTERED = 1;\n\n  error ReentrantCall();\n\n  /// @dev This gap is used to not shift down the storage layout after removing the OpenZeppelin ReentrancyGuardUpgradeable contract.\n  uint256[50] private __gap_ReentrancyGuardUpgradeable;\n\n  modifier nonReentrant() {\n    _nonReentrantBefore();\n    _;\n    _nonReentrantAfter();\n  }\n\n  /**\n   * @notice Checks reentrancy and if not reentrant sets the transient reentry flag.\n   * @dev This uses the TransientStorageHelpers library and REENTRANCY_GUARD_TRANSIENT_KEY.\n   */\n  function _nonReentrantBefore() private {\n    if (TransientStorageHelpers.tloadUint256(REENTRANCY_GUARD_TRANSIENT_KEY) != NOT_ENTERED) {\n      revert ReentrantCall();\n    }\n\n    TransientStorageHelpers.tstoreUint256(REENTRANCY_GUARD_TRANSIENT_KEY, ENTERED);\n  }\n\n  /**\n   * @notice Clears reentry transient storage flag.\n   * @dev This uses the TransientStorageHelpers library and REENTRANCY_GUARD_TRANSIENT_KEY.\n   */\n  function _nonReentrantAfter() private {\n    TransientStorageHelpers.tstoreUint256(REENTRANCY_GUARD_TRANSIENT_KEY, NOT_ENTERED);\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'TransientStorageReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1050, 'end_line': 1052, 'offset_start': 40157, 'offset_end': 40287, 'content': 'function _nonReentrantAfter() private {\n    TransientStorageHelpers.tstoreUint256(REENTRANCY_GUARD_TRANSIENT_KEY, NOT_ENTERED);\n  }', 'contract_name': 'TransientStorageReentrancyGuardUpgradeable', 'contract_code': '{\n  using TransientStorageHelpers for *;\n\n  bytes32 private constant REENTRANCY_GUARD_TRANSIENT_KEY =\n    bytes32(uint256(keccak256("eip1967.reentrancy.guard.transient.key")) - 1);\n\n  uint256 private constant NOT_ENTERED = 0;\n  uint256 private constant ENTERED = 1;\n\n  error ReentrantCall();\n\n  /// @dev This gap is used to not shift down the storage layout after removing the OpenZeppelin ReentrancyGuardUpgradeable contract.\n  uint256[50] private __gap_ReentrancyGuardUpgradeable;\n\n  modifier nonReentrant() {\n    _nonReentrantBefore();\n    _;\n    _nonReentrantAfter();\n  }\n\n  /**\n   * @notice Checks reentrancy and if not reentrant sets the transient reentry flag.\n   * @dev This uses the TransientStorageHelpers library and REENTRANCY_GUARD_TRANSIENT_KEY.\n   */\n  function _nonReentrantBefore() private {\n    if (TransientStorageHelpers.tloadUint256(REENTRANCY_GUARD_TRANSIENT_KEY) != NOT_ENTERED) {\n      revert ReentrantCall();\n    }\n\n    TransientStorageHelpers.tstoreUint256(REENTRANCY_GUARD_TRANSIENT_KEY, ENTERED);\n  }\n\n  /**\n   * @notice Clears reentry transient storage flag.\n   * @dev This uses the TransientStorageHelpers library and REENTRANCY_GUARD_TRANSIENT_KEY.\n   */\n  function _nonReentrantAfter() private {\n    TransientStorageHelpers.tstoreUint256(REENTRANCY_GUARD_TRANSIENT_KEY, NOT_ENTERED);\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.hasRole', 'start_line': 1094, 'end_line': 1094, 'offset_start': 41724, 'offset_end': 41800, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.getRoleAdmin', 'start_line': 1102, 'end_line': 1102, 'offset_start': 41996, 'offset_end': 42063, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.grantRole', 'start_line': 1114, 'end_line': 1114, 'offset_start': 42314, 'offset_end': 42372, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.revokeRole', 'start_line': 1125, 'end_line': 1125, 'offset_start': 42607, 'offset_end': 42666, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.renounceRole', 'start_line': 1141, 'end_line': 1141, 'offset_start': 43158, 'offset_end': 43219, 'content': 'function renounceRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ZkEvmV2._verifyProof', 'start_line': 1184, 'end_line': 1207, 'offset_start': 45321, 'offset_end': 45986, 'content': 'function _verifyProof(\n    uint256 _publicInputHash,\n    uint256 _proofType,\n    bytes calldata _proof,\n    bytes32 _parentStateRootHash,\n    uint256 _finalizedL2BlockNumber,\n    bytes32 _finalStateRootHash\n  ) internal {\n    uint256[] memory input = new uint256[](1);\n    input[0] = _publicInputHash;\n\n    address verifierToUse = verifiers[_proofType];\n\n    if (verifierToUse == address(0)) {\n      revert InvalidProofType();\n    }\n\n    bool success = IPlonkVerifier(verifierToUse).Verify(_proof, input);\n    if (!success) {\n      revert InvalidProof();\n    }\n\n    emit BlocksVerificationDone(_finalizedL2BlockNumber, _parentStateRootHash, _finalStateRootHash);\n  }', 'contract_name': 'ZkEvmV2', 'contract_code': '{\n  uint256 internal constant MODULO_R = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");\n\n  /// @dev DEPRECATED in favor of currentFinalizedState hash.\n  uint256 public currentTimestamp;\n\n  uint256 public currentL2BlockNumber;\n\n  mapping(uint256 blockNumber => bytes32 stateRootHash) public stateRootHashes;\n  mapping(uint256 proofType => address verifierAddress) public verifiers;\n\n  /// @dev Total contract storage is 54 slots with the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /**\n   * @notice Verifies the proof with locally computed public inputs.\n   * @dev If the verifier based on proof type is not found, it reverts with InvalidProofType.\n   * @param _publicInputHash The full BlockData collection - block, transaction and log data.\n   * @param _proofType The proof type to determine which verifier contract to use.\n   * @param _proof The proof to be verified with the proof type verifier contract.\n   * @param _parentStateRootHash The beginning roothash to start with.\n   * @param _finalizedL2BlockNumber The final L2 block number being finalized.\n   * @param _finalStateRootHash The state root finalized up until.\n   */\n  function _verifyProof(\n    uint256 _publicInputHash,\n    uint256 _proofType,\n    bytes calldata _proof,\n    bytes32 _parentStateRootHash,\n    uint256 _finalizedL2BlockNumber,\n    bytes32 _finalStateRootHash\n  ) internal {\n    uint256[] memory input = new uint256[](1);\n    input[0] = _publicInputHash;\n\n    address verifierToUse = verifiers[_proofType];\n\n    if (verifierToUse == address(0)) {\n      revert InvalidProofType();\n    }\n\n    bool success = IPlonkVerifier(verifierToUse).Verify(_proof, input);\n    if (!success) {\n      revert InvalidProof();\n    }\n\n    emit BlocksVerificationDone(_finalizedL2BlockNumber, _parentStateRootHash, _finalStateRootHash);\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 1233, 'end_line': 1234, 'offset_start': 46874, 'offset_end': 46931, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 1236, 'end_line': 1237, 'offset_start': 46938, 'offset_end': 47005, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 1241, 'end_line': 1243, 'offset_start': 47072, 'offset_end': 47237, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'RateLimiter.__RateLimiter_init', 'start_line': 1289, 'end_line': 1303, 'offset_start': 49136, 'offset_end': 49581, 'content': 'function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal onlyInitializing {\n    if (_periodInSeconds == 0) {\n      revert PeriodIsZero();\n    }\n\n    if (_limitInWei == 0) {\n      revert LimitIsZero();\n    }\n\n    periodInSeconds = _periodInSeconds;\n    limitInWei = _limitInWei;\n    currentPeriodEnd = block.timestamp + _periodInSeconds;\n\n    emit RateLimitInitialized(periodInSeconds, limitInWei, currentPeriodEnd);\n  }', 'contract_name': 'RateLimiter', 'contract_code': '{\n  bytes32 public constant RATE_LIMIT_SETTER_ROLE = keccak256("RATE_LIMIT_SETTER_ROLE");\n\n  uint256 public periodInSeconds; // how much time before limit resets.\n  uint256 public limitInWei; // max ether to withdraw per period.\n\n  /// @dev Public for ease of consumption.\n  /// @notice The time at which the current period ends at.\n  uint256 public currentPeriodEnd;\n\n  /// @dev Public for ease of consumption.\n  /// @notice Amounts already withdrawn this period.\n  uint256 public currentPeriodAmountInWei;\n\n  /// @dev Total contract storage is 14 slots with the gap below.\n  /// @dev Keep 10 free storage slots for future implementation updates to avoid storage collision.\n  uint256[10] private __gap;\n\n  /**\n   * @notice Initialises the limits and period for the rate limiter.\n   * @param _periodInSeconds The length of the period in seconds.\n   * @param _limitInWei The limit allowed in the period in Wei.\n   */\n  function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal onlyInitializing {\n    if (_periodInSeconds == 0) {\n      revert PeriodIsZero();\n    }\n\n    if (_limitInWei == 0) {\n      revert LimitIsZero();\n    }\n\n    periodInSeconds = _periodInSeconds;\n    limitInWei = _limitInWei;\n    currentPeriodEnd = block.timestamp + _periodInSeconds;\n\n    emit RateLimitInitialized(periodInSeconds, limitInWei, currentPeriodEnd);\n  }\n\n  /**\n   * @notice Increments the amount used in the period.\n   * @dev The amount determining logic is external to this (e.g. fees are included when calling here).\n   * @dev Reverts if the limit is breached.\n   * @param _usedAmount The amount used to be added.\n   */\n  function _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      currentPeriodAmountTemp = _usedAmount;\n    } else {\n      currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n      revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n  }\n\n  /**\n   * @notice Resets the rate limit amount.\n   * @dev If the used amount is higher, it is set to the limit to avoid confusion/issues.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the LimitAmountChanged event.\n   * @dev usedLimitAmountToSet will use the default value of zero if period has expired\n   * @param _amount The amount to reset the limit to.\n   */\n  function resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    uint256 usedLimitAmountToSet;\n    bool amountUsedLoweredToLimit;\n    bool usedAmountResetToZero;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      usedAmountResetToZero = true;\n    } else {\n      if (_amount < currentPeriodAmountInWei) {\n        usedLimitAmountToSet = _amount;\n        amountUsedLoweredToLimit = true;\n      }\n    }\n\n    limitInWei = _amount;\n\n    if (usedAmountResetToZero || amountUsedLoweredToLimit) {\n      currentPeriodAmountInWei = usedLimitAmountToSet;\n    }\n\n    emit LimitAmountChanged(_msgSender(), _amount, amountUsedLoweredToLimit, usedAmountResetToZero);\n  }\n\n  /**\n   * @notice Resets the amount used to zero.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the AmountUsedInPeriodReset event.\n   */\n  function resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'RateLimiter._addUsedAmount', 'start_line': 1311, 'end_line': 1326, 'offset_start': 49853, 'offset_end': 50337, 'content': 'function _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      currentPeriodAmountTemp = _usedAmount;\n    } else {\n      currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n      revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n  }', 'contract_name': 'RateLimiter', 'contract_code': '{\n  bytes32 public constant RATE_LIMIT_SETTER_ROLE = keccak256("RATE_LIMIT_SETTER_ROLE");\n\n  uint256 public periodInSeconds; // how much time before limit resets.\n  uint256 public limitInWei; // max ether to withdraw per period.\n\n  /// @dev Public for ease of consumption.\n  /// @notice The time at which the current period ends at.\n  uint256 public currentPeriodEnd;\n\n  /// @dev Public for ease of consumption.\n  /// @notice Amounts already withdrawn this period.\n  uint256 public currentPeriodAmountInWei;\n\n  /// @dev Total contract storage is 14 slots with the gap below.\n  /// @dev Keep 10 free storage slots for future implementation updates to avoid storage collision.\n  uint256[10] private __gap;\n\n  /**\n   * @notice Initialises the limits and period for the rate limiter.\n   * @param _periodInSeconds The length of the period in seconds.\n   * @param _limitInWei The limit allowed in the period in Wei.\n   */\n  function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal onlyInitializing {\n    if (_periodInSeconds == 0) {\n      revert PeriodIsZero();\n    }\n\n    if (_limitInWei == 0) {\n      revert LimitIsZero();\n    }\n\n    periodInSeconds = _periodInSeconds;\n    limitInWei = _limitInWei;\n    currentPeriodEnd = block.timestamp + _periodInSeconds;\n\n    emit RateLimitInitialized(periodInSeconds, limitInWei, currentPeriodEnd);\n  }\n\n  /**\n   * @notice Increments the amount used in the period.\n   * @dev The amount determining logic is external to this (e.g. fees are included when calling here).\n   * @dev Reverts if the limit is breached.\n   * @param _usedAmount The amount used to be added.\n   */\n  function _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      currentPeriodAmountTemp = _usedAmount;\n    } else {\n      currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n      revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n  }\n\n  /**\n   * @notice Resets the rate limit amount.\n   * @dev If the used amount is higher, it is set to the limit to avoid confusion/issues.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the LimitAmountChanged event.\n   * @dev usedLimitAmountToSet will use the default value of zero if period has expired\n   * @param _amount The amount to reset the limit to.\n   */\n  function resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    uint256 usedLimitAmountToSet;\n    bool amountUsedLoweredToLimit;\n    bool usedAmountResetToZero;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      usedAmountResetToZero = true;\n    } else {\n      if (_amount < currentPeriodAmountInWei) {\n        usedLimitAmountToSet = _amount;\n        amountUsedLoweredToLimit = true;\n      }\n    }\n\n    limitInWei = _amount;\n\n    if (usedAmountResetToZero || amountUsedLoweredToLimit) {\n      currentPeriodAmountInWei = usedLimitAmountToSet;\n    }\n\n    emit LimitAmountChanged(_msgSender(), _amount, amountUsedLoweredToLimit, usedAmountResetToZero);\n  }\n\n  /**\n   * @notice Resets the amount used to zero.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the AmountUsedInPeriodReset event.\n   */\n  function resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'RateLimiter.resetRateLimitAmount', 'start_line': 1336, 'end_line': 1358, 'offset_start': 50754, 'offset_end': 51499, 'content': 'function resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    uint256 usedLimitAmountToSet;\n    bool amountUsedLoweredToLimit;\n    bool usedAmountResetToZero;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      usedAmountResetToZero = true;\n    } else {\n      if (_amount < currentPeriodAmountInWei) {\n        usedLimitAmountToSet = _amount;\n        amountUsedLoweredToLimit = true;\n      }\n    }\n\n    limitInWei = _amount;\n\n    if (usedAmountResetToZero || amountUsedLoweredToLimit) {\n      currentPeriodAmountInWei = usedLimitAmountToSet;\n    }\n\n    emit LimitAmountChanged(_msgSender(), _amount, amountUsedLoweredToLimit, usedAmountResetToZero);\n  }', 'contract_name': 'RateLimiter', 'contract_code': '{\n  bytes32 public constant RATE_LIMIT_SETTER_ROLE = keccak256("RATE_LIMIT_SETTER_ROLE");\n\n  uint256 public periodInSeconds; // how much time before limit resets.\n  uint256 public limitInWei; // max ether to withdraw per period.\n\n  /// @dev Public for ease of consumption.\n  /// @notice The time at which the current period ends at.\n  uint256 public currentPeriodEnd;\n\n  /// @dev Public for ease of consumption.\n  /// @notice Amounts already withdrawn this period.\n  uint256 public currentPeriodAmountInWei;\n\n  /// @dev Total contract storage is 14 slots with the gap below.\n  /// @dev Keep 10 free storage slots for future implementation updates to avoid storage collision.\n  uint256[10] private __gap;\n\n  /**\n   * @notice Initialises the limits and period for the rate limiter.\n   * @param _periodInSeconds The length of the period in seconds.\n   * @param _limitInWei The limit allowed in the period in Wei.\n   */\n  function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal onlyInitializing {\n    if (_periodInSeconds == 0) {\n      revert PeriodIsZero();\n    }\n\n    if (_limitInWei == 0) {\n      revert LimitIsZero();\n    }\n\n    periodInSeconds = _periodInSeconds;\n    limitInWei = _limitInWei;\n    currentPeriodEnd = block.timestamp + _periodInSeconds;\n\n    emit RateLimitInitialized(periodInSeconds, limitInWei, currentPeriodEnd);\n  }\n\n  /**\n   * @notice Increments the amount used in the period.\n   * @dev The amount determining logic is external to this (e.g. fees are included when calling here).\n   * @dev Reverts if the limit is breached.\n   * @param _usedAmount The amount used to be added.\n   */\n  function _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      currentPeriodAmountTemp = _usedAmount;\n    } else {\n      currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n      revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n  }\n\n  /**\n   * @notice Resets the rate limit amount.\n   * @dev If the used amount is higher, it is set to the limit to avoid confusion/issues.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the LimitAmountChanged event.\n   * @dev usedLimitAmountToSet will use the default value of zero if period has expired\n   * @param _amount The amount to reset the limit to.\n   */\n  function resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    uint256 usedLimitAmountToSet;\n    bool amountUsedLoweredToLimit;\n    bool usedAmountResetToZero;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      usedAmountResetToZero = true;\n    } else {\n      if (_amount < currentPeriodAmountInWei) {\n        usedLimitAmountToSet = _amount;\n        amountUsedLoweredToLimit = true;\n      }\n    }\n\n    limitInWei = _amount;\n\n    if (usedAmountResetToZero || amountUsedLoweredToLimit) {\n      currentPeriodAmountInWei = usedLimitAmountToSet;\n    }\n\n    emit LimitAmountChanged(_msgSender(), _amount, amountUsedLoweredToLimit, usedAmountResetToZero);\n  }\n\n  /**\n   * @notice Resets the amount used to zero.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the AmountUsedInPeriodReset event.\n   */\n  function resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'RateLimiter.resetAmountUsedInPeriod', 'start_line': 1365, 'end_line': 1369, 'offset_start': 51691, 'offset_end': 51855, 'content': 'function resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n  }', 'contract_name': 'RateLimiter', 'contract_code': '{\n  bytes32 public constant RATE_LIMIT_SETTER_ROLE = keccak256("RATE_LIMIT_SETTER_ROLE");\n\n  uint256 public periodInSeconds; // how much time before limit resets.\n  uint256 public limitInWei; // max ether to withdraw per period.\n\n  /// @dev Public for ease of consumption.\n  /// @notice The time at which the current period ends at.\n  uint256 public currentPeriodEnd;\n\n  /// @dev Public for ease of consumption.\n  /// @notice Amounts already withdrawn this period.\n  uint256 public currentPeriodAmountInWei;\n\n  /// @dev Total contract storage is 14 slots with the gap below.\n  /// @dev Keep 10 free storage slots for future implementation updates to avoid storage collision.\n  uint256[10] private __gap;\n\n  /**\n   * @notice Initialises the limits and period for the rate limiter.\n   * @param _periodInSeconds The length of the period in seconds.\n   * @param _limitInWei The limit allowed in the period in Wei.\n   */\n  function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal onlyInitializing {\n    if (_periodInSeconds == 0) {\n      revert PeriodIsZero();\n    }\n\n    if (_limitInWei == 0) {\n      revert LimitIsZero();\n    }\n\n    periodInSeconds = _periodInSeconds;\n    limitInWei = _limitInWei;\n    currentPeriodEnd = block.timestamp + _periodInSeconds;\n\n    emit RateLimitInitialized(periodInSeconds, limitInWei, currentPeriodEnd);\n  }\n\n  /**\n   * @notice Increments the amount used in the period.\n   * @dev The amount determining logic is external to this (e.g. fees are included when calling here).\n   * @dev Reverts if the limit is breached.\n   * @param _usedAmount The amount used to be added.\n   */\n  function _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      currentPeriodAmountTemp = _usedAmount;\n    } else {\n      currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n      revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n  }\n\n  /**\n   * @notice Resets the rate limit amount.\n   * @dev If the used amount is higher, it is set to the limit to avoid confusion/issues.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the LimitAmountChanged event.\n   * @dev usedLimitAmountToSet will use the default value of zero if period has expired\n   * @param _amount The amount to reset the limit to.\n   */\n  function resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    uint256 usedLimitAmountToSet;\n    bool amountUsedLoweredToLimit;\n    bool usedAmountResetToZero;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      usedAmountResetToZero = true;\n    } else {\n      if (_amount < currentPeriodAmountInWei) {\n        usedLimitAmountToSet = _amount;\n        amountUsedLoweredToLimit = true;\n      }\n    }\n\n    limitInWei = _amount;\n\n    if (usedAmountResetToZero || amountUsedLoweredToLimit) {\n      currentPeriodAmountInWei = usedLimitAmountToSet;\n    }\n\n    emit LimitAmountChanged(_msgSender(), _amount, amountUsedLoweredToLimit, usedAmountResetToZero);\n  }\n\n  /**\n   * @notice Resets the amount used to zero.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the AmountUsedInPeriodReset event.\n   */\n  function resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 1509, 'end_line': 1510, 'offset_start': 56704, 'offset_end': 56768, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 1512, 'end_line': 1513, 'offset_start': 56775, 'offset_end': 56849, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 1517, 'end_line': 1519, 'offset_start': 56916, 'offset_end': 57128, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 1524, 'end_line': 1526, 'offset_start': 57216, 'offset_end': 57360, 'content': 'function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1536, 'end_line': 1538, 'offset_start': 57655, 'offset_end': 57757, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1547, 'end_line': 1560, 'offset_start': 58039, 'offset_end': 58539, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 1568, 'end_line': 1570, 'offset_start': 58721, 'offset_end': 58849, 'content': 'function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 1584, 'end_line': 1586, 'offset_start': 59146, 'offset_end': 59290, 'content': 'function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 1599, 'end_line': 1601, 'offset_start': 59571, 'offset_end': 59717, 'content': 'function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 1619, 'end_line': 1623, 'offset_start': 60255, 'offset_end': 60468, 'content': 'function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setupRole', 'start_line': 1645, 'end_line': 1647, 'offset_start': 61154, 'offset_end': 61263, 'content': 'function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 1654, 'end_line': 1658, 'offset_start': 61389, 'offset_end': 61635, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 1667, 'end_line': 1672, 'offset_start': 61804, 'offset_end': 62036, 'content': 'function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 1681, 'end_line': 1686, 'offset_start': 62208, 'offset_end': 62441, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'TransientStorageHelpers.tstoreUint256', 'start_line': 1710, 'end_line': 1714, 'offset_start': 63352, 'offset_end': 63466, 'content': 'function tstoreUint256(bytes32 _key, uint256 _value) internal {\n    assembly {\n      tstore(_key, _value)\n    }\n  }', 'contract_name': 'TransientStorageHelpers', 'contract_code': "{\n  /**\n   * @notice Internal function that stores a uint256 value at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _value The uint256 value to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreUint256(bytes32 _key, uint256 _value) internal {\n    assembly {\n      tstore(_key, _value)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves a uint256 value from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return value The uint256 value retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadUint256(bytes32 _key) internal view returns (uint256 value) {\n    assembly {\n      value := tload(_key)\n    }\n  }\n\n  /**\n   * @notice Internal function that stores an address at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _addr The address to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreAddress(bytes32 _key, address _addr) internal {\n    assembly {\n      tstore(_key, _addr)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves an address from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return addr The address retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadAddress(bytes32 _key) internal view returns (address addr) {\n    assembly {\n      addr := tload(_key)\n    }\n  }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'TransientStorageHelpers.tloadUint256', 'start_line': 1721, 'end_line': 1725, 'offset_start': 63800, 'offset_end': 63926, 'content': 'function tloadUint256(bytes32 _key) internal view returns (uint256 value) {\n    assembly {\n      value := tload(_key)\n    }\n  }', 'contract_name': 'TransientStorageHelpers', 'contract_code': "{\n  /**\n   * @notice Internal function that stores a uint256 value at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _value The uint256 value to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreUint256(bytes32 _key, uint256 _value) internal {\n    assembly {\n      tstore(_key, _value)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves a uint256 value from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return value The uint256 value retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadUint256(bytes32 _key) internal view returns (uint256 value) {\n    assembly {\n      value := tload(_key)\n    }\n  }\n\n  /**\n   * @notice Internal function that stores an address at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _addr The address to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreAddress(bytes32 _key, address _addr) internal {\n    assembly {\n      tstore(_key, _addr)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves an address from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return addr The address retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadAddress(bytes32 _key) internal view returns (address addr) {\n    assembly {\n      addr := tload(_key)\n    }\n  }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'TransientStorageHelpers.tstoreAddress', 'start_line': 1732, 'end_line': 1736, 'offset_start': 64252, 'offset_end': 64364, 'content': 'function tstoreAddress(bytes32 _key, address _addr) internal {\n    assembly {\n      tstore(_key, _addr)\n    }\n  }', 'contract_name': 'TransientStorageHelpers', 'contract_code': "{\n  /**\n   * @notice Internal function that stores a uint256 value at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _value The uint256 value to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreUint256(bytes32 _key, uint256 _value) internal {\n    assembly {\n      tstore(_key, _value)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves a uint256 value from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return value The uint256 value retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadUint256(bytes32 _key) internal view returns (uint256 value) {\n    assembly {\n      value := tload(_key)\n    }\n  }\n\n  /**\n   * @notice Internal function that stores an address at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _addr The address to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreAddress(bytes32 _key, address _addr) internal {\n    assembly {\n      tstore(_key, _addr)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves an address from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return addr The address retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadAddress(bytes32 _key) internal view returns (address addr) {\n    assembly {\n      addr := tload(_key)\n    }\n  }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'TransientStorageHelpers.tloadAddress', 'start_line': 1743, 'end_line': 1747, 'offset_start': 64686, 'offset_end': 64810, 'content': 'function tloadAddress(bytes32 _key) internal view returns (address addr) {\n    assembly {\n      addr := tload(_key)\n    }\n  }', 'contract_name': 'TransientStorageHelpers', 'contract_code': "{\n  /**\n   * @notice Internal function that stores a uint256 value at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _value The uint256 value to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreUint256(bytes32 _key, uint256 _value) internal {\n    assembly {\n      tstore(_key, _value)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves a uint256 value from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return value The uint256 value retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadUint256(bytes32 _key) internal view returns (uint256 value) {\n    assembly {\n      value := tload(_key)\n    }\n  }\n\n  /**\n   * @notice Internal function that stores an address at a given key in the EVM's transient storage using the `tstore` opcode.\n   * @param _key The key in the EVM transient storage where the value should be stored.\n   * @param _addr The address to be stored at the specified key in the EVM transient storage.\n   */\n  function tstoreAddress(bytes32 _key, address _addr) internal {\n    assembly {\n      tstore(_key, _addr)\n    }\n  }\n\n  /**\n   * @notice Internal function that retrieves an address from the EVM's transient storage using the `tload` opcode.\n   * @param _key The key in the EVM transient storage from which the value should be retrieved.\n   * @return addr The address retrieved from the specified key in the EVM transient storage.\n   */\n  function tloadAddress(bytes32 _key) internal view returns (address addr) {\n    assembly {\n      addr := tload(_key)\n    }\n  }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageManagerV1._updateL2L1MessageStatusToClaimed', 'start_line': 1791, 'end_line': 1797, 'offset_start': 66667, 'offset_end': 66945, 'content': 'function _updateL2L1MessageStatusToClaimed(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash] != INBOX_STATUS_RECEIVED) {\n      revert MessageDoesNotExistOrHasAlreadyBeenClaimed(_messageHash);\n    }\n\n    delete inboxL2L1MessageStatus[_messageHash];\n  }', 'contract_name': 'L1MessageManagerV1', 'contract_code': '{\n  uint8 public constant INBOX_STATUS_UNKNOWN = 0;\n  uint8 public constant INBOX_STATUS_RECEIVED = 1;\n\n  uint8 public constant OUTBOX_STATUS_UNKNOWN = 0;\n  uint8 public constant OUTBOX_STATUS_SENT = 1;\n  uint8 public constant OUTBOX_STATUS_RECEIVED = 2;\n\n  /// @dev Mapping to store L1->L2 message hashes status.\n  /// @dev messageHash => messageStatus (0: unknown, 1: sent, 2: received).\n  mapping(bytes32 messageHash => uint256 messageStatus) public outboxL1L2MessageStatus;\n\n  /// @dev Mapping to store L2->L1 message hashes status.\n  /// @dev messageHash => messageStatus (0: unknown, 1: received).\n  mapping(bytes32 messageHash => uint256 messageStatus) public inboxL2L1MessageStatus;\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  // *******************************************************************************************\n  // NB: THIS GAP HAS BEEN PUSHED OUT IN FAVOUR OF THE GAP INSIDE THE REENTRANCY CODE\n  //uint256[50] private __gap;\n  // NB: DO NOT USE THIS GAP\n  // *******************************************************************************************\n\n  /// @dev Total contract storage is 2 slots.\n\n  /**\n   * @notice Update the status of L2->L1 message when a user claims a message on L1.\n   * @dev The L2->L1 message is removed from storage.\n   * @dev Due to the nature of the rollup, we should not get a second entry of this.\n   * @param  _messageHash Hash of the message.\n   */\n  function _updateL2L1MessageStatusToClaimed(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash] != INBOX_STATUS_RECEIVED) {\n      revert MessageDoesNotExistOrHasAlreadyBeenClaimed(_messageHash);\n    }\n\n    delete inboxL2L1MessageStatus[_messageHash];\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IPlonkVerifier.Verify', 'start_line': 1814, 'end_line': 1814, 'offset_start': 67378, 'offset_end': 67475, 'content': 'function Verify(bytes calldata _proof, uint256[] calldata _public_inputs) external returns (bool);', 'contract_name': 'IPlonkVerifier', 'contract_code': '{\n  /**\n   * @notice Interface for verifier contracts.\n   * @param _proof The proof used to verify.\n   * @param _public_inputs The computed public inputs for the proof verification.\n   */\n  function Verify(bytes calldata _proof, uint256[] calldata _public_inputs) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 1856, 'end_line': 1862, 'offset_start': 68903, 'offset_end': 69222, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 1880, 'end_line': 1885, 'offset_start': 70138, 'offset_end': 70449, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1905, 'end_line': 1907, 'offset_start': 71192, 'offset_end': 71376, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1915, 'end_line': 1921, 'offset_start': 71599, 'offset_end': 71821, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1934, 'end_line': 1936, 'offset_start': 72184, 'offset_end': 72407, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1944, 'end_line': 1953, 'offset_start': 72656, 'offset_end': 73101, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1961, 'end_line': 1963, 'offset_start': 73279, 'offset_end': 73475, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1971, 'end_line': 1978, 'offset_start': 73660, 'offset_end': 73985, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1986, 'end_line': 1988, 'offset_start': 74165, 'offset_end': 74362, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1996, 'end_line': 2003, 'offset_start': 74549, 'offset_end': 74873, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 2011, 'end_line': 2027, 'offset_start': 75162, 'offset_end': 75789, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 2035, 'end_line': 2045, 'offset_start': 76011, 'offset_end': 76305, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 2047, 'end_line': 2059, 'offset_start': 76312, 'offset_end': 76851, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageServiceV1.claimMessage', 'start_line': 2169, 'end_line': 2205, 'offset_start': 80782, 'offset_end': 82013, 'content': 'function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external nonReentrant distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    /// @dev This is placed earlier to fix the stack issue by using these two earlier on.\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _from);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    // @dev Status check and revert is in the message manager.\n    _updateL2L1MessageStatusToClaimed(messageHash);\n\n    _addUsedAmount(_fee + _value);\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageHash);\n  }', 'contract_name': 'L1MessageServiceV1', 'contract_code': '{\n  // @dev This is initialised to save user cost with existing slot.\n  uint256 public nextMessageNumber;\n\n  /// @dev DEPRECATED in favor of new transient storage with `MESSAGE_SENDER_TRANSIENT_KEY` key.\n  address internal _messageSender;\n\n  /// @dev Total contract storage is 52 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /// @dev adding these should not affect storage as they are constants and are stored in bytecode.\n  uint256 internal constant REFUND_OVERHEAD_IN_GAS = 48252;\n\n  bytes32 internal constant MESSAGE_SENDER_TRANSIENT_KEY =\n    bytes32(uint256(keccak256("eip1967.message.sender.transient.key")) - 1);\n\n  address internal constant DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE = address(0);\n\n  /**\n   * @notice The unspent fee is refunded if applicable.\n   * @param _feeInWei The fee paid for delivery in Wei.\n   * @param _to The recipient of the message and gas refund.\n   * @param _calldata The calldata of the message.\n   */\n  modifier distributeFees(\n    uint256 _feeInWei,\n    address _to,\n    bytes calldata _calldata,\n    address _feeRecipient\n  ) {\n    //pre-execution\n    uint256 startingGas = gasleft();\n    _;\n    //post-execution\n\n    // we have a fee\n    if (_feeInWei > 0) {\n      // default postman fee\n      uint256 deliveryFee = _feeInWei;\n\n      // do we have empty calldata?\n      if (_calldata.length == 0) {\n        bool isDestinationEOA;\n\n        assembly {\n          isDestinationEOA := iszero(extcodesize(_to))\n        }\n\n        // are we calling an EOA\n        if (isDestinationEOA) {\n          // initial + cost to call and refund minus gasleft\n          deliveryFee = (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice;\n\n          if (_feeInWei > deliveryFee) {\n            payable(_to).send(_feeInWei - deliveryFee);\n          } else {\n            deliveryFee = _feeInWei;\n          }\n        }\n      }\n\n      address feeReceiver = _feeRecipient == address(0) ? msg.sender : _feeRecipient;\n\n      bool callSuccess = payable(feeReceiver).send(deliveryFee);\n      if (!callSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n      }\n    }\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _feeRecipient can be set to address(0) to receive as msg.sender.\n   * @dev _messageSender is set temporarily when claiming and reset post. Used in sender().\n   * @dev _messageSender is reset to DEFAULT_SENDER_ADDRESS to be more gas efficient.\n   * @param _from The address of the original sender.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _value The value to be transferred to the destination address.\n   * @param _feeRecipient The recipient for the fee.\n   * @param _calldata The calldata to pass to the recipient.\n   * @param _nonce The unique auto generated nonce used when sending the message.\n   */\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external nonReentrant distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeAndGeneralNotPaused(L2_L1_PAUSE_TYPE);\n\n    /// @dev This is placed earlier to fix the stack issue by using these two earlier on.\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, _from);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    // @dev Status check and revert is in the message manager.\n    _updateL2L1MessageStatusToClaimed(messageHash);\n\n    _addUsedAmount(_fee + _value);\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    TransientStorageHelpers.tstoreAddress(MESSAGE_SENDER_TRANSIENT_KEY, DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE);\n\n    emit MessageClaimed(messageHash);\n  }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IMessageService.sendMessage', 'start_line': 2274, 'end_line': 2274, 'offset_start': 84396, 'offset_end': 84486, 'content': 'function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable;', 'contract_name': 'IMessageService', 'contract_code': '{\n  /**\n   * @notice Emitted when a message is sent.\n   * @param _from The indexed sender address of the message (msg.sender).\n   * @param _to The indexed intended recipient address of the message on the other layer.\n   * @param _fee The fee being being paid to deliver the message to the recipient in Wei.\n   * @param _value The value being sent to the recipient in Wei.\n   * @param _nonce The unique message number.\n   * @param _calldata The calldata being passed to the intended recipient when being called on claiming.\n   * @param _messageHash The indexed hash of the message parameters.\n   * @dev _calldata has the _ because calldata is a reserved word.\n   * @dev We include the message hash to save hashing costs on the rollup.\n   * @dev This event is used on both L1 and L2.\n   */\n  event MessageSent(\n    address indexed _from,\n    address indexed _to,\n    uint256 _fee,\n    uint256 _value,\n    uint256 _nonce,\n    bytes _calldata,\n    bytes32 indexed _messageHash\n  );\n\n  /**\n   * @notice Emitted when a message is claimed.\n   * @param _messageHash The indexed hash of the message that was claimed.\n   */\n  event MessageClaimed(bytes32 indexed _messageHash);\n\n  /**\n   * @dev Thrown when fees are lower than the minimum fee.\n   */\n  error FeeTooLow();\n\n  /**\n   * @dev Thrown when the value sent is less than the fee.\n   * @dev Value to forward on is msg.value - _fee.\n   */\n  error ValueSentTooLow();\n\n  /**\n   * @dev Thrown when the destination address reverts.\n   */\n  error MessageSendingFailed(address destination);\n\n  /**\n   * @dev Thrown when the recipient address reverts.\n   */\n  error FeePaymentFailed(address recipient);\n\n  /**\n   * @notice Sends a message for transporting from the given chain.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The destination address on the destination chain.\n   * @param _fee The message service fee on the origin chain.\n   * @param _calldata The calldata used by the destination message service to call the destination contract.\n   */\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable;\n\n  /**\n   * @notice Deliver a message to the destination chain.\n   * @notice Is called by the Postman, dApp or end user.\n   * @param _from The msg.sender calling the origin message service.\n   * @param _to The destination address on the destination chain.\n   * @param _value The value to be transferred to the destination address.\n   * @param _fee The message service fee on the origin chain.\n   * @param _feeRecipient Address that will receive the fees.\n   * @param _calldata The calldata used by the destination message service to call/forward to the destination contract.\n   * @param _nonce Unique message number.\n   */\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external;\n\n  /**\n   * @notice Returns the original sender of the message on the origin layer.\n   * @return The original sender of the message on the origin layer.\n   */\n  function sender() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IMessageService.claimMessage', 'start_line': 2287, 'end_line': 2295, 'offset_start': 85113, 'offset_end': 85306, 'content': 'function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external;', 'contract_name': 'IMessageService', 'contract_code': '{\n  /**\n   * @notice Emitted when a message is sent.\n   * @param _from The indexed sender address of the message (msg.sender).\n   * @param _to The indexed intended recipient address of the message on the other layer.\n   * @param _fee The fee being being paid to deliver the message to the recipient in Wei.\n   * @param _value The value being sent to the recipient in Wei.\n   * @param _nonce The unique message number.\n   * @param _calldata The calldata being passed to the intended recipient when being called on claiming.\n   * @param _messageHash The indexed hash of the message parameters.\n   * @dev _calldata has the _ because calldata is a reserved word.\n   * @dev We include the message hash to save hashing costs on the rollup.\n   * @dev This event is used on both L1 and L2.\n   */\n  event MessageSent(\n    address indexed _from,\n    address indexed _to,\n    uint256 _fee,\n    uint256 _value,\n    uint256 _nonce,\n    bytes _calldata,\n    bytes32 indexed _messageHash\n  );\n\n  /**\n   * @notice Emitted when a message is claimed.\n   * @param _messageHash The indexed hash of the message that was claimed.\n   */\n  event MessageClaimed(bytes32 indexed _messageHash);\n\n  /**\n   * @dev Thrown when fees are lower than the minimum fee.\n   */\n  error FeeTooLow();\n\n  /**\n   * @dev Thrown when the value sent is less than the fee.\n   * @dev Value to forward on is msg.value - _fee.\n   */\n  error ValueSentTooLow();\n\n  /**\n   * @dev Thrown when the destination address reverts.\n   */\n  error MessageSendingFailed(address destination);\n\n  /**\n   * @dev Thrown when the recipient address reverts.\n   */\n  error FeePaymentFailed(address recipient);\n\n  /**\n   * @notice Sends a message for transporting from the given chain.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The destination address on the destination chain.\n   * @param _fee The message service fee on the origin chain.\n   * @param _calldata The calldata used by the destination message service to call the destination contract.\n   */\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable;\n\n  /**\n   * @notice Deliver a message to the destination chain.\n   * @notice Is called by the Postman, dApp or end user.\n   * @param _from The msg.sender calling the origin message service.\n   * @param _to The destination address on the destination chain.\n   * @param _value The value to be transferred to the destination address.\n   * @param _fee The message service fee on the origin chain.\n   * @param _feeRecipient Address that will receive the fees.\n   * @param _calldata The calldata used by the destination message service to call/forward to the destination contract.\n   * @param _nonce Unique message number.\n   */\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external;\n\n  /**\n   * @notice Returns the original sender of the message on the origin layer.\n   * @return The original sender of the message on the origin layer.\n   */\n  function sender() external view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IMessageService.sender', 'start_line': 2301, 'end_line': 2301, 'offset_start': 85469, 'offset_end': 85518, 'content': 'function sender() external view returns (address);', 'contract_name': 'IMessageService', 'contract_code': '{\n  /**\n   * @notice Emitted when a message is sent.\n   * @param _from The indexed sender address of the message (msg.sender).\n   * @param _to The indexed intended recipient address of the message on the other layer.\n   * @param _fee The fee being being paid to deliver the message to the recipient in Wei.\n   * @param _value The value being sent to the recipient in Wei.\n   * @param _nonce The unique message number.\n   * @param _calldata The calldata being passed to the intended recipient when being called on claiming.\n   * @param _messageHash The indexed hash of the message parameters.\n   * @dev _calldata has the _ because calldata is a reserved word.\n   * @dev We include the message hash to save hashing costs on the rollup.\n   * @dev This event is used on both L1 and L2.\n   */\n  event MessageSent(\n    address indexed _from,\n    address indexed _to,\n    uint256 _fee,\n    uint256 _value,\n    uint256 _nonce,\n    bytes _calldata,\n    bytes32 indexed _messageHash\n  );\n\n  /**\n   * @notice Emitted when a message is claimed.\n   * @param _messageHash The indexed hash of the message that was claimed.\n   */\n  event MessageClaimed(bytes32 indexed _messageHash);\n\n  /**\n   * @dev Thrown when fees are lower than the minimum fee.\n   */\n  error FeeTooLow();\n\n  /**\n   * @dev Thrown when the value sent is less than the fee.\n   * @dev Value to forward on is msg.value - _fee.\n   */\n  error ValueSentTooLow();\n\n  /**\n   * @dev Thrown when the destination address reverts.\n   */\n  error MessageSendingFailed(address destination);\n\n  /**\n   * @dev Thrown when the recipient address reverts.\n   */\n  error FeePaymentFailed(address recipient);\n\n  /**\n   * @notice Sends a message for transporting from the given chain.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The destination address on the destination chain.\n   * @param _fee The message service fee on the origin chain.\n   * @param _calldata The calldata used by the destination message service to call the destination contract.\n   */\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable;\n\n  /**\n   * @notice Deliver a message to the destination chain.\n   * @notice Is called by the Postman, dApp or end user.\n   * @param _from The msg.sender calling the origin message service.\n   * @param _to The destination address on the destination chain.\n   * @param _value The value to be transferred to the destination address.\n   * @param _fee The message service fee on the origin chain.\n   * @param _feeRecipient Address that will receive the fees.\n   * @param _calldata The calldata used by the destination message service to call/forward to the destination contract.\n   * @param _nonce Unique message number.\n   */\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external;\n\n  /**\n   * @notice Returns the original sender of the message on the origin layer.\n   * @return The original sender of the message on the origin layer.\n   */\n  function sender() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 2322, 'end_line': 2342, 'offset_start': 86003, 'offset_end': 86709, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 2347, 'end_line': 2349, 'offset_start': 86810, 'offset_end': 86993, 'content': 'function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 2354, 'end_line': 2358, 'offset_start': 87099, 'offset_end': 87283, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 2363, 'end_line': 2373, 'offset_start': 87407, 'offset_end': 87843, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 2378, 'end_line': 2380, 'offset_start': 87996, 'offset_end': 88144, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.equal', 'start_line': 2385, 'end_line': 2387, 'offset_start': 88222, 'offset_end': 88365, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ILineaRollup.setVerifierAddress', 'start_line': 2670, 'end_line': 2670, 'offset_start': 99857, 'offset_end': 99942, 'content': 'function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;', 'contract_name': 'ILineaRollup', 'contract_code': "{\n  /**\n   * @notice Supporting data for compressed calldata submission including compressed data.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded txData.\n   */\n  struct SubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n    bytes compressedData;\n  }\n\n  /**\n   * @notice Supporting data for compressed blob data submission.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   */\n  struct SupportingSubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n  }\n\n  /**\n   * @notice Shnarf data for validating a shnarf.\n   * @dev parentShnarf is the parent computed shnarf.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev finalStateRootHash is the final state root hash.\n   * @dev dataEvaluationPoint is the data evaluation point.\n   * @dev dataEvaluationClaim is the data evaluation claim.\n   */\n  struct ShnarfData {\n    bytes32 parentShnarf;\n    bytes32 snarkHash;\n    bytes32 finalStateRootHash;\n    bytes32 dataEvaluationPoint;\n    bytes32 dataEvaluationClaim;\n  }\n\n  /**\n   * @notice Data stucture for compressed blob data submission.\n   * @dev submissionData The supporting data for blob data submission excluding the compressed data.\n   * @dev dataEvaluationClaim The data evaluation claim.\n   * @dev kzgCommitment The blob KZG commitment.\n   * @dev kzgProof The blob KZG point proof.\n   */\n  struct BlobSubmissionData {\n    SupportingSubmissionDataV2 submissionData;\n    uint256 dataEvaluationClaim;\n    bytes kzgCommitment;\n    bytes kzgProof;\n  }\n\n  /**\n   * @notice Supporting data for finalization with or without proof.\n   * @dev NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.\n   * @dev parentStateRootHash is the expected last state root hash finalized.\n   * @dev lastFinalizedShnarf is the last finalized shnarf for proof continuity checks.\n   * @dev finalBlockInData is the final block finalizing until.\n   * @dev shnarfData contains data about the last data submission's shnarf used in finalization.\n   * @dev lastFinalizedTimestamp is the expected last finalized block's timestamp.\n   * @dev finalTimestamp is the timestamp of the last block being finalized.\n   * @dev lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.\n   * @dev l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.\n   * This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.\n   * @dev lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.\n   * @dev l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.\n   * This value will be used along with the stored last finalized L2 calculated message number in the public input.\n   * @dev l2MerkleTreesDepth is the depth of all l2MerkleRoots.\n   * @dev l2MerkleRoots is an array of L2 message merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockInData.\n   * @dev l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events.\n   */\n  struct FinalizationDataV2 {\n    bytes32 parentStateRootHash;\n    bytes32 lastFinalizedShnarf;\n    uint256 finalBlockInData;\n    ShnarfData shnarfData;\n    uint256 lastFinalizedTimestamp;\n    uint256 finalTimestamp;\n    bytes32 lastFinalizedL1RollingHash;\n    bytes32 l1RollingHash;\n    uint256 lastFinalizedL1RollingHashMessageNumber;\n    uint256 l1RollingHashMessageNumber;\n    uint256 l2MerkleTreesDepth;\n    bytes32[] l2MerkleRoots;\n    bytes l2MessagingBlocksOffsets;\n  }\n\n  /**\n   * @notice Emitted when a verifier is set for a particular proof type.\n   * @param verifierAddress The indexed new verifier address being set.\n   * @param proofType The indexed proof type/index that the verifier is mapped to.\n   * @param verifierSetBy The index address who set the verifier at the mapping.\n   * @param oldVerifierAddress Indicates the previous address mapped to the proof type.\n   * @dev The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.\n   * @dev The oldVerifierAddress can be the zero address.\n   */\n  event VerifierAddressChanged(\n    address indexed verifierAddress,\n    uint256 indexed proofType,\n    address indexed verifierSetBy,\n    address oldVerifierAddress\n  );\n\n  /**\n   * @notice Emitted when compressed data is being submitted and verified succesfully on L1.\n   * @param shnarf The indexed shnarf for the data being submitted.\n   * @param startBlock The indexed L2 block number indicating which block the data starts from.\n   * @param endBlock The indexed L2 block number indicating which block the data ends on.\n   * @dev Please note, shnarf was previously dataHash and points to the shnarfFinalBlockNumbers mapping.\n   */\n  event DataSubmittedV2(bytes32 indexed shnarf, uint256 indexed startBlock, uint256 indexed endBlock);\n\n  /**\n   * @notice Emitted when L2 blocks have been finalized on L1.\n   * @param lastBlockFinalized The indexed last L2 block that is finalized in the finalization.\n   * @param startingRootHash The indexed initial (also last finalized) L2 state root hash that the finalization is from.\n   * @param finalRootHash The indexed L2 state root hash that the current finalization is up until.\n   * @param withProof Indicates if the finalization is proven or not.\n   */\n  event DataFinalized(\n    uint256 indexed lastBlockFinalized,\n    bytes32 indexed startingRootHash,\n    bytes32 indexed finalRootHash,\n    bool withProof\n  );\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data field(s) are wrong.\n   */\n  error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data length is wrong.\n   */\n  error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call returns false.\n   */\n  error PointEvaluationFailed();\n\n  /**\n   * @dev Thrown when the blobhash equals to the zero hash.\n   */\n  error EmptyBlobData();\n\n  /**\n   * @dev Thrown when the blobhash at an index equals to the zero hash.\n   */\n  error EmptyBlobDataAtIndex(uint256 index);\n\n  /**\n   * @dev Thrown when the data for multiple blobs' submission has length zero.\n   */\n  error BlobSubmissionDataIsMissing();\n\n  /**\n   * @dev Thrown when the starting block in the data item is out of sequence with the last block number.\n   */\n  error DataStartingBlockDoesNotMatch(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the current data was already submitted.\n   */\n  error DataAlreadySubmitted(bytes32 currentDataHash);\n\n  /**\n   * @dev Thrown when the last finalized shnarf does not match the parent finalizing from.\n   */\n  error LastFinalizedShnarfWrong(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when submissionData is empty.\n   */\n  error EmptySubmissionData();\n\n  /**\n   * @dev Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop).\n   */\n  error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when finalization state does not match.\n   */\n  error FinalizationStateIncorrect(bytes32 expected, bytes32 value);\n\n  /**\n   * @dev Thrown when the first block is greater than final block in submission data.\n   */\n  error FirstBlockGreaterThanFinalBlock(uint256 firstBlockNumber, uint256 finalBlockNumber);\n\n  /**\n   * @dev Thrown when the first block in data is less than or equal to the last finalized block during data submission.\n   */\n  error FirstBlockLessThanOrEqualToLastFinalizedBlock(uint256 firstBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization.\n   */\n  error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block state equals the zero hash during finalization.\n   */\n  error FinalBlockStateEqualsZeroHash();\n\n  /**\n   * @dev Thrown when final l2 block timestamp higher than current block.timestamp during finalization.\n   */\n  error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp);\n\n  /**\n   * @dev Thrown when a rolling hash is provided without a corresponding message number.\n   */\n  error MissingMessageNumberForRollingHash(bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when a message number is provided without a corresponding rolling hash.\n   */\n  error MissingRollingHashForMessageNumber(uint256 messageNumber);\n\n  /**\n   * @dev Thrown when the first byte is not zero.\n   * @dev This is used explicitly with the four bytes in assembly 0x729eebce.\n   */\n  error FirstByteIsNotZero();\n\n  /**\n   * @dev Thrown when bytes length is not a multiple of 32.\n   */\n  error BytesLengthNotMultipleOf32();\n\n  /**\n   * @dev Thrown when the snarkhash is the zero hash.\n   */\n  error SnarkHashIsZeroHash();\n\n  /**\n   * @dev Thrown when parent stateRootHash does not match.\n   */\n  error ParentStateRootHashInvalid(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when the block being finalized until does not match that of the shnarf data.\n   */\n  error FinalBlockDoesNotMatchShnarfFinalBlock(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the lengths of the shnarfs array and final block numbers array don't match.\n   */\n  error ShnarfAndFinalBlockNumberLengthsMismatched(uint256 shnarfsLength, uint256 finalBlockNumbers);\n\n  /**\n   * @dev Thrown when the computed shnarf does not match what is expected.\n   */\n  error FinalShnarfWrong(bytes32 expected, bytes32 value);\n\n  /**\n   * @notice Adds or updated the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external;\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ILineaRollup.unsetVerifierAddress', 'start_line': 2677, 'end_line': 2677, 'offset_start': 100138, 'offset_end': 100196, 'content': 'function unsetVerifierAddress(uint256 _proofType) external;', 'contract_name': 'ILineaRollup', 'contract_code': "{\n  /**\n   * @notice Supporting data for compressed calldata submission including compressed data.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded txData.\n   */\n  struct SubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n    bytes compressedData;\n  }\n\n  /**\n   * @notice Supporting data for compressed blob data submission.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   */\n  struct SupportingSubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n  }\n\n  /**\n   * @notice Shnarf data for validating a shnarf.\n   * @dev parentShnarf is the parent computed shnarf.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev finalStateRootHash is the final state root hash.\n   * @dev dataEvaluationPoint is the data evaluation point.\n   * @dev dataEvaluationClaim is the data evaluation claim.\n   */\n  struct ShnarfData {\n    bytes32 parentShnarf;\n    bytes32 snarkHash;\n    bytes32 finalStateRootHash;\n    bytes32 dataEvaluationPoint;\n    bytes32 dataEvaluationClaim;\n  }\n\n  /**\n   * @notice Data stucture for compressed blob data submission.\n   * @dev submissionData The supporting data for blob data submission excluding the compressed data.\n   * @dev dataEvaluationClaim The data evaluation claim.\n   * @dev kzgCommitment The blob KZG commitment.\n   * @dev kzgProof The blob KZG point proof.\n   */\n  struct BlobSubmissionData {\n    SupportingSubmissionDataV2 submissionData;\n    uint256 dataEvaluationClaim;\n    bytes kzgCommitment;\n    bytes kzgProof;\n  }\n\n  /**\n   * @notice Supporting data for finalization with or without proof.\n   * @dev NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.\n   * @dev parentStateRootHash is the expected last state root hash finalized.\n   * @dev lastFinalizedShnarf is the last finalized shnarf for proof continuity checks.\n   * @dev finalBlockInData is the final block finalizing until.\n   * @dev shnarfData contains data about the last data submission's shnarf used in finalization.\n   * @dev lastFinalizedTimestamp is the expected last finalized block's timestamp.\n   * @dev finalTimestamp is the timestamp of the last block being finalized.\n   * @dev lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.\n   * @dev l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.\n   * This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.\n   * @dev lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.\n   * @dev l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.\n   * This value will be used along with the stored last finalized L2 calculated message number in the public input.\n   * @dev l2MerkleTreesDepth is the depth of all l2MerkleRoots.\n   * @dev l2MerkleRoots is an array of L2 message merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockInData.\n   * @dev l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events.\n   */\n  struct FinalizationDataV2 {\n    bytes32 parentStateRootHash;\n    bytes32 lastFinalizedShnarf;\n    uint256 finalBlockInData;\n    ShnarfData shnarfData;\n    uint256 lastFinalizedTimestamp;\n    uint256 finalTimestamp;\n    bytes32 lastFinalizedL1RollingHash;\n    bytes32 l1RollingHash;\n    uint256 lastFinalizedL1RollingHashMessageNumber;\n    uint256 l1RollingHashMessageNumber;\n    uint256 l2MerkleTreesDepth;\n    bytes32[] l2MerkleRoots;\n    bytes l2MessagingBlocksOffsets;\n  }\n\n  /**\n   * @notice Emitted when a verifier is set for a particular proof type.\n   * @param verifierAddress The indexed new verifier address being set.\n   * @param proofType The indexed proof type/index that the verifier is mapped to.\n   * @param verifierSetBy The index address who set the verifier at the mapping.\n   * @param oldVerifierAddress Indicates the previous address mapped to the proof type.\n   * @dev The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.\n   * @dev The oldVerifierAddress can be the zero address.\n   */\n  event VerifierAddressChanged(\n    address indexed verifierAddress,\n    uint256 indexed proofType,\n    address indexed verifierSetBy,\n    address oldVerifierAddress\n  );\n\n  /**\n   * @notice Emitted when compressed data is being submitted and verified succesfully on L1.\n   * @param shnarf The indexed shnarf for the data being submitted.\n   * @param startBlock The indexed L2 block number indicating which block the data starts from.\n   * @param endBlock The indexed L2 block number indicating which block the data ends on.\n   * @dev Please note, shnarf was previously dataHash and points to the shnarfFinalBlockNumbers mapping.\n   */\n  event DataSubmittedV2(bytes32 indexed shnarf, uint256 indexed startBlock, uint256 indexed endBlock);\n\n  /**\n   * @notice Emitted when L2 blocks have been finalized on L1.\n   * @param lastBlockFinalized The indexed last L2 block that is finalized in the finalization.\n   * @param startingRootHash The indexed initial (also last finalized) L2 state root hash that the finalization is from.\n   * @param finalRootHash The indexed L2 state root hash that the current finalization is up until.\n   * @param withProof Indicates if the finalization is proven or not.\n   */\n  event DataFinalized(\n    uint256 indexed lastBlockFinalized,\n    bytes32 indexed startingRootHash,\n    bytes32 indexed finalRootHash,\n    bool withProof\n  );\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data field(s) are wrong.\n   */\n  error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data length is wrong.\n   */\n  error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call returns false.\n   */\n  error PointEvaluationFailed();\n\n  /**\n   * @dev Thrown when the blobhash equals to the zero hash.\n   */\n  error EmptyBlobData();\n\n  /**\n   * @dev Thrown when the blobhash at an index equals to the zero hash.\n   */\n  error EmptyBlobDataAtIndex(uint256 index);\n\n  /**\n   * @dev Thrown when the data for multiple blobs' submission has length zero.\n   */\n  error BlobSubmissionDataIsMissing();\n\n  /**\n   * @dev Thrown when the starting block in the data item is out of sequence with the last block number.\n   */\n  error DataStartingBlockDoesNotMatch(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the current data was already submitted.\n   */\n  error DataAlreadySubmitted(bytes32 currentDataHash);\n\n  /**\n   * @dev Thrown when the last finalized shnarf does not match the parent finalizing from.\n   */\n  error LastFinalizedShnarfWrong(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when submissionData is empty.\n   */\n  error EmptySubmissionData();\n\n  /**\n   * @dev Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop).\n   */\n  error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when finalization state does not match.\n   */\n  error FinalizationStateIncorrect(bytes32 expected, bytes32 value);\n\n  /**\n   * @dev Thrown when the first block is greater than final block in submission data.\n   */\n  error FirstBlockGreaterThanFinalBlock(uint256 firstBlockNumber, uint256 finalBlockNumber);\n\n  /**\n   * @dev Thrown when the first block in data is less than or equal to the last finalized block during data submission.\n   */\n  error FirstBlockLessThanOrEqualToLastFinalizedBlock(uint256 firstBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization.\n   */\n  error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block state equals the zero hash during finalization.\n   */\n  error FinalBlockStateEqualsZeroHash();\n\n  /**\n   * @dev Thrown when final l2 block timestamp higher than current block.timestamp during finalization.\n   */\n  error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp);\n\n  /**\n   * @dev Thrown when a rolling hash is provided without a corresponding message number.\n   */\n  error MissingMessageNumberForRollingHash(bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when a message number is provided without a corresponding rolling hash.\n   */\n  error MissingRollingHashForMessageNumber(uint256 messageNumber);\n\n  /**\n   * @dev Thrown when the first byte is not zero.\n   * @dev This is used explicitly with the four bytes in assembly 0x729eebce.\n   */\n  error FirstByteIsNotZero();\n\n  /**\n   * @dev Thrown when bytes length is not a multiple of 32.\n   */\n  error BytesLengthNotMultipleOf32();\n\n  /**\n   * @dev Thrown when the snarkhash is the zero hash.\n   */\n  error SnarkHashIsZeroHash();\n\n  /**\n   * @dev Thrown when parent stateRootHash does not match.\n   */\n  error ParentStateRootHashInvalid(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when the block being finalized until does not match that of the shnarf data.\n   */\n  error FinalBlockDoesNotMatchShnarfFinalBlock(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the lengths of the shnarfs array and final block numbers array don't match.\n   */\n  error ShnarfAndFinalBlockNumberLengthsMismatched(uint256 shnarfsLength, uint256 finalBlockNumbers);\n\n  /**\n   * @dev Thrown when the computed shnarf does not match what is expected.\n   */\n  error FinalShnarfWrong(bytes32 expected, bytes32 value);\n\n  /**\n   * @notice Adds or updated the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external;\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ILineaRollup.submitBlobs', 'start_line': 2687, 'end_line': 2691, 'offset_start': 100693, 'offset_end': 100838, 'content': 'function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;', 'contract_name': 'ILineaRollup', 'contract_code': "{\n  /**\n   * @notice Supporting data for compressed calldata submission including compressed data.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded txData.\n   */\n  struct SubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n    bytes compressedData;\n  }\n\n  /**\n   * @notice Supporting data for compressed blob data submission.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   */\n  struct SupportingSubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n  }\n\n  /**\n   * @notice Shnarf data for validating a shnarf.\n   * @dev parentShnarf is the parent computed shnarf.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev finalStateRootHash is the final state root hash.\n   * @dev dataEvaluationPoint is the data evaluation point.\n   * @dev dataEvaluationClaim is the data evaluation claim.\n   */\n  struct ShnarfData {\n    bytes32 parentShnarf;\n    bytes32 snarkHash;\n    bytes32 finalStateRootHash;\n    bytes32 dataEvaluationPoint;\n    bytes32 dataEvaluationClaim;\n  }\n\n  /**\n   * @notice Data stucture for compressed blob data submission.\n   * @dev submissionData The supporting data for blob data submission excluding the compressed data.\n   * @dev dataEvaluationClaim The data evaluation claim.\n   * @dev kzgCommitment The blob KZG commitment.\n   * @dev kzgProof The blob KZG point proof.\n   */\n  struct BlobSubmissionData {\n    SupportingSubmissionDataV2 submissionData;\n    uint256 dataEvaluationClaim;\n    bytes kzgCommitment;\n    bytes kzgProof;\n  }\n\n  /**\n   * @notice Supporting data for finalization with or without proof.\n   * @dev NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.\n   * @dev parentStateRootHash is the expected last state root hash finalized.\n   * @dev lastFinalizedShnarf is the last finalized shnarf for proof continuity checks.\n   * @dev finalBlockInData is the final block finalizing until.\n   * @dev shnarfData contains data about the last data submission's shnarf used in finalization.\n   * @dev lastFinalizedTimestamp is the expected last finalized block's timestamp.\n   * @dev finalTimestamp is the timestamp of the last block being finalized.\n   * @dev lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.\n   * @dev l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.\n   * This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.\n   * @dev lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.\n   * @dev l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.\n   * This value will be used along with the stored last finalized L2 calculated message number in the public input.\n   * @dev l2MerkleTreesDepth is the depth of all l2MerkleRoots.\n   * @dev l2MerkleRoots is an array of L2 message merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockInData.\n   * @dev l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events.\n   */\n  struct FinalizationDataV2 {\n    bytes32 parentStateRootHash;\n    bytes32 lastFinalizedShnarf;\n    uint256 finalBlockInData;\n    ShnarfData shnarfData;\n    uint256 lastFinalizedTimestamp;\n    uint256 finalTimestamp;\n    bytes32 lastFinalizedL1RollingHash;\n    bytes32 l1RollingHash;\n    uint256 lastFinalizedL1RollingHashMessageNumber;\n    uint256 l1RollingHashMessageNumber;\n    uint256 l2MerkleTreesDepth;\n    bytes32[] l2MerkleRoots;\n    bytes l2MessagingBlocksOffsets;\n  }\n\n  /**\n   * @notice Emitted when a verifier is set for a particular proof type.\n   * @param verifierAddress The indexed new verifier address being set.\n   * @param proofType The indexed proof type/index that the verifier is mapped to.\n   * @param verifierSetBy The index address who set the verifier at the mapping.\n   * @param oldVerifierAddress Indicates the previous address mapped to the proof type.\n   * @dev The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.\n   * @dev The oldVerifierAddress can be the zero address.\n   */\n  event VerifierAddressChanged(\n    address indexed verifierAddress,\n    uint256 indexed proofType,\n    address indexed verifierSetBy,\n    address oldVerifierAddress\n  );\n\n  /**\n   * @notice Emitted when compressed data is being submitted and verified succesfully on L1.\n   * @param shnarf The indexed shnarf for the data being submitted.\n   * @param startBlock The indexed L2 block number indicating which block the data starts from.\n   * @param endBlock The indexed L2 block number indicating which block the data ends on.\n   * @dev Please note, shnarf was previously dataHash and points to the shnarfFinalBlockNumbers mapping.\n   */\n  event DataSubmittedV2(bytes32 indexed shnarf, uint256 indexed startBlock, uint256 indexed endBlock);\n\n  /**\n   * @notice Emitted when L2 blocks have been finalized on L1.\n   * @param lastBlockFinalized The indexed last L2 block that is finalized in the finalization.\n   * @param startingRootHash The indexed initial (also last finalized) L2 state root hash that the finalization is from.\n   * @param finalRootHash The indexed L2 state root hash that the current finalization is up until.\n   * @param withProof Indicates if the finalization is proven or not.\n   */\n  event DataFinalized(\n    uint256 indexed lastBlockFinalized,\n    bytes32 indexed startingRootHash,\n    bytes32 indexed finalRootHash,\n    bool withProof\n  );\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data field(s) are wrong.\n   */\n  error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data length is wrong.\n   */\n  error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call returns false.\n   */\n  error PointEvaluationFailed();\n\n  /**\n   * @dev Thrown when the blobhash equals to the zero hash.\n   */\n  error EmptyBlobData();\n\n  /**\n   * @dev Thrown when the blobhash at an index equals to the zero hash.\n   */\n  error EmptyBlobDataAtIndex(uint256 index);\n\n  /**\n   * @dev Thrown when the data for multiple blobs' submission has length zero.\n   */\n  error BlobSubmissionDataIsMissing();\n\n  /**\n   * @dev Thrown when the starting block in the data item is out of sequence with the last block number.\n   */\n  error DataStartingBlockDoesNotMatch(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the current data was already submitted.\n   */\n  error DataAlreadySubmitted(bytes32 currentDataHash);\n\n  /**\n   * @dev Thrown when the last finalized shnarf does not match the parent finalizing from.\n   */\n  error LastFinalizedShnarfWrong(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when submissionData is empty.\n   */\n  error EmptySubmissionData();\n\n  /**\n   * @dev Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop).\n   */\n  error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when finalization state does not match.\n   */\n  error FinalizationStateIncorrect(bytes32 expected, bytes32 value);\n\n  /**\n   * @dev Thrown when the first block is greater than final block in submission data.\n   */\n  error FirstBlockGreaterThanFinalBlock(uint256 firstBlockNumber, uint256 finalBlockNumber);\n\n  /**\n   * @dev Thrown when the first block in data is less than or equal to the last finalized block during data submission.\n   */\n  error FirstBlockLessThanOrEqualToLastFinalizedBlock(uint256 firstBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization.\n   */\n  error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block state equals the zero hash during finalization.\n   */\n  error FinalBlockStateEqualsZeroHash();\n\n  /**\n   * @dev Thrown when final l2 block timestamp higher than current block.timestamp during finalization.\n   */\n  error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp);\n\n  /**\n   * @dev Thrown when a rolling hash is provided without a corresponding message number.\n   */\n  error MissingMessageNumberForRollingHash(bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when a message number is provided without a corresponding rolling hash.\n   */\n  error MissingRollingHashForMessageNumber(uint256 messageNumber);\n\n  /**\n   * @dev Thrown when the first byte is not zero.\n   * @dev This is used explicitly with the four bytes in assembly 0x729eebce.\n   */\n  error FirstByteIsNotZero();\n\n  /**\n   * @dev Thrown when bytes length is not a multiple of 32.\n   */\n  error BytesLengthNotMultipleOf32();\n\n  /**\n   * @dev Thrown when the snarkhash is the zero hash.\n   */\n  error SnarkHashIsZeroHash();\n\n  /**\n   * @dev Thrown when parent stateRootHash does not match.\n   */\n  error ParentStateRootHashInvalid(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when the block being finalized until does not match that of the shnarf data.\n   */\n  error FinalBlockDoesNotMatchShnarfFinalBlock(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the lengths of the shnarfs array and final block numbers array don't match.\n   */\n  error ShnarfAndFinalBlockNumberLengthsMismatched(uint256 shnarfsLength, uint256 finalBlockNumbers);\n\n  /**\n   * @dev Thrown when the computed shnarf does not match what is expected.\n   */\n  error FinalShnarfWrong(bytes32 expected, bytes32 value);\n\n  /**\n   * @notice Adds or updated the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external;\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ILineaRollup.submitDataAsCalldata', 'start_line': 2700, 'end_line': 2704, 'offset_start': 101288, 'offset_end': 101433, 'content': 'function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;', 'contract_name': 'ILineaRollup', 'contract_code': "{\n  /**\n   * @notice Supporting data for compressed calldata submission including compressed data.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded txData.\n   */\n  struct SubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n    bytes compressedData;\n  }\n\n  /**\n   * @notice Supporting data for compressed blob data submission.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   */\n  struct SupportingSubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n  }\n\n  /**\n   * @notice Shnarf data for validating a shnarf.\n   * @dev parentShnarf is the parent computed shnarf.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev finalStateRootHash is the final state root hash.\n   * @dev dataEvaluationPoint is the data evaluation point.\n   * @dev dataEvaluationClaim is the data evaluation claim.\n   */\n  struct ShnarfData {\n    bytes32 parentShnarf;\n    bytes32 snarkHash;\n    bytes32 finalStateRootHash;\n    bytes32 dataEvaluationPoint;\n    bytes32 dataEvaluationClaim;\n  }\n\n  /**\n   * @notice Data stucture for compressed blob data submission.\n   * @dev submissionData The supporting data for blob data submission excluding the compressed data.\n   * @dev dataEvaluationClaim The data evaluation claim.\n   * @dev kzgCommitment The blob KZG commitment.\n   * @dev kzgProof The blob KZG point proof.\n   */\n  struct BlobSubmissionData {\n    SupportingSubmissionDataV2 submissionData;\n    uint256 dataEvaluationClaim;\n    bytes kzgCommitment;\n    bytes kzgProof;\n  }\n\n  /**\n   * @notice Supporting data for finalization with or without proof.\n   * @dev NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.\n   * @dev parentStateRootHash is the expected last state root hash finalized.\n   * @dev lastFinalizedShnarf is the last finalized shnarf for proof continuity checks.\n   * @dev finalBlockInData is the final block finalizing until.\n   * @dev shnarfData contains data about the last data submission's shnarf used in finalization.\n   * @dev lastFinalizedTimestamp is the expected last finalized block's timestamp.\n   * @dev finalTimestamp is the timestamp of the last block being finalized.\n   * @dev lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.\n   * @dev l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.\n   * This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.\n   * @dev lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.\n   * @dev l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.\n   * This value will be used along with the stored last finalized L2 calculated message number in the public input.\n   * @dev l2MerkleTreesDepth is the depth of all l2MerkleRoots.\n   * @dev l2MerkleRoots is an array of L2 message merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockInData.\n   * @dev l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events.\n   */\n  struct FinalizationDataV2 {\n    bytes32 parentStateRootHash;\n    bytes32 lastFinalizedShnarf;\n    uint256 finalBlockInData;\n    ShnarfData shnarfData;\n    uint256 lastFinalizedTimestamp;\n    uint256 finalTimestamp;\n    bytes32 lastFinalizedL1RollingHash;\n    bytes32 l1RollingHash;\n    uint256 lastFinalizedL1RollingHashMessageNumber;\n    uint256 l1RollingHashMessageNumber;\n    uint256 l2MerkleTreesDepth;\n    bytes32[] l2MerkleRoots;\n    bytes l2MessagingBlocksOffsets;\n  }\n\n  /**\n   * @notice Emitted when a verifier is set for a particular proof type.\n   * @param verifierAddress The indexed new verifier address being set.\n   * @param proofType The indexed proof type/index that the verifier is mapped to.\n   * @param verifierSetBy The index address who set the verifier at the mapping.\n   * @param oldVerifierAddress Indicates the previous address mapped to the proof type.\n   * @dev The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.\n   * @dev The oldVerifierAddress can be the zero address.\n   */\n  event VerifierAddressChanged(\n    address indexed verifierAddress,\n    uint256 indexed proofType,\n    address indexed verifierSetBy,\n    address oldVerifierAddress\n  );\n\n  /**\n   * @notice Emitted when compressed data is being submitted and verified succesfully on L1.\n   * @param shnarf The indexed shnarf for the data being submitted.\n   * @param startBlock The indexed L2 block number indicating which block the data starts from.\n   * @param endBlock The indexed L2 block number indicating which block the data ends on.\n   * @dev Please note, shnarf was previously dataHash and points to the shnarfFinalBlockNumbers mapping.\n   */\n  event DataSubmittedV2(bytes32 indexed shnarf, uint256 indexed startBlock, uint256 indexed endBlock);\n\n  /**\n   * @notice Emitted when L2 blocks have been finalized on L1.\n   * @param lastBlockFinalized The indexed last L2 block that is finalized in the finalization.\n   * @param startingRootHash The indexed initial (also last finalized) L2 state root hash that the finalization is from.\n   * @param finalRootHash The indexed L2 state root hash that the current finalization is up until.\n   * @param withProof Indicates if the finalization is proven or not.\n   */\n  event DataFinalized(\n    uint256 indexed lastBlockFinalized,\n    bytes32 indexed startingRootHash,\n    bytes32 indexed finalRootHash,\n    bool withProof\n  );\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data field(s) are wrong.\n   */\n  error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data length is wrong.\n   */\n  error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call returns false.\n   */\n  error PointEvaluationFailed();\n\n  /**\n   * @dev Thrown when the blobhash equals to the zero hash.\n   */\n  error EmptyBlobData();\n\n  /**\n   * @dev Thrown when the blobhash at an index equals to the zero hash.\n   */\n  error EmptyBlobDataAtIndex(uint256 index);\n\n  /**\n   * @dev Thrown when the data for multiple blobs' submission has length zero.\n   */\n  error BlobSubmissionDataIsMissing();\n\n  /**\n   * @dev Thrown when the starting block in the data item is out of sequence with the last block number.\n   */\n  error DataStartingBlockDoesNotMatch(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the current data was already submitted.\n   */\n  error DataAlreadySubmitted(bytes32 currentDataHash);\n\n  /**\n   * @dev Thrown when the last finalized shnarf does not match the parent finalizing from.\n   */\n  error LastFinalizedShnarfWrong(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when submissionData is empty.\n   */\n  error EmptySubmissionData();\n\n  /**\n   * @dev Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop).\n   */\n  error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when finalization state does not match.\n   */\n  error FinalizationStateIncorrect(bytes32 expected, bytes32 value);\n\n  /**\n   * @dev Thrown when the first block is greater than final block in submission data.\n   */\n  error FirstBlockGreaterThanFinalBlock(uint256 firstBlockNumber, uint256 finalBlockNumber);\n\n  /**\n   * @dev Thrown when the first block in data is less than or equal to the last finalized block during data submission.\n   */\n  error FirstBlockLessThanOrEqualToLastFinalizedBlock(uint256 firstBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization.\n   */\n  error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block state equals the zero hash during finalization.\n   */\n  error FinalBlockStateEqualsZeroHash();\n\n  /**\n   * @dev Thrown when final l2 block timestamp higher than current block.timestamp during finalization.\n   */\n  error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp);\n\n  /**\n   * @dev Thrown when a rolling hash is provided without a corresponding message number.\n   */\n  error MissingMessageNumberForRollingHash(bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when a message number is provided without a corresponding rolling hash.\n   */\n  error MissingRollingHashForMessageNumber(uint256 messageNumber);\n\n  /**\n   * @dev Thrown when the first byte is not zero.\n   * @dev This is used explicitly with the four bytes in assembly 0x729eebce.\n   */\n  error FirstByteIsNotZero();\n\n  /**\n   * @dev Thrown when bytes length is not a multiple of 32.\n   */\n  error BytesLengthNotMultipleOf32();\n\n  /**\n   * @dev Thrown when the snarkhash is the zero hash.\n   */\n  error SnarkHashIsZeroHash();\n\n  /**\n   * @dev Thrown when parent stateRootHash does not match.\n   */\n  error ParentStateRootHashInvalid(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when the block being finalized until does not match that of the shnarf data.\n   */\n  error FinalBlockDoesNotMatchShnarfFinalBlock(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the lengths of the shnarfs array and final block numbers array don't match.\n   */\n  error ShnarfAndFinalBlockNumberLengthsMismatched(uint256 shnarfsLength, uint256 finalBlockNumbers);\n\n  /**\n   * @dev Thrown when the computed shnarf does not match what is expected.\n   */\n  error FinalShnarfWrong(bytes32 expected, bytes32 value);\n\n  /**\n   * @notice Adds or updated the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external;\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ILineaRollup.finalizeBlocksWithoutProof', 'start_line': 2711, 'end_line': 2711, 'offset_start': 101616, 'offset_end': 101707, 'content': 'function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;', 'contract_name': 'ILineaRollup', 'contract_code': "{\n  /**\n   * @notice Supporting data for compressed calldata submission including compressed data.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded txData.\n   */\n  struct SubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n    bytes compressedData;\n  }\n\n  /**\n   * @notice Supporting data for compressed blob data submission.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   */\n  struct SupportingSubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n  }\n\n  /**\n   * @notice Shnarf data for validating a shnarf.\n   * @dev parentShnarf is the parent computed shnarf.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev finalStateRootHash is the final state root hash.\n   * @dev dataEvaluationPoint is the data evaluation point.\n   * @dev dataEvaluationClaim is the data evaluation claim.\n   */\n  struct ShnarfData {\n    bytes32 parentShnarf;\n    bytes32 snarkHash;\n    bytes32 finalStateRootHash;\n    bytes32 dataEvaluationPoint;\n    bytes32 dataEvaluationClaim;\n  }\n\n  /**\n   * @notice Data stucture for compressed blob data submission.\n   * @dev submissionData The supporting data for blob data submission excluding the compressed data.\n   * @dev dataEvaluationClaim The data evaluation claim.\n   * @dev kzgCommitment The blob KZG commitment.\n   * @dev kzgProof The blob KZG point proof.\n   */\n  struct BlobSubmissionData {\n    SupportingSubmissionDataV2 submissionData;\n    uint256 dataEvaluationClaim;\n    bytes kzgCommitment;\n    bytes kzgProof;\n  }\n\n  /**\n   * @notice Supporting data for finalization with or without proof.\n   * @dev NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.\n   * @dev parentStateRootHash is the expected last state root hash finalized.\n   * @dev lastFinalizedShnarf is the last finalized shnarf for proof continuity checks.\n   * @dev finalBlockInData is the final block finalizing until.\n   * @dev shnarfData contains data about the last data submission's shnarf used in finalization.\n   * @dev lastFinalizedTimestamp is the expected last finalized block's timestamp.\n   * @dev finalTimestamp is the timestamp of the last block being finalized.\n   * @dev lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.\n   * @dev l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.\n   * This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.\n   * @dev lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.\n   * @dev l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.\n   * This value will be used along with the stored last finalized L2 calculated message number in the public input.\n   * @dev l2MerkleTreesDepth is the depth of all l2MerkleRoots.\n   * @dev l2MerkleRoots is an array of L2 message merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockInData.\n   * @dev l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events.\n   */\n  struct FinalizationDataV2 {\n    bytes32 parentStateRootHash;\n    bytes32 lastFinalizedShnarf;\n    uint256 finalBlockInData;\n    ShnarfData shnarfData;\n    uint256 lastFinalizedTimestamp;\n    uint256 finalTimestamp;\n    bytes32 lastFinalizedL1RollingHash;\n    bytes32 l1RollingHash;\n    uint256 lastFinalizedL1RollingHashMessageNumber;\n    uint256 l1RollingHashMessageNumber;\n    uint256 l2MerkleTreesDepth;\n    bytes32[] l2MerkleRoots;\n    bytes l2MessagingBlocksOffsets;\n  }\n\n  /**\n   * @notice Emitted when a verifier is set for a particular proof type.\n   * @param verifierAddress The indexed new verifier address being set.\n   * @param proofType The indexed proof type/index that the verifier is mapped to.\n   * @param verifierSetBy The index address who set the verifier at the mapping.\n   * @param oldVerifierAddress Indicates the previous address mapped to the proof type.\n   * @dev The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.\n   * @dev The oldVerifierAddress can be the zero address.\n   */\n  event VerifierAddressChanged(\n    address indexed verifierAddress,\n    uint256 indexed proofType,\n    address indexed verifierSetBy,\n    address oldVerifierAddress\n  );\n\n  /**\n   * @notice Emitted when compressed data is being submitted and verified succesfully on L1.\n   * @param shnarf The indexed shnarf for the data being submitted.\n   * @param startBlock The indexed L2 block number indicating which block the data starts from.\n   * @param endBlock The indexed L2 block number indicating which block the data ends on.\n   * @dev Please note, shnarf was previously dataHash and points to the shnarfFinalBlockNumbers mapping.\n   */\n  event DataSubmittedV2(bytes32 indexed shnarf, uint256 indexed startBlock, uint256 indexed endBlock);\n\n  /**\n   * @notice Emitted when L2 blocks have been finalized on L1.\n   * @param lastBlockFinalized The indexed last L2 block that is finalized in the finalization.\n   * @param startingRootHash The indexed initial (also last finalized) L2 state root hash that the finalization is from.\n   * @param finalRootHash The indexed L2 state root hash that the current finalization is up until.\n   * @param withProof Indicates if the finalization is proven or not.\n   */\n  event DataFinalized(\n    uint256 indexed lastBlockFinalized,\n    bytes32 indexed startingRootHash,\n    bytes32 indexed finalRootHash,\n    bool withProof\n  );\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data field(s) are wrong.\n   */\n  error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data length is wrong.\n   */\n  error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call returns false.\n   */\n  error PointEvaluationFailed();\n\n  /**\n   * @dev Thrown when the blobhash equals to the zero hash.\n   */\n  error EmptyBlobData();\n\n  /**\n   * @dev Thrown when the blobhash at an index equals to the zero hash.\n   */\n  error EmptyBlobDataAtIndex(uint256 index);\n\n  /**\n   * @dev Thrown when the data for multiple blobs' submission has length zero.\n   */\n  error BlobSubmissionDataIsMissing();\n\n  /**\n   * @dev Thrown when the starting block in the data item is out of sequence with the last block number.\n   */\n  error DataStartingBlockDoesNotMatch(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the current data was already submitted.\n   */\n  error DataAlreadySubmitted(bytes32 currentDataHash);\n\n  /**\n   * @dev Thrown when the last finalized shnarf does not match the parent finalizing from.\n   */\n  error LastFinalizedShnarfWrong(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when submissionData is empty.\n   */\n  error EmptySubmissionData();\n\n  /**\n   * @dev Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop).\n   */\n  error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when finalization state does not match.\n   */\n  error FinalizationStateIncorrect(bytes32 expected, bytes32 value);\n\n  /**\n   * @dev Thrown when the first block is greater than final block in submission data.\n   */\n  error FirstBlockGreaterThanFinalBlock(uint256 firstBlockNumber, uint256 finalBlockNumber);\n\n  /**\n   * @dev Thrown when the first block in data is less than or equal to the last finalized block during data submission.\n   */\n  error FirstBlockLessThanOrEqualToLastFinalizedBlock(uint256 firstBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization.\n   */\n  error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block state equals the zero hash during finalization.\n   */\n  error FinalBlockStateEqualsZeroHash();\n\n  /**\n   * @dev Thrown when final l2 block timestamp higher than current block.timestamp during finalization.\n   */\n  error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp);\n\n  /**\n   * @dev Thrown when a rolling hash is provided without a corresponding message number.\n   */\n  error MissingMessageNumberForRollingHash(bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when a message number is provided without a corresponding rolling hash.\n   */\n  error MissingRollingHashForMessageNumber(uint256 messageNumber);\n\n  /**\n   * @dev Thrown when the first byte is not zero.\n   * @dev This is used explicitly with the four bytes in assembly 0x729eebce.\n   */\n  error FirstByteIsNotZero();\n\n  /**\n   * @dev Thrown when bytes length is not a multiple of 32.\n   */\n  error BytesLengthNotMultipleOf32();\n\n  /**\n   * @dev Thrown when the snarkhash is the zero hash.\n   */\n  error SnarkHashIsZeroHash();\n\n  /**\n   * @dev Thrown when parent stateRootHash does not match.\n   */\n  error ParentStateRootHashInvalid(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when the block being finalized until does not match that of the shnarf data.\n   */\n  error FinalBlockDoesNotMatchShnarfFinalBlock(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the lengths of the shnarfs array and final block numbers array don't match.\n   */\n  error ShnarfAndFinalBlockNumberLengthsMismatched(uint256 shnarfsLength, uint256 finalBlockNumbers);\n\n  /**\n   * @dev Thrown when the computed shnarf does not match what is expected.\n   */\n  error FinalShnarfWrong(bytes32 expected, bytes32 value);\n\n  /**\n   * @notice Adds or updated the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external;\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'ILineaRollup.finalizeBlocksWithProof', 'start_line': 2720, 'end_line': 2724, 'offset_start': 101972, 'offset_end': 102129, 'content': 'function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;', 'contract_name': 'ILineaRollup', 'contract_code': "{\n  /**\n   * @notice Supporting data for compressed calldata submission including compressed data.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded txData.\n   */\n  struct SubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n    bytes compressedData;\n  }\n\n  /**\n   * @notice Supporting data for compressed blob data submission.\n   * @dev finalStateRootHash is used to set state root at the end of the data.\n   * @dev firstBlockInData is the first block that is included in the data submitted.\n   * @dev finalBlockInData is the last block that is included in the data submitted.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   */\n  struct SupportingSubmissionDataV2 {\n    bytes32 finalStateRootHash;\n    uint256 firstBlockInData;\n    uint256 finalBlockInData;\n    bytes32 snarkHash;\n  }\n\n  /**\n   * @notice Shnarf data for validating a shnarf.\n   * @dev parentShnarf is the parent computed shnarf.\n   * @dev snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.\n   * @dev finalStateRootHash is the final state root hash.\n   * @dev dataEvaluationPoint is the data evaluation point.\n   * @dev dataEvaluationClaim is the data evaluation claim.\n   */\n  struct ShnarfData {\n    bytes32 parentShnarf;\n    bytes32 snarkHash;\n    bytes32 finalStateRootHash;\n    bytes32 dataEvaluationPoint;\n    bytes32 dataEvaluationClaim;\n  }\n\n  /**\n   * @notice Data stucture for compressed blob data submission.\n   * @dev submissionData The supporting data for blob data submission excluding the compressed data.\n   * @dev dataEvaluationClaim The data evaluation claim.\n   * @dev kzgCommitment The blob KZG commitment.\n   * @dev kzgProof The blob KZG point proof.\n   */\n  struct BlobSubmissionData {\n    SupportingSubmissionDataV2 submissionData;\n    uint256 dataEvaluationClaim;\n    bytes kzgCommitment;\n    bytes kzgProof;\n  }\n\n  /**\n   * @notice Supporting data for finalization with or without proof.\n   * @dev NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.\n   * @dev parentStateRootHash is the expected last state root hash finalized.\n   * @dev lastFinalizedShnarf is the last finalized shnarf for proof continuity checks.\n   * @dev finalBlockInData is the final block finalizing until.\n   * @dev shnarfData contains data about the last data submission's shnarf used in finalization.\n   * @dev lastFinalizedTimestamp is the expected last finalized block's timestamp.\n   * @dev finalTimestamp is the timestamp of the last block being finalized.\n   * @dev lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.\n   * @dev l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.\n   * This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.\n   * @dev lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.\n   * @dev l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.\n   * This value will be used along with the stored last finalized L2 calculated message number in the public input.\n   * @dev l2MerkleTreesDepth is the depth of all l2MerkleRoots.\n   * @dev l2MerkleRoots is an array of L2 message merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockInData.\n   * @dev l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events.\n   */\n  struct FinalizationDataV2 {\n    bytes32 parentStateRootHash;\n    bytes32 lastFinalizedShnarf;\n    uint256 finalBlockInData;\n    ShnarfData shnarfData;\n    uint256 lastFinalizedTimestamp;\n    uint256 finalTimestamp;\n    bytes32 lastFinalizedL1RollingHash;\n    bytes32 l1RollingHash;\n    uint256 lastFinalizedL1RollingHashMessageNumber;\n    uint256 l1RollingHashMessageNumber;\n    uint256 l2MerkleTreesDepth;\n    bytes32[] l2MerkleRoots;\n    bytes l2MessagingBlocksOffsets;\n  }\n\n  /**\n   * @notice Emitted when a verifier is set for a particular proof type.\n   * @param verifierAddress The indexed new verifier address being set.\n   * @param proofType The indexed proof type/index that the verifier is mapped to.\n   * @param verifierSetBy The index address who set the verifier at the mapping.\n   * @param oldVerifierAddress Indicates the previous address mapped to the proof type.\n   * @dev The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.\n   * @dev The oldVerifierAddress can be the zero address.\n   */\n  event VerifierAddressChanged(\n    address indexed verifierAddress,\n    uint256 indexed proofType,\n    address indexed verifierSetBy,\n    address oldVerifierAddress\n  );\n\n  /**\n   * @notice Emitted when compressed data is being submitted and verified succesfully on L1.\n   * @param shnarf The indexed shnarf for the data being submitted.\n   * @param startBlock The indexed L2 block number indicating which block the data starts from.\n   * @param endBlock The indexed L2 block number indicating which block the data ends on.\n   * @dev Please note, shnarf was previously dataHash and points to the shnarfFinalBlockNumbers mapping.\n   */\n  event DataSubmittedV2(bytes32 indexed shnarf, uint256 indexed startBlock, uint256 indexed endBlock);\n\n  /**\n   * @notice Emitted when L2 blocks have been finalized on L1.\n   * @param lastBlockFinalized The indexed last L2 block that is finalized in the finalization.\n   * @param startingRootHash The indexed initial (also last finalized) L2 state root hash that the finalization is from.\n   * @param finalRootHash The indexed L2 state root hash that the current finalization is up until.\n   * @param withProof Indicates if the finalization is proven or not.\n   */\n  event DataFinalized(\n    uint256 indexed lastBlockFinalized,\n    bytes32 indexed startingRootHash,\n    bytes32 indexed finalRootHash,\n    bool withProof\n  );\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data field(s) are wrong.\n   */\n  error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call return data length is wrong.\n   */\n  error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the point evaluation precompile call returns false.\n   */\n  error PointEvaluationFailed();\n\n  /**\n   * @dev Thrown when the blobhash equals to the zero hash.\n   */\n  error EmptyBlobData();\n\n  /**\n   * @dev Thrown when the blobhash at an index equals to the zero hash.\n   */\n  error EmptyBlobDataAtIndex(uint256 index);\n\n  /**\n   * @dev Thrown when the data for multiple blobs' submission has length zero.\n   */\n  error BlobSubmissionDataIsMissing();\n\n  /**\n   * @dev Thrown when the starting block in the data item is out of sequence with the last block number.\n   */\n  error DataStartingBlockDoesNotMatch(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the current data was already submitted.\n   */\n  error DataAlreadySubmitted(bytes32 currentDataHash);\n\n  /**\n   * @dev Thrown when the last finalized shnarf does not match the parent finalizing from.\n   */\n  error LastFinalizedShnarfWrong(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when submissionData is empty.\n   */\n  error EmptySubmissionData();\n\n  /**\n   * @dev Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop).\n   */\n  error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when finalization state does not match.\n   */\n  error FinalizationStateIncorrect(bytes32 expected, bytes32 value);\n\n  /**\n   * @dev Thrown when the first block is greater than final block in submission data.\n   */\n  error FirstBlockGreaterThanFinalBlock(uint256 firstBlockNumber, uint256 finalBlockNumber);\n\n  /**\n   * @dev Thrown when the first block in data is less than or equal to the last finalized block during data submission.\n   */\n  error FirstBlockLessThanOrEqualToLastFinalizedBlock(uint256 firstBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization.\n   */\n  error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock);\n\n  /**\n   * @dev Thrown when the final block state equals the zero hash during finalization.\n   */\n  error FinalBlockStateEqualsZeroHash();\n\n  /**\n   * @dev Thrown when final l2 block timestamp higher than current block.timestamp during finalization.\n   */\n  error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp);\n\n  /**\n   * @dev Thrown when a rolling hash is provided without a corresponding message number.\n   */\n  error MissingMessageNumberForRollingHash(bytes32 rollingHash);\n\n  /**\n   * @dev Thrown when a message number is provided without a corresponding rolling hash.\n   */\n  error MissingRollingHashForMessageNumber(uint256 messageNumber);\n\n  /**\n   * @dev Thrown when the first byte is not zero.\n   * @dev This is used explicitly with the four bytes in assembly 0x729eebce.\n   */\n  error FirstByteIsNotZero();\n\n  /**\n   * @dev Thrown when bytes length is not a multiple of 32.\n   */\n  error BytesLengthNotMultipleOf32();\n\n  /**\n   * @dev Thrown when the snarkhash is the zero hash.\n   */\n  error SnarkHashIsZeroHash();\n\n  /**\n   * @dev Thrown when parent stateRootHash does not match.\n   */\n  error ParentStateRootHashInvalid(bytes32 expected, bytes32 actual);\n\n  /**\n   * @dev Thrown when the block being finalized until does not match that of the shnarf data.\n   */\n  error FinalBlockDoesNotMatchShnarfFinalBlock(uint256 expected, uint256 actual);\n\n  /**\n   * @dev Thrown when the lengths of the shnarfs array and final block numbers array don't match.\n   */\n  error ShnarfAndFinalBlockNumberLengthsMismatched(uint256 shnarfsLength, uint256 finalBlockNumbers);\n\n  /**\n   * @dev Thrown when the computed shnarf does not match what is expected.\n   */\n  error FinalShnarfWrong(bytes32 expected, bytes32 value);\n\n  /**\n   * @notice Adds or updated the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _newVerifierAddress The address for the verifier contract.\n   * @param _proofType The proof type being set/updated.\n   */\n  function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external;\n\n  /**\n   * @notice Unset the verifier contract address for a proof type.\n   * @dev VERIFIER_SETTER_ROLE is required to execute.\n   * @param _proofType The proof type being set/updated.\n   */\n  function unsetVerifierAddress(uint256 _proofType) external;\n\n  /**\n   * @notice Submit one or more EIP-4844 blobs.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @dev This should be a blob carrying transaction.\n   * @param _blobSubmissionData The data for blob submission including proofs and required polynomials.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _finalBlobShnarf The expected final shnarf post computation of all the blob shnarfs.\n   */\n  function submitBlobs(\n    BlobSubmissionData[] calldata _blobSubmissionData,\n    bytes32 _parentShnarf,\n    bytes32 _finalBlobShnarf\n  ) external;\n\n  /**\n   * @notice Submit blobs using compressed data via calldata.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _submissionData The supporting data for compressed data submission including compressed data.\n   * @param _parentShnarf The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation.\n   * @param _expectedShnarf The expected shnarf post computation of all the submission.\n   */\n  function submitDataAsCalldata(\n    SubmissionDataV2 calldata _submissionData,\n    bytes32 _parentShnarf,\n    bytes32 _expectedShnarf\n  ) external;\n\n  /**\n   * @notice Finalize compressed blocks without proof.\n   * @dev DEFAULT_ADMIN_ROLE is required to execute.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithoutProof(FinalizationDataV2 calldata _finalizationData) external;\n\n  /**\n   * @notice Finalize compressed blocks with proof.\n   * @dev OPERATOR_ROLE is required to execute.\n   * @param _aggregatedProof The aggregated proof.\n   * @param _proofType The proof type.\n   * @param _finalizationData The full finalization data.\n   */\n  function finalizeBlocksWithProof(\n    bytes calldata _aggregatedProof,\n    uint256 _proofType,\n    FinalizationDataV2 calldata _finalizationData\n  ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'Utils._efficientKeccak', 'start_line': 2736, 'end_line': 2743, 'offset_start': 102350, 'offset_end': 102599, 'content': 'function _efficientKeccak(bytes32 _left, bytes32 _right) internal pure returns (bytes32 value) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, _left)\n      mstore(0x20, _right)\n      value := keccak256(0x00, 0x40)\n    }\n  }', 'contract_name': 'Utils', 'contract_code': '{\n  /**\n   * @notice Performs a gas optimized keccak hash.\n   * @param _left Left value.\n   * @param _right Right value.\n   */\n  function _efficientKeccak(bytes32 _left, bytes32 _right) internal pure returns (bytes32 value) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, _left)\n      mstore(0x20, _right)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageManager._addRollingHash', 'start_line': 2839, 'end_line': 2846, 'offset_start': 106077, 'offset_end': 106419, 'content': 'function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal {\n    unchecked {\n      bytes32 newRollingHash = Utils._efficientKeccak(rollingHashes[_messageNumber - 1], _messageHash);\n\n      rollingHashes[_messageNumber] = newRollingHash;\n      emit RollingHashUpdated(_messageNumber, newRollingHash, _messageHash);\n    }\n  }', 'contract_name': 'L1MessageManager', 'contract_code': "{\n  using BitMaps for BitMaps.BitMap;\n  using Utils for *;\n\n  mapping(uint256 messageNumber => bytes32 rollingHash) public rollingHashes;\n  BitMaps.BitMap internal _messageClaimedBitMap;\n  mapping(bytes32 merkleRoot => uint256 treeDepth) public l2MerkleRootsDepths;\n\n  /// @dev Total contract storage is 53 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageManager;\n\n  /**\n   * @notice Take an existing message hash, calculates the rolling hash and stores at the message number.\n   * @param _messageNumber The current message number being sent.\n   * @param _messageHash The hash of the message being sent.\n   */\n  function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal {\n    unchecked {\n      bytes32 newRollingHash = Utils._efficientKeccak(rollingHashes[_messageNumber - 1], _messageHash);\n\n      rollingHashes[_messageNumber] = newRollingHash;\n      emit RollingHashUpdated(_messageNumber, newRollingHash, _messageHash);\n    }\n  }\n\n  /**\n   * @notice Set the L2->L1 message as claimed when a user claims a message on L1.\n   * @param  _messageNumber The message number on L2.\n   */\n  function _setL2L1MessageToClaimed(uint256 _messageNumber) internal {\n    if (_messageClaimedBitMap.get(_messageNumber)) {\n      revert MessageAlreadyClaimed(_messageNumber);\n    }\n    _messageClaimedBitMap.set(_messageNumber);\n  }\n\n  /**\n   * @notice Add the L2 merkle roots to the storage.\n   * @dev This function is called during block finalization.\n   * @dev The _treeDepth does not need to be checked to be non-zero as it is,\n   * already enforced to be non-zero in the circuit, and used in the proof's public input.\n   * @param _newRoots New L2 merkle roots.\n   */\n  function _addL2MerkleRoots(bytes32[] calldata _newRoots, uint256 _treeDepth) internal {\n    for (uint256 i; i < _newRoots.length; ++i) {\n      if (l2MerkleRootsDepths[_newRoots[i]] != 0) {\n        revert L2MerkleRootAlreadyAnchored(_newRoots[i]);\n      }\n\n      l2MerkleRootsDepths[_newRoots[i]] = _treeDepth;\n\n      emit L2MerkleRootAdded(_newRoots[i], _treeDepth);\n    }\n  }\n\n  /**\n   * @notice Emit an event for each L2 block containing L2->L1 messages.\n   * @dev This function is called during block finalization.\n   * @param _l2MessagingBlocksOffsets Is a sequence of uint16 values, where each value plus the last finalized L2 block number.\n   * indicates which L2 blocks have L2->L1 messages.\n   * @param _currentL2BlockNumber Last L2 block number finalized on L1.\n   */\n  function _anchorL2MessagingBlocks(bytes calldata _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal {\n    if (_l2MessagingBlocksOffsets.length % 2 != 0) {\n      revert BytesLengthNotMultipleOfTwo(_l2MessagingBlocksOffsets.length);\n    }\n\n    uint256 l2BlockOffset;\n    unchecked {\n      for (uint256 i; i < _l2MessagingBlocksOffsets.length; ) {\n        assembly {\n          l2BlockOffset := shr(240, calldataload(add(_l2MessagingBlocksOffsets.offset, i)))\n        }\n        emit L2MessagingBlockAnchored(_currentL2BlockNumber + l2BlockOffset);\n        i += 2;\n      }\n    }\n  }\n\n  /**\n   * @notice Check if the L2->L1 message is claimed or not.\n   * @param _messageNumber The message number on L2.\n   */\n  function isMessageClaimed(uint256 _messageNumber) external view returns (bool) {\n    return _messageClaimedBitMap.get(_messageNumber);\n  }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageManager._setL2L1MessageToClaimed', 'start_line': 2852, 'end_line': 2857, 'offset_start': 106573, 'offset_end': 106802, 'content': 'function _setL2L1MessageToClaimed(uint256 _messageNumber) internal {\n    if (_messageClaimedBitMap.get(_messageNumber)) {\n      revert MessageAlreadyClaimed(_messageNumber);\n    }\n    _messageClaimedBitMap.set(_messageNumber);\n  }', 'contract_name': 'L1MessageManager', 'contract_code': "{\n  using BitMaps for BitMaps.BitMap;\n  using Utils for *;\n\n  mapping(uint256 messageNumber => bytes32 rollingHash) public rollingHashes;\n  BitMaps.BitMap internal _messageClaimedBitMap;\n  mapping(bytes32 merkleRoot => uint256 treeDepth) public l2MerkleRootsDepths;\n\n  /// @dev Total contract storage is 53 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageManager;\n\n  /**\n   * @notice Take an existing message hash, calculates the rolling hash and stores at the message number.\n   * @param _messageNumber The current message number being sent.\n   * @param _messageHash The hash of the message being sent.\n   */\n  function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal {\n    unchecked {\n      bytes32 newRollingHash = Utils._efficientKeccak(rollingHashes[_messageNumber - 1], _messageHash);\n\n      rollingHashes[_messageNumber] = newRollingHash;\n      emit RollingHashUpdated(_messageNumber, newRollingHash, _messageHash);\n    }\n  }\n\n  /**\n   * @notice Set the L2->L1 message as claimed when a user claims a message on L1.\n   * @param  _messageNumber The message number on L2.\n   */\n  function _setL2L1MessageToClaimed(uint256 _messageNumber) internal {\n    if (_messageClaimedBitMap.get(_messageNumber)) {\n      revert MessageAlreadyClaimed(_messageNumber);\n    }\n    _messageClaimedBitMap.set(_messageNumber);\n  }\n\n  /**\n   * @notice Add the L2 merkle roots to the storage.\n   * @dev This function is called during block finalization.\n   * @dev The _treeDepth does not need to be checked to be non-zero as it is,\n   * already enforced to be non-zero in the circuit, and used in the proof's public input.\n   * @param _newRoots New L2 merkle roots.\n   */\n  function _addL2MerkleRoots(bytes32[] calldata _newRoots, uint256 _treeDepth) internal {\n    for (uint256 i; i < _newRoots.length; ++i) {\n      if (l2MerkleRootsDepths[_newRoots[i]] != 0) {\n        revert L2MerkleRootAlreadyAnchored(_newRoots[i]);\n      }\n\n      l2MerkleRootsDepths[_newRoots[i]] = _treeDepth;\n\n      emit L2MerkleRootAdded(_newRoots[i], _treeDepth);\n    }\n  }\n\n  /**\n   * @notice Emit an event for each L2 block containing L2->L1 messages.\n   * @dev This function is called during block finalization.\n   * @param _l2MessagingBlocksOffsets Is a sequence of uint16 values, where each value plus the last finalized L2 block number.\n   * indicates which L2 blocks have L2->L1 messages.\n   * @param _currentL2BlockNumber Last L2 block number finalized on L1.\n   */\n  function _anchorL2MessagingBlocks(bytes calldata _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal {\n    if (_l2MessagingBlocksOffsets.length % 2 != 0) {\n      revert BytesLengthNotMultipleOfTwo(_l2MessagingBlocksOffsets.length);\n    }\n\n    uint256 l2BlockOffset;\n    unchecked {\n      for (uint256 i; i < _l2MessagingBlocksOffsets.length; ) {\n        assembly {\n          l2BlockOffset := shr(240, calldataload(add(_l2MessagingBlocksOffsets.offset, i)))\n        }\n        emit L2MessagingBlockAnchored(_currentL2BlockNumber + l2BlockOffset);\n        i += 2;\n      }\n    }\n  }\n\n  /**\n   * @notice Check if the L2->L1 message is claimed or not.\n   * @param _messageNumber The message number on L2.\n   */\n  function isMessageClaimed(uint256 _messageNumber) external view returns (bool) {\n    return _messageClaimedBitMap.get(_messageNumber);\n  }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageManager._addL2MerkleRoots', 'start_line': 2866, 'end_line': 2876, 'offset_start': 107145, 'offset_end': 107520, 'content': 'function _addL2MerkleRoots(bytes32[] calldata _newRoots, uint256 _treeDepth) internal {\n    for (uint256 i; i < _newRoots.length; ++i) {\n      if (l2MerkleRootsDepths[_newRoots[i]] != 0) {\n        revert L2MerkleRootAlreadyAnchored(_newRoots[i]);\n      }\n\n      l2MerkleRootsDepths[_newRoots[i]] = _treeDepth;\n\n      emit L2MerkleRootAdded(_newRoots[i], _treeDepth);\n    }\n  }', 'contract_name': 'L1MessageManager', 'contract_code': "{\n  using BitMaps for BitMaps.BitMap;\n  using Utils for *;\n\n  mapping(uint256 messageNumber => bytes32 rollingHash) public rollingHashes;\n  BitMaps.BitMap internal _messageClaimedBitMap;\n  mapping(bytes32 merkleRoot => uint256 treeDepth) public l2MerkleRootsDepths;\n\n  /// @dev Total contract storage is 53 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageManager;\n\n  /**\n   * @notice Take an existing message hash, calculates the rolling hash and stores at the message number.\n   * @param _messageNumber The current message number being sent.\n   * @param _messageHash The hash of the message being sent.\n   */\n  function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal {\n    unchecked {\n      bytes32 newRollingHash = Utils._efficientKeccak(rollingHashes[_messageNumber - 1], _messageHash);\n\n      rollingHashes[_messageNumber] = newRollingHash;\n      emit RollingHashUpdated(_messageNumber, newRollingHash, _messageHash);\n    }\n  }\n\n  /**\n   * @notice Set the L2->L1 message as claimed when a user claims a message on L1.\n   * @param  _messageNumber The message number on L2.\n   */\n  function _setL2L1MessageToClaimed(uint256 _messageNumber) internal {\n    if (_messageClaimedBitMap.get(_messageNumber)) {\n      revert MessageAlreadyClaimed(_messageNumber);\n    }\n    _messageClaimedBitMap.set(_messageNumber);\n  }\n\n  /**\n   * @notice Add the L2 merkle roots to the storage.\n   * @dev This function is called during block finalization.\n   * @dev The _treeDepth does not need to be checked to be non-zero as it is,\n   * already enforced to be non-zero in the circuit, and used in the proof's public input.\n   * @param _newRoots New L2 merkle roots.\n   */\n  function _addL2MerkleRoots(bytes32[] calldata _newRoots, uint256 _treeDepth) internal {\n    for (uint256 i; i < _newRoots.length; ++i) {\n      if (l2MerkleRootsDepths[_newRoots[i]] != 0) {\n        revert L2MerkleRootAlreadyAnchored(_newRoots[i]);\n      }\n\n      l2MerkleRootsDepths[_newRoots[i]] = _treeDepth;\n\n      emit L2MerkleRootAdded(_newRoots[i], _treeDepth);\n    }\n  }\n\n  /**\n   * @notice Emit an event for each L2 block containing L2->L1 messages.\n   * @dev This function is called during block finalization.\n   * @param _l2MessagingBlocksOffsets Is a sequence of uint16 values, where each value plus the last finalized L2 block number.\n   * indicates which L2 blocks have L2->L1 messages.\n   * @param _currentL2BlockNumber Last L2 block number finalized on L1.\n   */\n  function _anchorL2MessagingBlocks(bytes calldata _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal {\n    if (_l2MessagingBlocksOffsets.length % 2 != 0) {\n      revert BytesLengthNotMultipleOfTwo(_l2MessagingBlocksOffsets.length);\n    }\n\n    uint256 l2BlockOffset;\n    unchecked {\n      for (uint256 i; i < _l2MessagingBlocksOffsets.length; ) {\n        assembly {\n          l2BlockOffset := shr(240, calldataload(add(_l2MessagingBlocksOffsets.offset, i)))\n        }\n        emit L2MessagingBlockAnchored(_currentL2BlockNumber + l2BlockOffset);\n        i += 2;\n      }\n    }\n  }\n\n  /**\n   * @notice Check if the L2->L1 message is claimed or not.\n   * @param _messageNumber The message number on L2.\n   */\n  function isMessageClaimed(uint256 _messageNumber) external view returns (bool) {\n    return _messageClaimedBitMap.get(_messageNumber);\n  }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageManager._anchorL2MessagingBlocks', 'start_line': 2885, 'end_line': 2900, 'offset_start': 107924, 'offset_end': 108516, 'content': 'function _anchorL2MessagingBlocks(bytes calldata _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal {\n    if (_l2MessagingBlocksOffsets.length % 2 != 0) {\n      revert BytesLengthNotMultipleOfTwo(_l2MessagingBlocksOffsets.length);\n    }\n\n    uint256 l2BlockOffset;\n    unchecked {\n      for (uint256 i; i < _l2MessagingBlocksOffsets.length; ) {\n        assembly {\n          l2BlockOffset := shr(240, calldataload(add(_l2MessagingBlocksOffsets.offset, i)))\n        }\n        emit L2MessagingBlockAnchored(_currentL2BlockNumber + l2BlockOffset);\n        i += 2;\n      }\n    }\n  }', 'contract_name': 'L1MessageManager', 'contract_code': "{\n  using BitMaps for BitMaps.BitMap;\n  using Utils for *;\n\n  mapping(uint256 messageNumber => bytes32 rollingHash) public rollingHashes;\n  BitMaps.BitMap internal _messageClaimedBitMap;\n  mapping(bytes32 merkleRoot => uint256 treeDepth) public l2MerkleRootsDepths;\n\n  /// @dev Total contract storage is 53 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageManager;\n\n  /**\n   * @notice Take an existing message hash, calculates the rolling hash and stores at the message number.\n   * @param _messageNumber The current message number being sent.\n   * @param _messageHash The hash of the message being sent.\n   */\n  function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal {\n    unchecked {\n      bytes32 newRollingHash = Utils._efficientKeccak(rollingHashes[_messageNumber - 1], _messageHash);\n\n      rollingHashes[_messageNumber] = newRollingHash;\n      emit RollingHashUpdated(_messageNumber, newRollingHash, _messageHash);\n    }\n  }\n\n  /**\n   * @notice Set the L2->L1 message as claimed when a user claims a message on L1.\n   * @param  _messageNumber The message number on L2.\n   */\n  function _setL2L1MessageToClaimed(uint256 _messageNumber) internal {\n    if (_messageClaimedBitMap.get(_messageNumber)) {\n      revert MessageAlreadyClaimed(_messageNumber);\n    }\n    _messageClaimedBitMap.set(_messageNumber);\n  }\n\n  /**\n   * @notice Add the L2 merkle roots to the storage.\n   * @dev This function is called during block finalization.\n   * @dev The _treeDepth does not need to be checked to be non-zero as it is,\n   * already enforced to be non-zero in the circuit, and used in the proof's public input.\n   * @param _newRoots New L2 merkle roots.\n   */\n  function _addL2MerkleRoots(bytes32[] calldata _newRoots, uint256 _treeDepth) internal {\n    for (uint256 i; i < _newRoots.length; ++i) {\n      if (l2MerkleRootsDepths[_newRoots[i]] != 0) {\n        revert L2MerkleRootAlreadyAnchored(_newRoots[i]);\n      }\n\n      l2MerkleRootsDepths[_newRoots[i]] = _treeDepth;\n\n      emit L2MerkleRootAdded(_newRoots[i], _treeDepth);\n    }\n  }\n\n  /**\n   * @notice Emit an event for each L2 block containing L2->L1 messages.\n   * @dev This function is called during block finalization.\n   * @param _l2MessagingBlocksOffsets Is a sequence of uint16 values, where each value plus the last finalized L2 block number.\n   * indicates which L2 blocks have L2->L1 messages.\n   * @param _currentL2BlockNumber Last L2 block number finalized on L1.\n   */\n  function _anchorL2MessagingBlocks(bytes calldata _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal {\n    if (_l2MessagingBlocksOffsets.length % 2 != 0) {\n      revert BytesLengthNotMultipleOfTwo(_l2MessagingBlocksOffsets.length);\n    }\n\n    uint256 l2BlockOffset;\n    unchecked {\n      for (uint256 i; i < _l2MessagingBlocksOffsets.length; ) {\n        assembly {\n          l2BlockOffset := shr(240, calldataload(add(_l2MessagingBlocksOffsets.offset, i)))\n        }\n        emit L2MessagingBlockAnchored(_currentL2BlockNumber + l2BlockOffset);\n        i += 2;\n      }\n    }\n  }\n\n  /**\n   * @notice Check if the L2->L1 message is claimed or not.\n   * @param _messageNumber The message number on L2.\n   */\n  function isMessageClaimed(uint256 _messageNumber) external view returns (bool) {\n    return _messageClaimedBitMap.get(_messageNumber);\n  }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'L1MessageManager.isMessageClaimed', 'start_line': 2906, 'end_line': 2908, 'offset_start': 108646, 'offset_end': 108783, 'content': 'function isMessageClaimed(uint256 _messageNumber) external view returns (bool) {\n    return _messageClaimedBitMap.get(_messageNumber);\n  }', 'contract_name': 'L1MessageManager', 'contract_code': "{\n  using BitMaps for BitMaps.BitMap;\n  using Utils for *;\n\n  mapping(uint256 messageNumber => bytes32 rollingHash) public rollingHashes;\n  BitMaps.BitMap internal _messageClaimedBitMap;\n  mapping(bytes32 merkleRoot => uint256 treeDepth) public l2MerkleRootsDepths;\n\n  /// @dev Total contract storage is 53 slots including the gap below.\n  /// @dev Keep 50 free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L1MessageManager;\n\n  /**\n   * @notice Take an existing message hash, calculates the rolling hash and stores at the message number.\n   * @param _messageNumber The current message number being sent.\n   * @param _messageHash The hash of the message being sent.\n   */\n  function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal {\n    unchecked {\n      bytes32 newRollingHash = Utils._efficientKeccak(rollingHashes[_messageNumber - 1], _messageHash);\n\n      rollingHashes[_messageNumber] = newRollingHash;\n      emit RollingHashUpdated(_messageNumber, newRollingHash, _messageHash);\n    }\n  }\n\n  /**\n   * @notice Set the L2->L1 message as claimed when a user claims a message on L1.\n   * @param  _messageNumber The message number on L2.\n   */\n  function _setL2L1MessageToClaimed(uint256 _messageNumber) internal {\n    if (_messageClaimedBitMap.get(_messageNumber)) {\n      revert MessageAlreadyClaimed(_messageNumber);\n    }\n    _messageClaimedBitMap.set(_messageNumber);\n  }\n\n  /**\n   * @notice Add the L2 merkle roots to the storage.\n   * @dev This function is called during block finalization.\n   * @dev The _treeDepth does not need to be checked to be non-zero as it is,\n   * already enforced to be non-zero in the circuit, and used in the proof's public input.\n   * @param _newRoots New L2 merkle roots.\n   */\n  function _addL2MerkleRoots(bytes32[] calldata _newRoots, uint256 _treeDepth) internal {\n    for (uint256 i; i < _newRoots.length; ++i) {\n      if (l2MerkleRootsDepths[_newRoots[i]] != 0) {\n        revert L2MerkleRootAlreadyAnchored(_newRoots[i]);\n      }\n\n      l2MerkleRootsDepths[_newRoots[i]] = _treeDepth;\n\n      emit L2MerkleRootAdded(_newRoots[i], _treeDepth);\n    }\n  }\n\n  /**\n   * @notice Emit an event for each L2 block containing L2->L1 messages.\n   * @dev This function is called during block finalization.\n   * @param _l2MessagingBlocksOffsets Is a sequence of uint16 values, where each value plus the last finalized L2 block number.\n   * indicates which L2 blocks have L2->L1 messages.\n   * @param _currentL2BlockNumber Last L2 block number finalized on L1.\n   */\n  function _anchorL2MessagingBlocks(bytes calldata _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal {\n    if (_l2MessagingBlocksOffsets.length % 2 != 0) {\n      revert BytesLengthNotMultipleOfTwo(_l2MessagingBlocksOffsets.length);\n    }\n\n    uint256 l2BlockOffset;\n    unchecked {\n      for (uint256 i; i < _l2MessagingBlocksOffsets.length; ) {\n        assembly {\n          l2BlockOffset := shr(240, calldataload(add(_l2MessagingBlocksOffsets.offset, i)))\n        }\n        emit L2MessagingBlockAnchored(_currentL2BlockNumber + l2BlockOffset);\n        i += 2;\n      }\n    }\n  }\n\n  /**\n   * @notice Check if the L2->L1 message is claimed or not.\n   * @param _messageNumber The message number on L2.\n   */\n  function isMessageClaimed(uint256 _messageNumber) external view returns (bool) {\n    return _messageClaimedBitMap.get(_messageNumber);\n  }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.max', 'start_line': 2923, 'end_line': 2925, 'offset_start': 109110, 'offset_end': 109210, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.min', 'start_line': 2930, 'end_line': 2932, 'offset_start': 109289, 'offset_end': 109389, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.average', 'start_line': 2938, 'end_line': 2942, 'offset_start': 109527, 'offset_end': 109756, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.abs', 'start_line': 2947, 'end_line': 2952, 'offset_start': 109846, 'offset_end': 110058, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'PauseManager._requireTypeAndGeneralNotPaused', 'start_line': 3014, 'end_line': 3024, 'offset_start': 112254, 'offset_end': 112605, 'content': 'function _requireTypeAndGeneralNotPaused(uint8 _pauseType) internal view virtual {\n    uint256 pauseBitMap = _pauseTypeStatusesBitMap;\n\n    if (pauseBitMap & (1 << uint256(_pauseType)) != 0) {\n      revert IsPaused(_pauseType);\n    }\n\n    if (pauseBitMap & (1 << uint256(GENERAL_PAUSE_TYPE)) != 0) {\n      revert IsPaused(GENERAL_PAUSE_TYPE);\n    }\n  }', 'contract_name': 'PauseManager', 'contract_code': '{\n  bytes32 public constant PAUSE_MANAGER_ROLE = keccak256("PAUSE_MANAGER_ROLE");\n\n  uint8 public constant GENERAL_PAUSE_TYPE = 1;\n  uint8 public constant L1_L2_PAUSE_TYPE = 2;\n  uint8 public constant L2_L1_PAUSE_TYPE = 3;\n  uint8 public constant PROVING_SYSTEM_PAUSE_TYPE = 4;\n\n  // @dev DEPRECATED. USE _pauseTypeStatusesBitMap INSTEAD\n  mapping(bytes32 pauseType => bool pauseStatus) public pauseTypeStatuses;\n\n  uint256 private _pauseTypeStatusesBitMap;\n\n  /// @dev Total contract storage is 11 slots with the gap below.\n  /// @dev Keep 9 free storage slots for future implementation updates to avoid storage collision.\n  /// @dev Note: This was reduced previously to cater for new functionality.\n  uint256[9] private __gap;\n\n  /**\n   * @dev Modifier to make a function callable only when the specific and general types are not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeAndGeneralNotPaused(uint8 _pauseType) {\n    _requireTypeAndGeneralNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the type is not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeNotPaused(uint8 _pauseType) {\n    _requireTypeNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Throws if the specific or general types are paused.\n   * @dev Checks the specific and general pause types.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeAndGeneralNotPaused(uint8 _pauseType) internal view virtual {\n    uint256 pauseBitMap = _pauseTypeStatusesBitMap;\n\n    if (pauseBitMap & (1 << uint256(_pauseType)) != 0) {\n      revert IsPaused(_pauseType);\n    }\n\n    if (pauseBitMap & (1 << uint256(GENERAL_PAUSE_TYPE)) != 0) {\n      revert IsPaused(GENERAL_PAUSE_TYPE);\n    }\n  }\n\n  /**\n   * @dev Throws if the type is paused.\n   * @dev Checks the specific pause type.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeNotPaused(uint8 _pauseType) internal view virtual {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n  }\n\n  /**\n   * @notice Pauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function pauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap |= 1 << uint256(_pauseType);\n    emit Paused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Unpauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function unPauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (!isPaused(_pauseType)) {\n      revert IsNotPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap &= ~(1 << uint256(_pauseType));\n    emit UnPaused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Check if a pause type is enabled.\n   * @param _pauseType The pause type value.\n   * @return boolean True if the pause type if enabled, false otherwise.\n   */\n  function isPaused(uint8 _pauseType) public view returns (bool) {\n    return (_pauseTypeStatusesBitMap & (1 << uint256(_pauseType))) != 0;\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'PauseManager._requireTypeNotPaused', 'start_line': 3031, 'end_line': 3035, 'offset_start': 112763, 'offset_end': 112911, 'content': 'function _requireTypeNotPaused(uint8 _pauseType) internal view virtual {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n  }', 'contract_name': 'PauseManager', 'contract_code': '{\n  bytes32 public constant PAUSE_MANAGER_ROLE = keccak256("PAUSE_MANAGER_ROLE");\n\n  uint8 public constant GENERAL_PAUSE_TYPE = 1;\n  uint8 public constant L1_L2_PAUSE_TYPE = 2;\n  uint8 public constant L2_L1_PAUSE_TYPE = 3;\n  uint8 public constant PROVING_SYSTEM_PAUSE_TYPE = 4;\n\n  // @dev DEPRECATED. USE _pauseTypeStatusesBitMap INSTEAD\n  mapping(bytes32 pauseType => bool pauseStatus) public pauseTypeStatuses;\n\n  uint256 private _pauseTypeStatusesBitMap;\n\n  /// @dev Total contract storage is 11 slots with the gap below.\n  /// @dev Keep 9 free storage slots for future implementation updates to avoid storage collision.\n  /// @dev Note: This was reduced previously to cater for new functionality.\n  uint256[9] private __gap;\n\n  /**\n   * @dev Modifier to make a function callable only when the specific and general types are not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeAndGeneralNotPaused(uint8 _pauseType) {\n    _requireTypeAndGeneralNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the type is not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeNotPaused(uint8 _pauseType) {\n    _requireTypeNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Throws if the specific or general types are paused.\n   * @dev Checks the specific and general pause types.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeAndGeneralNotPaused(uint8 _pauseType) internal view virtual {\n    uint256 pauseBitMap = _pauseTypeStatusesBitMap;\n\n    if (pauseBitMap & (1 << uint256(_pauseType)) != 0) {\n      revert IsPaused(_pauseType);\n    }\n\n    if (pauseBitMap & (1 << uint256(GENERAL_PAUSE_TYPE)) != 0) {\n      revert IsPaused(GENERAL_PAUSE_TYPE);\n    }\n  }\n\n  /**\n   * @dev Throws if the type is paused.\n   * @dev Checks the specific pause type.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeNotPaused(uint8 _pauseType) internal view virtual {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n  }\n\n  /**\n   * @notice Pauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function pauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap |= 1 << uint256(_pauseType);\n    emit Paused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Unpauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function unPauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (!isPaused(_pauseType)) {\n      revert IsNotPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap &= ~(1 << uint256(_pauseType));\n    emit UnPaused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Check if a pause type is enabled.\n   * @param _pauseType The pause type value.\n   * @return boolean True if the pause type if enabled, false otherwise.\n   */\n  function isPaused(uint8 _pauseType) public view returns (bool) {\n    return (_pauseTypeStatusesBitMap & (1 << uint256(_pauseType))) != 0;\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'PauseManager.pauseByType', 'start_line': 3042, 'end_line': 3049, 'offset_start': 113064, 'offset_end': 113320, 'content': 'function pauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap |= 1 << uint256(_pauseType);\n    emit Paused(_msgSender(), _pauseType);\n  }', 'contract_name': 'PauseManager', 'contract_code': '{\n  bytes32 public constant PAUSE_MANAGER_ROLE = keccak256("PAUSE_MANAGER_ROLE");\n\n  uint8 public constant GENERAL_PAUSE_TYPE = 1;\n  uint8 public constant L1_L2_PAUSE_TYPE = 2;\n  uint8 public constant L2_L1_PAUSE_TYPE = 3;\n  uint8 public constant PROVING_SYSTEM_PAUSE_TYPE = 4;\n\n  // @dev DEPRECATED. USE _pauseTypeStatusesBitMap INSTEAD\n  mapping(bytes32 pauseType => bool pauseStatus) public pauseTypeStatuses;\n\n  uint256 private _pauseTypeStatusesBitMap;\n\n  /// @dev Total contract storage is 11 slots with the gap below.\n  /// @dev Keep 9 free storage slots for future implementation updates to avoid storage collision.\n  /// @dev Note: This was reduced previously to cater for new functionality.\n  uint256[9] private __gap;\n\n  /**\n   * @dev Modifier to make a function callable only when the specific and general types are not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeAndGeneralNotPaused(uint8 _pauseType) {\n    _requireTypeAndGeneralNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the type is not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeNotPaused(uint8 _pauseType) {\n    _requireTypeNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Throws if the specific or general types are paused.\n   * @dev Checks the specific and general pause types.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeAndGeneralNotPaused(uint8 _pauseType) internal view virtual {\n    uint256 pauseBitMap = _pauseTypeStatusesBitMap;\n\n    if (pauseBitMap & (1 << uint256(_pauseType)) != 0) {\n      revert IsPaused(_pauseType);\n    }\n\n    if (pauseBitMap & (1 << uint256(GENERAL_PAUSE_TYPE)) != 0) {\n      revert IsPaused(GENERAL_PAUSE_TYPE);\n    }\n  }\n\n  /**\n   * @dev Throws if the type is paused.\n   * @dev Checks the specific pause type.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeNotPaused(uint8 _pauseType) internal view virtual {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n  }\n\n  /**\n   * @notice Pauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function pauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap |= 1 << uint256(_pauseType);\n    emit Paused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Unpauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function unPauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (!isPaused(_pauseType)) {\n      revert IsNotPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap &= ~(1 << uint256(_pauseType));\n    emit UnPaused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Check if a pause type is enabled.\n   * @param _pauseType The pause type value.\n   * @return boolean True if the pause type if enabled, false otherwise.\n   */\n  function isPaused(uint8 _pauseType) public view returns (bool) {\n    return (_pauseTypeStatusesBitMap & (1 << uint256(_pauseType))) != 0;\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'PauseManager.unPauseByType', 'start_line': 3056, 'end_line': 3063, 'offset_start': 113475, 'offset_end': 113742, 'content': 'function unPauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (!isPaused(_pauseType)) {\n      revert IsNotPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap &= ~(1 << uint256(_pauseType));\n    emit UnPaused(_msgSender(), _pauseType);\n  }', 'contract_name': 'PauseManager', 'contract_code': '{\n  bytes32 public constant PAUSE_MANAGER_ROLE = keccak256("PAUSE_MANAGER_ROLE");\n\n  uint8 public constant GENERAL_PAUSE_TYPE = 1;\n  uint8 public constant L1_L2_PAUSE_TYPE = 2;\n  uint8 public constant L2_L1_PAUSE_TYPE = 3;\n  uint8 public constant PROVING_SYSTEM_PAUSE_TYPE = 4;\n\n  // @dev DEPRECATED. USE _pauseTypeStatusesBitMap INSTEAD\n  mapping(bytes32 pauseType => bool pauseStatus) public pauseTypeStatuses;\n\n  uint256 private _pauseTypeStatusesBitMap;\n\n  /// @dev Total contract storage is 11 slots with the gap below.\n  /// @dev Keep 9 free storage slots for future implementation updates to avoid storage collision.\n  /// @dev Note: This was reduced previously to cater for new functionality.\n  uint256[9] private __gap;\n\n  /**\n   * @dev Modifier to make a function callable only when the specific and general types are not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeAndGeneralNotPaused(uint8 _pauseType) {\n    _requireTypeAndGeneralNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the type is not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeNotPaused(uint8 _pauseType) {\n    _requireTypeNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Throws if the specific or general types are paused.\n   * @dev Checks the specific and general pause types.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeAndGeneralNotPaused(uint8 _pauseType) internal view virtual {\n    uint256 pauseBitMap = _pauseTypeStatusesBitMap;\n\n    if (pauseBitMap & (1 << uint256(_pauseType)) != 0) {\n      revert IsPaused(_pauseType);\n    }\n\n    if (pauseBitMap & (1 << uint256(GENERAL_PAUSE_TYPE)) != 0) {\n      revert IsPaused(GENERAL_PAUSE_TYPE);\n    }\n  }\n\n  /**\n   * @dev Throws if the type is paused.\n   * @dev Checks the specific pause type.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeNotPaused(uint8 _pauseType) internal view virtual {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n  }\n\n  /**\n   * @notice Pauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function pauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap |= 1 << uint256(_pauseType);\n    emit Paused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Unpauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function unPauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (!isPaused(_pauseType)) {\n      revert IsNotPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap &= ~(1 << uint256(_pauseType));\n    emit UnPaused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Check if a pause type is enabled.\n   * @param _pauseType The pause type value.\n   * @return boolean True if the pause type if enabled, false otherwise.\n   */\n  function isPaused(uint8 _pauseType) public view returns (bool) {\n    return (_pauseTypeStatusesBitMap & (1 << uint256(_pauseType))) != 0;\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'PauseManager.isPaused', 'start_line': 3070, 'end_line': 3072, 'offset_start': 113924, 'offset_end': 114064, 'content': 'function isPaused(uint8 _pauseType) public view returns (bool) {\n    return (_pauseTypeStatusesBitMap & (1 << uint256(_pauseType))) != 0;\n  }', 'contract_name': 'PauseManager', 'contract_code': '{\n  bytes32 public constant PAUSE_MANAGER_ROLE = keccak256("PAUSE_MANAGER_ROLE");\n\n  uint8 public constant GENERAL_PAUSE_TYPE = 1;\n  uint8 public constant L1_L2_PAUSE_TYPE = 2;\n  uint8 public constant L2_L1_PAUSE_TYPE = 3;\n  uint8 public constant PROVING_SYSTEM_PAUSE_TYPE = 4;\n\n  // @dev DEPRECATED. USE _pauseTypeStatusesBitMap INSTEAD\n  mapping(bytes32 pauseType => bool pauseStatus) public pauseTypeStatuses;\n\n  uint256 private _pauseTypeStatusesBitMap;\n\n  /// @dev Total contract storage is 11 slots with the gap below.\n  /// @dev Keep 9 free storage slots for future implementation updates to avoid storage collision.\n  /// @dev Note: This was reduced previously to cater for new functionality.\n  uint256[9] private __gap;\n\n  /**\n   * @dev Modifier to make a function callable only when the specific and general types are not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeAndGeneralNotPaused(uint8 _pauseType) {\n    _requireTypeAndGeneralNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the type is not paused.\n   * @param _pauseType The pause type value being checked.\n   * Requirements:\n   *\n   * - The type must not be paused.\n   */\n  modifier whenTypeNotPaused(uint8 _pauseType) {\n    _requireTypeNotPaused(_pauseType);\n    _;\n  }\n\n  /**\n   * @dev Throws if the specific or general types are paused.\n   * @dev Checks the specific and general pause types.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeAndGeneralNotPaused(uint8 _pauseType) internal view virtual {\n    uint256 pauseBitMap = _pauseTypeStatusesBitMap;\n\n    if (pauseBitMap & (1 << uint256(_pauseType)) != 0) {\n      revert IsPaused(_pauseType);\n    }\n\n    if (pauseBitMap & (1 << uint256(GENERAL_PAUSE_TYPE)) != 0) {\n      revert IsPaused(GENERAL_PAUSE_TYPE);\n    }\n  }\n\n  /**\n   * @dev Throws if the type is paused.\n   * @dev Checks the specific pause type.\n   * @param _pauseType The pause type value being checked.\n   */\n  function _requireTypeNotPaused(uint8 _pauseType) internal view virtual {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n  }\n\n  /**\n   * @notice Pauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function pauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (isPaused(_pauseType)) {\n      revert IsPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap |= 1 << uint256(_pauseType);\n    emit Paused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Unpauses functionality by specific type.\n   * @dev Requires PAUSE_MANAGER_ROLE.\n   * @param _pauseType The pause type value.\n   */\n  function unPauseByType(uint8 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    if (!isPaused(_pauseType)) {\n      revert IsNotPaused(_pauseType);\n    }\n\n    _pauseTypeStatusesBitMap &= ~(1 << uint256(_pauseType));\n    emit UnPaused(_msgSender(), _pauseType);\n  }\n\n  /**\n   * @notice Check if a pause type is enabled.\n   * @param _pauseType The pause type value.\n   * @return boolean True if the pause type if enabled, false otherwise.\n   */\n  function isPaused(uint8 _pauseType) public view returns (bool) {\n    return (_pauseTypeStatusesBitMap & (1 << uint256(_pauseType))) != 0;\n  }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'BitMaps.get', 'start_line': 3091, 'end_line': 3095, 'offset_start': 114637, 'offset_end': 114853, 'content': 'function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }', 'contract_name': 'BitMaps', 'contract_code': '{\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'BitMaps.setTo', 'start_line': 3100, 'end_line': 3106, 'offset_start': 114936, 'offset_end': 115130, 'content': 'function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }', 'contract_name': 'BitMaps', 'contract_code': '{\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'BitMaps.set', 'start_line': 3111, 'end_line': 3115, 'offset_start': 115190, 'offset_end': 115375, 'content': 'function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }', 'contract_name': 'BitMaps', 'contract_code': '{\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'BitMaps.unset', 'start_line': 3120, 'end_line': 3124, 'offset_start': 115437, 'offset_end': 115625, 'content': 'function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }', 'contract_name': 'BitMaps', 'contract_code': '{\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165Upgradeable.supportsInterface', 'start_line': 3205, 'end_line': 3205, 'offset_start': 118124, 'offset_end': 118199, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165Upgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 3352, 'end_line': 3358, 'offset_start': 124143, 'offset_end': 124422, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 3363, 'end_line': 3365, 'offset_start': 124533, 'offset_end': 124632, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 3370, 'end_line': 3372, 'offset_start': 124749, 'offset_end': 124841, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageManager.isMessageClaimed', 'start_line': 3426, 'end_line': 3426, 'offset_start': 126916, 'offset_end': 126994, 'content': 'function isMessageClaimed(uint256 _messageNumber) external view returns (bool);', 'contract_name': 'IL1MessageManager', 'contract_code': '{\n  /**\n   * @notice Emitted when a new message is sent and the rolling hash updated.\n   * @param messageNumber The unique indexed message number for the message.\n   * @param rollingHash The indexed rolling hash computed for the current message number.\n   * @param messageHash The indexed hash of the message parameters.\n   */\n  event RollingHashUpdated(uint256 indexed messageNumber, bytes32 indexed rollingHash, bytes32 indexed messageHash);\n\n  /**\n   * @notice Emitted when the L2 merkle root has been anchored on L1.\n   * @param l2MerkleRoot The indexed L2 Merkle root that has been anchored on L1 Ethereum.\n   * @param treeDepth The indexed tree depth of the Merkle root.\n   * @dev There may be more than one of these in a finalization depending on the amount of L2->L1 messages in the finalization.\n   */\n  event L2MerkleRootAdded(bytes32 indexed l2MerkleRoot, uint256 indexed treeDepth);\n\n  /**\n   * @notice Emitted when the l2 block contains L2 messages during finalization.\n   * @param l2Block The indexed L2 block containing L2 to L1 messages.\n   * @dev This is used externally in the logic for determining which messages belong to which Merkle root when claiming.\n   */\n  event L2MessagingBlockAnchored(uint256 indexed l2Block);\n\n  /**\n   * @dev Thrown when the message has already been claimed.\n   */\n  error MessageAlreadyClaimed(uint256 messageIndex);\n\n  /**\n   * @dev Thrown when the L2 merkle root has already been anchored on L1.\n   */\n  error L2MerkleRootAlreadyAnchored(bytes32 merkleRoot);\n\n  /**\n   * @dev Thrown when the L2 messaging blocks offsets bytes length is not a multiple of 2.\n   */\n  error BytesLengthNotMultipleOfTwo(uint256 bytesLength);\n\n  /**\n   * @notice Check if the L2->L1 message is claimed or not.\n   * @param _messageNumber The message number on L2.\n   */\n  function isMessageClaimed(uint256 _messageNumber) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'SparseMerkleTreeVerifier._verifyMerkleProof', 'start_line': 3445, 'end_line': 3461, 'offset_start': 127473, 'offset_end': 127938, 'content': 'function _verifyMerkleProof(\n    bytes32 _leafHash,\n    bytes32[] calldata _proof,\n    uint32 _leafIndex,\n    bytes32 _root\n  ) internal pure returns (bool) {\n    bytes32 node = _leafHash;\n\n    for (uint256 height; height < _proof.length; ++height) {\n      if (((_leafIndex >> height) & 1) == 1) {\n        node = _efficientKeccak(_proof[height], node);\n      } else {\n        node = _efficientKeccak(node, _proof[height]);\n      }\n    }\n    return node == _root;\n  }', 'contract_name': 'SparseMerkleTreeVerifier', 'contract_code': '{\n  /**\n   * @notice Verify merkle proof\n   * @param _leafHash Leaf hash.\n   * @param _proof Sparse merkle tree proof.\n   * @param _leafIndex Index of the leaf.\n   * @param _root Merkle root.\n   */\n  function _verifyMerkleProof(\n    bytes32 _leafHash,\n    bytes32[] calldata _proof,\n    uint32 _leafIndex,\n    bytes32 _root\n  ) internal pure returns (bool) {\n    bytes32 node = _leafHash;\n\n    for (uint256 height; height < _proof.length; ++height) {\n      if (((_leafIndex >> height) & 1) == 1) {\n        node = _efficientKeccak(_proof[height], node);\n      } else {\n        node = _efficientKeccak(node, _proof[height]);\n      }\n    }\n    return node == _root;\n  }\n\n  /**\n   * @notice Performs a gas optimized keccak hash\n   * @param _left Left value.\n   * @param _right Right value.\n   */\n  function _efficientKeccak(bytes32 _left, bytes32 _right) internal pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, _left)\n      mstore(0x20, _right)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'SparseMerkleTreeVerifier._efficientKeccak', 'start_line': 3468, 'end_line': 3474, 'offset_start': 128067, 'offset_end': 128277, 'content': 'function _efficientKeccak(bytes32 _left, bytes32 _right) internal pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, _left)\n      mstore(0x20, _right)\n      value := keccak256(0x00, 0x40)\n    }\n  }', 'contract_name': 'SparseMerkleTreeVerifier', 'contract_code': '{\n  /**\n   * @notice Verify merkle proof\n   * @param _leafHash Leaf hash.\n   * @param _proof Sparse merkle tree proof.\n   * @param _leafIndex Index of the leaf.\n   * @param _root Merkle root.\n   */\n  function _verifyMerkleProof(\n    bytes32 _leafHash,\n    bytes32[] calldata _proof,\n    uint32 _leafIndex,\n    bytes32 _root\n  ) internal pure returns (bool) {\n    bytes32 node = _leafHash;\n\n    for (uint256 height; height < _proof.length; ++height) {\n      if (((_leafIndex >> height) & 1) == 1) {\n        node = _efficientKeccak(_proof[height], node);\n      } else {\n        node = _efficientKeccak(node, _proof[height]);\n      }\n    }\n    return node == _root;\n  }\n\n  /**\n   * @notice Performs a gas optimized keccak hash\n   * @param _left Left value.\n   * @param _right Right value.\n   */\n  function _efficientKeccak(bytes32 _left, bytes32 _right) internal pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, _left)\n      mstore(0x20, _right)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.max', 'start_line': 3495, 'end_line': 3497, 'offset_start': 128706, 'offset_end': 128809, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.min', 'start_line': 3502, 'end_line': 3504, 'offset_start': 128881, 'offset_end': 128984, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.average', 'start_line': 3510, 'end_line': 3513, 'offset_start': 129098, 'offset_end': 129250, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.ceilDiv', 'start_line': 3521, 'end_line': 3524, 'offset_start': 129450, 'offset_end': 129643, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 3531, 'end_line': 3610, 'offset_start': 129960, 'offset_end': 134172, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 3615, 'end_line': 3621, 'offset_start': 134305, 'offset_end': 134603, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 3628, 'end_line': 3659, 'offset_start': 134823, 'offset_end': 136460, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 3664, 'end_line': 3669, 'offset_start': 136561, 'offset_end': 136797, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 3675, 'end_line': 3711, 'offset_start': 136922, 'offset_end': 137904, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 3717, 'end_line': 3722, 'offset_start': 138058, 'offset_end': 138302, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 3728, 'end_line': 3760, 'offset_start': 138428, 'offset_end': 139343, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 3766, 'end_line': 3771, 'offset_start': 139498, 'offset_end': 139745, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 3779, 'end_line': 3803, 'offset_start': 139997, 'offset_end': 140659, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 3809, 'end_line': 3814, 'offset_start': 140815, 'offset_end': 141070, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xd19d4b5d358258f05d7b411e21a1460d11b0876f/0xd19d4b5d358258f05d7b411e21a1460d11b0876f.sol'}
