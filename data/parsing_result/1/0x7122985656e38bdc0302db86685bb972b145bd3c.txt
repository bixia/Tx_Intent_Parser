{'type': 'FunctionDefinition', 'name': 'Stone.tor', 'start_line': 31, 'end_line': 38, 'offset_start': 828, 'offset_end': 1039, 'content': 'constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.mint', 'start_line': 45, 'end_line': 47, 'offset_start': 1137, 'offset_end': 1236, 'content': 'function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.burn', 'start_line': 49, 'end_line': 51, 'offset_start': 1243, 'offset_end': 1346, 'content': 'function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.sendFrom', 'start_line': 53, 'end_line': 84, 'offset_start': 1353, 'offset_end': 2184, 'content': 'function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.updatePrice', 'start_line': 86, 'end_line': 117, 'offset_start': 2191, 'offset_end': 2920, 'content': 'function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.setEnableFor', 'start_line': 119, 'end_line': 151, 'offset_start': 2927, 'offset_end': 3704, 'content': 'function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.setCapFor', 'start_line': 153, 'end_line': 181, 'offset_start': 3711, 'offset_end': 4407, 'content': 'function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.tokenPrice', 'start_line': 183, 'end_line': 185, 'offset_start': 4414, 'offset_end': 4521, 'content': 'function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Stone.getQuota', 'start_line': 187, 'end_line': 192, 'offset_start': 4528, 'offset_end': 4731, 'content': 'function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }', 'contract_name': 'Stone', 'contract_code': '{\n    uint256 public constant DAY_INTERVAL = 24 * 60 * 60;\n\n    address public minter;\n\n    uint16 public constant PT_FEED = 1;\n    uint16 public constant PT_SET_ENABLE = 2;\n    uint16 public constant PT_SET_CAP = 3;\n\n    uint256 public cap;\n    bool public enable = true;\n\n    mapping(uint256 => uint256) public quota;\n\n    event FeedToChain(\n        uint16 indexed dstChainId,\n        address indexed from,\n        bytes toAddress,\n        uint price\n    );\n    event SetCapFor(uint16 indexed dstChainId, bytes toAddress, uint cap);\n    event SetEnableFor(uint16 indexed dstChainId, bytes toAddress, bool flag);\n\n    constructor(\n        address _minter,\n        address _layerZeroEndpoint,\n        uint256 _cap\n    ) BasedOFT("StakeStone Ether", "STONE", _layerZeroEndpoint) {\n        minter = _minter;\n        cap = _cap;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, "NM");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyMinter {\n        _burn(_from, _amount);\n    }\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) public payable override(IOFTCore, OFTCore) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        uint256 day = block.timestamp / DAY_INTERVAL;\n        require(_amount + quota[day] <= cap, "Exceed cap");\n\n        quota[day] = quota[day] + _amount;\n\n        super.sendFrom(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _refundAddress,\n            _zroPaymentAddress,\n            _adapterParams\n        );\n    }\n\n    function updatePrice(\n        uint16 _dstChainId,\n        bytes memory _toAddress\n    ) external payable returns (uint256 price) {\n        require(enable, "invalid");\n\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        require(id != _dstChainId, "same chain");\n\n        price = tokenPrice();\n\n        bytes memory lzPayload = abi.encode(\n            PT_FEED,\n            _toAddress,\n            price,\n            block.timestamp\n        );\n\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit FeedToChain(_dstChainId, msg.sender, _toAddress, price);\n    }\n\n    function setEnableFor(\n        uint16 _dstChainId,\n        bool _flag,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            enable = _flag;\n\n            emit SetEnableFor(\n                _dstChainId,\n                abi.encodePacked(address(this)),\n                enable\n            );\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_ENABLE, _toAddress, _flag);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetEnableFor(_dstChainId, _toAddress, _flag);\n    }\n\n    function setCapFor(\n        uint16 _dstChainId,\n        uint256 _cap,\n        bytes memory _toAddress\n    ) external payable onlyOwner {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n\n        if (_dstChainId == id) {\n            cap = _cap;\n\n            emit SetCapFor(_dstChainId, abi.encodePacked(address(this)), cap);\n            return;\n        }\n\n        bytes memory lzPayload = abi.encode(PT_SET_CAP, _toAddress, _cap);\n        _lzSend(\n            _dstChainId,\n            lzPayload,\n            payable(msg.sender),\n            address(0),\n            bytes(""),\n            msg.value\n        );\n\n        emit SetCapFor(_dstChainId, _toAddress, _cap);\n    }\n\n    function tokenPrice() public returns (uint256 price) {\n        price = Minter(minter).getTokenPrice();\n    }\n\n    function getQuota() external view returns (uint256) {\n        uint256 amount = quota[block.timestamp / DAY_INTERVAL];\n        if (cap > amount && enable) {\n            return cap - amount;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 221, 'end_line': 221, 'offset_start': 5510, 'offset_end': 5564, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 226, 'end_line': 226, 'offset_start': 5648, 'offset_end': 5715, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 235, 'end_line': 235, 'offset_start': 5929, 'offset_end': 5998, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 244, 'end_line': 244, 'offset_start': 6274, 'offset_end': 6356, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 260, 'end_line': 260, 'offset_start': 7010, 'offset_end': 7083, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 271, 'end_line': 271, 'offset_start': 7382, 'offset_end': 7469, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'AssetsVault.tor', 'start_line': 291, 'end_line': 298, 'offset_start': 7896, 'offset_end': 8179, 'content': 'constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }', 'contract_name': 'AssetsVault', 'contract_code': '{\n    address public stoneVault;\n    address public strategyController;\n\n    modifier onlyPermit() {\n        require(\n            stoneVault == msg.sender || strategyController == msg.sender,\n            "not permit"\n        );\n        _;\n    }\n\n    constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }\n\n    function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }\n\n    function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }\n\n    function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'AssetsVault.deposit', 'start_line': 300, 'end_line': 302, 'offset_start': 8186, 'offset_end': 8274, 'content': 'function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }', 'contract_name': 'AssetsVault', 'contract_code': '{\n    address public stoneVault;\n    address public strategyController;\n\n    modifier onlyPermit() {\n        require(\n            stoneVault == msg.sender || strategyController == msg.sender,\n            "not permit"\n        );\n        _;\n    }\n\n    constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }\n\n    function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }\n\n    function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }\n\n    function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'AssetsVault.withdraw', 'start_line': 304, 'end_line': 306, 'offset_start': 8281, 'offset_end': 8409, 'content': 'function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }', 'contract_name': 'AssetsVault', 'contract_code': '{\n    address public stoneVault;\n    address public strategyController;\n\n    modifier onlyPermit() {\n        require(\n            stoneVault == msg.sender || strategyController == msg.sender,\n            "not permit"\n        );\n        _;\n    }\n\n    constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }\n\n    function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }\n\n    function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }\n\n    function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'AssetsVault.setNewVault', 'start_line': 308, 'end_line': 310, 'offset_start': 8416, 'offset_end': 8508, 'content': 'function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }', 'contract_name': 'AssetsVault', 'contract_code': '{\n    address public stoneVault;\n    address public strategyController;\n\n    modifier onlyPermit() {\n        require(\n            stoneVault == msg.sender || strategyController == msg.sender,\n            "not permit"\n        );\n        _;\n    }\n\n    constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }\n\n    function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }\n\n    function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }\n\n    function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'AssetsVault.getBalance', 'start_line': 312, 'end_line': 314, 'offset_start': 8515, 'offset_end': 8622, 'content': 'function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }', 'contract_name': 'AssetsVault', 'contract_code': '{\n    address public stoneVault;\n    address public strategyController;\n\n    modifier onlyPermit() {\n        require(\n            stoneVault == msg.sender || strategyController == msg.sender,\n            "not permit"\n        );\n        _;\n    }\n\n    constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }\n\n    function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }\n\n    function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }\n\n    function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'AssetsVault.', 'start_line': 316, 'end_line': 316, 'offset_start': 8629, 'offset_end': 8657, 'content': 'receive() external payable {}', 'contract_name': 'AssetsVault', 'contract_code': '{\n    address public stoneVault;\n    address public strategyController;\n\n    modifier onlyPermit() {\n        require(\n            stoneVault == msg.sender || strategyController == msg.sender,\n            "not permit"\n        );\n        _;\n    }\n\n    constructor(address _stoneVault, address _strategyController) {\n        require(\n            _stoneVault != address(0) && _strategyController != address(0),\n            "ZERO ADDRESS"\n        );\n        stoneVault = _stoneVault;\n        strategyController = _strategyController;\n    }\n\n    function deposit() external payable {\n        require(msg.value != 0, "too small");\n    }\n\n    function withdraw(address _to, uint256 _amount) external onlyPermit {\n        TransferHelper.safeTransferETH(_to, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyPermit {\n        stoneVault = _vault;\n    }\n\n    function getBalance() external view returns (uint256 amount) {\n        amount = address(this).balance;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 335, 'end_line': 337, 'offset_start': 9302, 'offset_end': 9397, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 339, 'end_line': 341, 'offset_start': 9404, 'offset_end': 9502, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFT.tor', 'start_line': 355, 'end_line': 355, 'offset_start': 9817, 'offset_end': 9938, 'content': 'constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}', 'contract_name': 'OFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFT.supportsInterface', 'start_line': 357, 'end_line': 359, 'offset_start': 9945, 'offset_end': 10197, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'OFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFT.token', 'start_line': 361, 'end_line': 363, 'offset_start': 10204, 'offset_end': 10304, 'content': 'function token() public view virtual override returns (address) {\n        return address(this);\n    }', 'contract_name': 'OFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFT.circulatingSupply', 'start_line': 365, 'end_line': 367, 'offset_start': 10311, 'offset_end': 10420, 'content': 'function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }', 'contract_name': 'OFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFT._debitFrom', 'start_line': 369, 'end_line': 374, 'offset_start': 10427, 'offset_end': 10711, 'content': 'function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }', 'contract_name': 'OFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFT._creditTo', 'start_line': 376, 'end_line': 379, 'offset_start': 10718, 'offset_end': 10885, 'content': 'function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }', 'contract_name': 'OFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'NonblockingLzApp.tor', 'start_line': 397, 'end_line': 397, 'offset_start': 11451, 'offset_end': 11500, 'content': 'constructor(address _endpoint) LzApp(_endpoint) {}', 'contract_name': 'NonblockingLzApp', 'contract_code': '{\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'NonblockingLzApp._blockingLzReceive', 'start_line': 405, 'end_line': 411, 'offset_start': 11870, 'offset_end': 12377, 'content': 'function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }', 'contract_name': 'NonblockingLzApp', 'contract_code': '{\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'NonblockingLzApp._storeFailedMessage', 'start_line': 413, 'end_line': 416, 'offset_start': 12384, 'offset_end': 12703, 'content': 'function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }', 'contract_name': 'NonblockingLzApp', 'contract_code': '{\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'NonblockingLzApp.nonblockingLzReceive', 'start_line': 418, 'end_line': 422, 'offset_start': 12710, 'offset_end': 13051, 'content': 'function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }', 'contract_name': 'NonblockingLzApp', 'contract_code': '{\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'NonblockingLzApp._nonblockingLzReceive', 'start_line': 425, 'end_line': 425, 'offset_start': 13095, 'offset_end': 13226, 'content': 'function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;', 'contract_name': 'NonblockingLzApp', 'contract_code': '{\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'NonblockingLzApp.retryMessage', 'start_line': 427, 'end_line': 437, 'offset_start': 13233, 'offset_end': 13989, 'content': 'function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }', 'contract_name': 'NonblockingLzApp', 'contract_code': '{\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), "NonblockingLzApp: caller must be LzApp");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), "NonblockingLzApp: no stored message");\n        require(keccak256(_payload) == payloadHash, "NonblockingLzApp: invalid payload");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.concat', 'start_line': 452, 'end_line': 528, 'offset_start': 14385, 'offset_end': 17219, 'content': 'function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.concatStorage', 'start_line': 530, 'end_line': 665, 'offset_start': 17226, 'offset_end': 22850, 'content': "function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don't need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let's prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }", 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.slice', 'start_line': 667, 'end_line': 734, 'offset_start': 22857, 'offset_end': 25568, 'content': 'function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toAddress', 'start_line': 736, 'end_line': 745, 'offset_start': 25575, 'offset_end': 25928, 'content': 'function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint8', 'start_line': 747, 'end_line': 756, 'offset_start': 25935, 'offset_end': 26236, 'content': 'function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint16', 'start_line': 758, 'end_line': 767, 'offset_start': 26243, 'offset_end': 26547, 'content': 'function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint32', 'start_line': 769, 'end_line': 778, 'offset_start': 26554, 'offset_end': 26858, 'content': 'function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint64', 'start_line': 780, 'end_line': 789, 'offset_start': 26865, 'offset_end': 27169, 'content': 'function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint96', 'start_line': 791, 'end_line': 800, 'offset_start': 27176, 'offset_end': 27481, 'content': 'function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint128', 'start_line': 802, 'end_line': 811, 'offset_start': 27488, 'offset_end': 27798, 'content': 'function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint256', 'start_line': 813, 'end_line': 822, 'offset_start': 27805, 'offset_end': 28115, 'content': 'function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toBytes32', 'start_line': 824, 'end_line': 833, 'offset_start': 28122, 'offset_end': 28441, 'content': 'function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.equal', 'start_line': 835, 'end_line': 876, 'offset_start': 28448, 'offset_end': 29831, 'content': "function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }", 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.equalStorage', 'start_line': 878, 'end_line': 948, 'offset_start': 29838, 'offset_end': 32467, 'content': "function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }", 'contract_name': 'BytesLib', 'contract_code': '{\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don\'t need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let\'s prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, "slice_overflow");\n        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don\'t care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we\'re done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin\'s length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let\'s just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there\'s\n            //  no said feature for inline assembly loops\n            // cb = 1 - don\'t breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don\'t match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let\'s prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there\'s\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don\'t breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.name', 'start_line': 967, 'end_line': 967, 'offset_start': 32849, 'offset_end': 32902, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.symbol', 'start_line': 972, 'end_line': 972, 'offset_start': 32970, 'offset_end': 33025, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.decimals', 'start_line': 977, 'end_line': 977, 'offset_start': 33102, 'offset_end': 33151, 'content': 'function decimals() external view returns (uint8);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.tor', 'start_line': 1012, 'end_line': 1028, 'offset_start': 34019, 'offset_end': 34498, 'content': 'constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.onlyRebaseStrategies', 'start_line': 1030, 'end_line': 1032, 'offset_start': 34505, 'offset_end': 34575, 'content': 'function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.forceWithdraw', 'start_line': 1034, 'end_line': 1048, 'offset_start': 34582, 'offset_end': 35028, 'content': 'function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.setStrategies', 'start_line': 1050, 'end_line': 1055, 'offset_start': 35035, 'offset_end': 35207, 'content': 'function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.addStrategy', 'start_line': 1057, 'end_line': 1061, 'offset_start': 35214, 'offset_end': 35382, 'content': 'function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.rebaseStrategies', 'start_line': 1063, 'end_line': 1068, 'offset_start': 35389, 'offset_end': 35525, 'content': 'function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.destroyStrategy', 'start_line': 1070, 'end_line': 1072, 'offset_start': 35532, 'offset_end': 35638, 'content': 'function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._rebase', 'start_line': 1074, 'end_line': 1139, 'offset_start': 35645, 'offset_end': 37712, 'content': 'function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._repayToVault', 'start_line': 1141, 'end_line': 1145, 'offset_start': 37719, 'offset_end': 37891, 'content': 'function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._depositToStrategy', 'start_line': 1147, 'end_line': 1149, 'offset_start': 37898, 'offset_end': 38032, 'content': 'function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._withdrawFromStrategy', 'start_line': 1151, 'end_line': 1156, 'offset_start': 38039, 'offset_end': 38190, 'content': 'function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._forceWithdraw', 'start_line': 1158, 'end_line': 1176, 'offset_start': 38197, 'offset_end': 38755, 'content': 'function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getStrategyValue', 'start_line': 1178, 'end_line': 1182, 'offset_start': 38762, 'offset_end': 38909, 'content': 'function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getStrategyValidValue', 'start_line': 1184, 'end_line': 1188, 'offset_start': 38916, 'offset_end': 39073, 'content': 'function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getStrategyPendingValue', 'start_line': 1190, 'end_line': 1194, 'offset_start': 39080, 'offset_end': 39238, 'content': 'function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getAllStrategiesValue', 'start_line': 1196, 'end_line': 1201, 'offset_start': 39245, 'offset_end': 39478, 'content': 'function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getAllStrategyValidValue', 'start_line': 1203, 'end_line': 1208, 'offset_start': 39485, 'offset_end': 39726, 'content': 'function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getAllStrategyPendingValue', 'start_line': 1210, 'end_line': 1215, 'offset_start': 39733, 'offset_end': 39978, 'content': 'function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.getStrategies', 'start_line': 1217, 'end_line': 1232, 'offset_start': 39985, 'offset_end': 40412, 'content': 'function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._initStrategies', 'start_line': 1234, 'end_line': 1248, 'offset_start': 40419, 'offset_end': 40944, 'content': 'function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._setStrategies', 'start_line': 1250, 'end_line': 1272, 'offset_start': 40951, 'offset_end': 41753, 'content': 'function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.clearStrategy', 'start_line': 1274, 'end_line': 1276, 'offset_start': 41760, 'offset_end': 41867, 'content': 'function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._clearStrategy', 'start_line': 1278, 'end_line': 1284, 'offset_start': 41874, 'offset_end': 42051, 'content': 'function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._destoryStrategy', 'start_line': 1286, 'end_line': 1292, 'offset_start': 42058, 'offset_end': 42250, 'content': 'function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController._couldDestroyStrategy', 'start_line': 1294, 'end_line': 1299, 'offset_start': 42257, 'offset_end': 42452, 'content': 'function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.setNewVault', 'start_line': 1301, 'end_line': 1303, 'offset_start': 42459, 'offset_end': 42550, 'content': 'function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StrategyController.', 'start_line': 1305, 'end_line': 1305, 'offset_start': 42557, 'offset_end': 42585, 'content': 'receive() external payable {}', 'contract_name': 'StrategyController', 'contract_code': '{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n\n    address public stoneVault;\n    address payable public immutable assetsVault;\n\n    EnumerableSet.AddressSet private strategies;\n\n    mapping(address => uint256) public ratios;\n\n    struct StrategyDiff {\n        address strategy;\n        bool isDeposit;\n        uint256 amount;\n    }\n\n    modifier onlyVault() {\n        require(stoneVault == msg.sender, "not vault");\n        _;\n    }\n\n    constructor(\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(_assetsVault != address(0), "ZERO ADDRESS");\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        stoneVault = msg.sender;\n        assetsVault = _assetsVault;\n\n        _initStrategies(_strategies, _ratios);\n    }\n\n    function onlyRebaseStrategies() external {\n        _rebase(0, 0);\n    }\n\n    function forceWithdraw(\n        uint256 _amount\n    ) external onlyVault returns (uint256 actualAmount) {\n        uint256 balanceBeforeRepay = address(this).balance;\n\n        if (balanceBeforeRepay >= _amount) {\n            _repayToVault();\n\n            actualAmount = balanceBeforeRepay;\n        } else {\n            actualAmount =\n                _forceWithdraw(_amount - balanceBeforeRepay) +\n                balanceBeforeRepay;\n        }\n    }\n\n    function setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyVault {\n        _setStrategies(_strategies, _ratios);\n    }\n\n    function addStrategy(address _strategy) external onlyVault {\n        require(!strategies.contains(_strategy), "already exist");\n\n        strategies.add(_strategy);\n    }\n\n    function rebaseStrategies(\n        uint256 _in,\n        uint256 _out\n    ) external payable onlyVault {\n        _rebase(_in, _out);\n    }\n\n    function destroyStrategy(address _strategy) external onlyVault {\n        _destoryStrategy(_strategy);\n    }\n\n    function _rebase(uint256 _in, uint256 _out) internal {\n        require(_in == 0 || _out == 0, "only deposit or withdraw");\n\n        if (_in != 0) {\n            AssetsVault(assetsVault).withdraw(address(this), _in);\n        }\n        uint256 total = getAllStrategyValidValue();\n        if (total < _out) {\n            total = 0;\n        } else {\n            total = total + _in - _out;\n        }\n\n        uint256 length = strategies.length();\n        StrategyDiff[] memory diffs = new StrategyDiff[](length);\n        uint256 head;\n        uint256 tail = length - 1;\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n            if (ratios[strategy] == 0) {\n                _clearStrategy(strategy, true);\n                continue;\n            }\n            uint256 newPosition = (total * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n            uint256 position = getStrategyValidValue(strategy);\n\n            if (newPosition < position) {\n                diffs[head] = StrategyDiff(\n                    strategy,\n                    false,\n                    position - newPosition\n                );\n                head++;\n            } else if (newPosition > position) {\n                diffs[tail] = StrategyDiff(\n                    strategy,\n                    true,\n                    newPosition - position\n                );\n                if (tail != 0) {\n                    tail--;\n                }\n            }\n        }\n\n        length = diffs.length;\n        for (uint256 i; i < length; i++) {\n            StrategyDiff memory diff = diffs[i];\n\n            if (diff.amount == 0) {\n                continue;\n            }\n\n            if (diff.isDeposit) {\n                if (address(this).balance < diff.amount) {\n                    diff.amount = address(this).balance;\n                }\n                _depositToStrategy(diff.strategy, diff.amount);\n            } else {\n                _withdrawFromStrategy(diff.strategy, diff.amount);\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function _repayToVault() internal {\n        if (address(this).balance != 0) {\n            TransferHelper.safeTransferETH(assetsVault, address(this).balance);\n        }\n    }\n\n    function _depositToStrategy(address _strategy, uint256 _amount) internal {\n        Strategy(_strategy).deposit{value: _amount}();\n    }\n\n    function _withdrawFromStrategy(\n        address _strategy,\n        uint256 _amount\n    ) internal {\n        Strategy(_strategy).withdraw(_amount);\n    }\n\n    function _forceWithdraw(\n        uint256 _amount\n    ) internal returns (uint256 actualAmount) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            address strategy = strategies.at(i);\n\n            uint256 withAmount = (_amount * ratios[strategy]) /\n                ONE_HUNDRED_PERCENT;\n\n            if (withAmount != 0) {\n                actualAmount =\n                    Strategy(strategy).instantWithdraw(withAmount) +\n                    actualAmount;\n            }\n        }\n\n        _repayToVault();\n    }\n\n    function getStrategyValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getAllValue();\n    }\n\n    function getStrategyValidValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getInvestedValue();\n    }\n\n    function getStrategyPendingValue(\n        address _strategy\n    ) public returns (uint256 _value) {\n        return Strategy(_strategy).getPendingValue();\n    }\n\n    function getAllStrategiesValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyValidValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyValidValue(strategies.at(i));\n        }\n    }\n\n    function getAllStrategyPendingValue() public returns (uint256 _value) {\n        uint256 length = strategies.length();\n        for (uint i; i < length; i++) {\n            _value = _value + getStrategyPendingValue(strategies.at(i));\n        }\n    }\n\n    function getStrategies()\n        public\n        view\n        returns (address[] memory addrs, uint256[] memory portions)\n    {\n        uint256 length = strategies.length();\n\n        addrs = new address[](length);\n        portions = new uint256[](length);\n\n        for (uint256 i; i < length; i++) {\n            address addr = strategies.at(i);\n            addrs[i] = addr;\n            portions[i] = ratios[addr];\n        }\n    }\n\n    function _initStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        require(_strategies.length == _ratios.length, "invalid length");\n\n        uint256 totalRatio;\n        uint256 length = _strategies.length;\n        for (uint i; i < length; i++) {\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function _setStrategies(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) internal {\n        uint256 length = _strategies.length;\n        require(length == _ratios.length, "invalid length");\n\n        uint256 oldLength = strategies.length();\n        for (uint i; i < oldLength; i++) {\n            ratios[strategies.at(i)] = 0;\n        }\n        uint256 totalRatio;\n        for (uint i; i < length; i++) {\n            require(\n                Strategy(_strategies[i]).controller() == address(this),\n                "controller mismatch"\n            );\n            strategies.add(_strategies[i]);\n            ratios[_strategies[i]] = _ratios[i];\n            totalRatio = totalRatio + _ratios[i];\n        }\n        require(totalRatio <= ONE_HUNDRED_PERCENT, "exceed 100%");\n    }\n\n    function clearStrategy(address _strategy) public onlyVault {\n        _clearStrategy(_strategy, false);\n    }\n\n    function _clearStrategy(address _strategy, bool _isRebase) internal {\n        Strategy(_strategy).clear();\n\n        if (!_isRebase) {\n            _repayToVault();\n        }\n    }\n\n    function _destoryStrategy(address _strategy) internal {\n        require(_couldDestroyStrategy(_strategy), "still active");\n\n        strategies.remove(_strategy);\n\n        _repayToVault();\n    }\n\n    function _couldDestroyStrategy(\n        address _strategy\n    ) internal returns (bool status) {\n        return\n            ratios[_strategy] == 0 && Strategy(_strategy).getAllValue() < 1e4;\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        stoneVault = _vault;\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.tor', 'start_line': 1405, 'end_line': 1440, 'offset_start': 45619, 'offset_end': 46598, 'content': 'constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.deposit', 'start_line': 1442, 'end_line': 1449, 'offset_start': 46605, 'offset_end': 46782, 'content': 'function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.depositFor', 'start_line': 1451, 'end_line': 1455, 'offset_start': 46789, 'offset_end': 46955, 'content': 'function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault._depositFor', 'start_line': 1457, 'end_line': 1480, 'offset_start': 46962, 'offset_end': 47760, 'content': 'function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.requestWithdraw', 'start_line': 1482, 'end_line': 1526, 'offset_start': 47767, 'offset_end': 49393, 'content': 'function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.cancelWithdraw', 'start_line': 1528, 'end_line': 1546, 'offset_start': 49400, 'offset_end': 50102, 'content': 'function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.instantWithdraw', 'start_line': 1548, 'end_line': 1650, 'offset_start': 50109, 'offset_end': 53620, 'content': 'function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.rollToNextRound', 'start_line': 1652, 'end_line': 1699, 'offset_start': 53627, 'offset_end': 55406, 'content': 'function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.addStrategy', 'start_line': 1701, 'end_line': 1706, 'offset_start': 55413, 'offset_end': 55644, 'content': 'function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.destroyStrategy', 'start_line': 1708, 'end_line': 1713, 'offset_start': 55651, 'offset_end': 55891, 'content': 'function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.clearStrategy', 'start_line': 1715, 'end_line': 1720, 'offset_start': 55898, 'offset_end': 56132, 'content': 'function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.updatePortfolioConfig', 'start_line': 1722, 'end_line': 1731, 'offset_start': 56139, 'offset_end': 56473, 'content': 'function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.updateProposal', 'start_line': 1733, 'end_line': 1735, 'offset_start': 56480, 'offset_end': 56581, 'content': 'function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.migrateVault', 'start_line': 1737, 'end_line': 1741, 'offset_start': 56588, 'offset_end': 56820, 'content': 'function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.currentSharePrice', 'start_line': 1743, 'end_line': 1760, 'offset_start': 56827, 'offset_end': 57482, 'content': 'function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.getVaultAvailableAmount', 'start_line': 1762, 'end_line': 1774, 'offset_start': 57489, 'offset_end': 57914, 'content': 'function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.setWithdrawFeeRate', 'start_line': 1776, 'end_line': 1782, 'offset_start': 57921, 'offset_end': 58187, 'content': 'function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.setFeeRecipient', 'start_line': 1784, 'end_line': 1790, 'offset_start': 58194, 'offset_end': 58428, 'content': 'function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.setRebaseInterval', 'start_line': 1792, 'end_line': 1797, 'offset_start': 58435, 'offset_end': 58665, 'content': 'function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'StoneVault.', 'start_line': 1799, 'end_line': 1799, 'offset_start': 58672, 'offset_end': 58700, 'content': 'receive() external payable {}', 'contract_name': 'StoneVault', 'contract_code': '{\n    uint256 internal constant MULTIPLIER = 1e18;\n    uint256 internal constant ONE_HUNDRED_PERCENT = 1e6;\n    uint256 internal constant MAXMIUM_FEE_RATE = ONE_HUNDRED_PERCENT / 100; // 1%\n    uint256 internal constant MINIMUM_REBASE_INTERVAL = 7 * 24 * 60 * 60;\n\n    uint256 public constant VERSION = 1;\n\n    uint256 public rebaseTimeInterval = 24 * 60 * 60;\n\n    address public immutable minter;\n    address public immutable stone;\n    address payable public immutable strategyController;\n    address payable public immutable assetsVault;\n\n    address public proposal;\n\n    address public feeRecipient;\n\n    uint256 public latestRoundID;\n\n    uint256 public withdrawableAmountInPast;\n    uint256 public withdrawingSharesInPast;\n    uint256 public withdrawingSharesInRound;\n\n    uint256 public withdrawFeeRate;\n\n    uint256 public rebaseTime;\n\n    mapping(uint256 => uint256) public roundPricePerShare;\n    mapping(uint256 => uint256) public settlementTime;\n\n    mapping(address => UserReceipt) public userReceipts;\n\n    struct UserReceipt {\n        uint256 withdrawRound;\n        uint256 withdrawShares;\n        uint256 withdrawableAmount;\n    }\n\n    event Deposit(\n        address indexed account,\n        uint256 amount,\n        uint256 mint,\n        uint256 round\n    );\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n    event CancelWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n    event Withdrawn(address indexed account, uint256 amount, uint256 round);\n    event WithdrawnFromStrategy(\n        address indexed account,\n        uint256 amount,\n        uint256 actualAmount,\n        uint256 round\n    );\n    event RollToNextRound(\n        uint256 round,\n        uint256 vaultIn,\n        uint256 vaultOut,\n        uint256 sharePrice\n    );\n    event StragetyAdded(address strategy);\n    event StragetyDestroyed(address strategy);\n    event StragetyCleared(address strategy);\n    event PortfolioConfigUpdated(address[] strategies, uint256[] ratios);\n    event FeeCharged(address indexed account, uint256 amount);\n    event SetWithdrawFeeRate(uint256 oldRate, uint256 newRate);\n    event SetFeeRecipient(address oldAddr, address newAddr);\n    event SetRebaseInterval(uint256 interval);\n\n    modifier onlyProposal() {\n        require(proposal == msg.sender, "not proposal");\n        _;\n    }\n\n    constructor(\n        address _minter,\n        address _proposal,\n        address payable _assetsVault,\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) {\n        require(\n            _minter != address(0) &&\n                _proposal != address(0) &&\n                _assetsVault != address(0),\n            "ZERO ADDRESS"\n        );\n\n        uint256 length = _strategies.length;\n        for (uint256 i; i < length; i++) {\n            require(_strategies[i] != address(0), "ZERO ADDRESS");\n        }\n\n        minter = _minter;\n        proposal = _proposal;\n        assetsVault = _assetsVault;\n\n        feeRecipient = msg.sender;\n\n        StrategyController controller = new StrategyController(\n            _assetsVault,\n            _strategies,\n            _ratios\n        );\n        strategyController = payable(address(controller));\n        stone = Minter(_minter).stone();\n\n        roundPricePerShare[0] = MULTIPLIER;\n        latestRoundID = 0;\n    }\n\n    function deposit()\n        external\n        payable\n        nonReentrant\n        returns (uint256 mintAmount)\n    {\n        mintAmount = _depositFor(msg.value, msg.sender);\n    }\n\n    function depositFor(\n        address _user\n    ) external payable nonReentrant returns (uint256 mintAmount) {\n        mintAmount = _depositFor(msg.value, _user);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _user\n    ) internal returns (uint256 mintAmount) {\n        require(_amount != 0, "too small");\n\n        uint256 sharePrice;\n        uint256 currSharePrice = currentSharePrice();\n        if (latestRoundID == 0) {\n            sharePrice = MULTIPLIER;\n        } else {\n            uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1];\n            sharePrice = latestSharePrice > currSharePrice\n                ? latestSharePrice\n                : currSharePrice;\n        }\n\n        mintAmount = (_amount * MULTIPLIER) / sharePrice;\n\n        AssetsVault(assetsVault).deposit{value: address(this).balance}();\n        Minter(minter).mint(_user, mintAmount);\n\n        emit Deposit(_user, _amount, mintAmount, latestRoundID);\n    }\n\n    function requestWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n        require(latestRoundID != 0, "should withdraw instantly");\n        Stone stoneToken = Stone(stone);\n        Minter stoneMinter = Minter(minter);\n\n        require(stoneToken.balanceOf(msg.sender) >= _shares, "exceed balance");\n\n        TransferHelper.safeTransferFrom(\n            stone,\n            msg.sender,\n            address(this),\n            _shares\n        );\n\n        withdrawingSharesInRound = withdrawingSharesInRound + _shares;\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n\n        if (receipt.withdrawRound == latestRoundID) {\n            receipt.withdrawShares = receipt.withdrawShares + _shares;\n        } else if (receipt.withdrawRound == 0) {\n            receipt.withdrawShares = _shares;\n            receipt.withdrawRound = latestRoundID;\n        } else {\n            // Withdraw previous round share first\n            uint256 withdrawAmount = VaultMath.sharesToAsset(\n                receipt.withdrawShares,\n                roundPricePerShare[receipt.withdrawRound]\n            );\n\n            stoneMinter.burn(address(this), receipt.withdrawShares);\n            withdrawingSharesInPast =\n                withdrawingSharesInPast -\n                receipt.withdrawShares;\n\n            receipt.withdrawShares = _shares;\n            receipt.withdrawableAmount =\n                receipt.withdrawableAmount +\n                withdrawAmount;\n            receipt.withdrawRound = latestRoundID;\n        }\n\n        emit InitiateWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function cancelWithdraw(uint256 _shares) external nonReentrant {\n        require(_shares != 0, "too small");\n\n        UserReceipt storage receipt = userReceipts[msg.sender];\n        require(receipt.withdrawRound == latestRoundID, "no pending withdraw");\n        require(receipt.withdrawShares >= _shares, "exceed pending withdraw");\n\n        receipt.withdrawShares = receipt.withdrawShares - _shares;\n\n        TransferHelper.safeTransfer(stone, msg.sender, _shares);\n\n        if (receipt.withdrawShares == 0) {\n            receipt.withdrawRound = 0;\n        }\n\n        withdrawingSharesInRound = withdrawingSharesInRound - _shares;\n\n        emit CancelWithdraw(msg.sender, _shares, latestRoundID);\n    }\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external nonReentrant returns (uint256 actualWithdrawn) {\n        require(_amount != 0 || _shares != 0, "too small");\n\n        AssetsVault aVault = AssetsVault(assetsVault);\n        Minter stoneMinter = Minter(minter);\n\n        (uint256 idleAmount, ) = getVaultAvailableAmount();\n\n        if (_amount != 0) {\n            UserReceipt storage receipt = userReceipts[msg.sender];\n\n            if (\n                receipt.withdrawRound != latestRoundID &&\n                receipt.withdrawRound != 0\n            ) {\n                // Withdraw previous round share first\n                uint256 withdrawAmount = VaultMath.sharesToAsset(\n                    receipt.withdrawShares,\n                    roundPricePerShare[receipt.withdrawRound]\n                );\n\n                stoneMinter.burn(address(this), receipt.withdrawShares);\n\n                withdrawingSharesInPast =\n                    withdrawingSharesInPast -\n                    receipt.withdrawShares;\n                receipt.withdrawShares = 0;\n                receipt.withdrawableAmount =\n                    receipt.withdrawableAmount +\n                    withdrawAmount;\n                receipt.withdrawRound = 0;\n            }\n\n            require(\n                receipt.withdrawableAmount >= _amount,\n                "exceed withdrawable"\n            );\n\n            receipt.withdrawableAmount = receipt.withdrawableAmount - _amount;\n            withdrawableAmountInPast = withdrawableAmountInPast - _amount;\n            actualWithdrawn = _amount;\n\n            emit Withdrawn(msg.sender, _amount, latestRoundID);\n        }\n\n        if (_shares != 0) {\n            uint256 sharePrice;\n\n            if (latestRoundID == 0) {\n                sharePrice = MULTIPLIER;\n            } else {\n                uint256 currSharePrice = currentSharePrice();\n                uint256 latestSharePrice = roundPricePerShare[\n                    latestRoundID - 1\n                ];\n\n                sharePrice = latestSharePrice < currSharePrice\n                    ? latestSharePrice\n                    : currSharePrice;\n            }\n\n            uint256 ethAmount = VaultMath.sharesToAsset(_shares, sharePrice);\n\n            stoneMinter.burn(msg.sender, _shares);\n\n            if (ethAmount <= idleAmount) {\n                actualWithdrawn = actualWithdrawn + ethAmount;\n\n                emit Withdrawn(msg.sender, ethAmount, latestRoundID);\n            } else {\n                actualWithdrawn = actualWithdrawn + idleAmount;\n                ethAmount = ethAmount - idleAmount;\n\n                StrategyController controller = StrategyController(\n                    strategyController\n                );\n                uint256 actualAmount = controller.forceWithdraw(ethAmount);\n\n                actualWithdrawn = actualWithdrawn + actualAmount;\n\n                emit WithdrawnFromStrategy(\n                    msg.sender,\n                    ethAmount,\n                    actualAmount,\n                    latestRoundID\n                );\n            }\n        }\n\n        require(aVault.getBalance() >= actualWithdrawn, "still need wait");\n\n        uint256 withFee;\n        if (withdrawFeeRate != 0) {\n            withFee = (actualWithdrawn * withdrawFeeRate) / ONE_HUNDRED_PERCENT;\n            aVault.withdraw(feeRecipient, withFee);\n\n            emit FeeCharged(msg.sender, withFee);\n        }\n        aVault.withdraw(msg.sender, actualWithdrawn - withFee);\n    }\n\n    function rollToNextRound() external {\n        require(\n            block.timestamp > rebaseTime + rebaseTimeInterval,\n            "already rebased"\n        );\n\n        StrategyController controller = StrategyController(strategyController);\n        AssetsVault aVault = AssetsVault(assetsVault);\n        uint256 previewSharePrice = currentSharePrice();\n\n        uint256 vaultBalance = aVault.getBalance();\n        uint256 amountToWithdraw = VaultMath.sharesToAsset(\n            withdrawingSharesInRound,\n            previewSharePrice\n        );\n        uint256 amountVaultNeed = withdrawableAmountInPast + amountToWithdraw;\n        uint256 allPendingValue = controller.getAllStrategyPendingValue();\n\n        uint256 vaultIn;\n        uint256 vaultOut;\n\n        if (vaultBalance > amountVaultNeed) {\n            vaultIn = vaultBalance - amountVaultNeed;\n        } else if (vaultBalance + allPendingValue < amountVaultNeed) {\n            vaultOut = amountVaultNeed - vaultBalance - allPendingValue;\n        }\n\n        controller.rebaseStrategies(vaultIn, vaultOut);\n\n        uint256 newSharePrice = currentSharePrice();\n        roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice\n            ? previewSharePrice\n            : newSharePrice;\n\n        settlementTime[latestRoundID] = block.timestamp;\n        latestRoundID = latestRoundID + 1;\n\n        withdrawingSharesInPast =\n            withdrawingSharesInPast +\n            withdrawingSharesInRound;\n        withdrawableAmountInPast =\n            withdrawableAmountInPast +\n            VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice);\n        withdrawingSharesInRound = 0;\n        rebaseTime = block.timestamp;\n\n        emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice);\n    }\n\n    function addStrategy(address _strategy) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.addStrategy(_strategy);\n        emit StragetyAdded(_strategy);\n    }\n\n    function destroyStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.destroyStrategy(_strategy);\n        emit StragetyDestroyed(_strategy);\n    }\n\n    function clearStrategy(address _strategy) external onlyOwner {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.clearStrategy(_strategy);\n        emit StragetyCleared(_strategy);\n    }\n\n    function updatePortfolioConfig(\n        address[] memory _strategies,\n        uint256[] memory _ratios\n    ) external onlyProposal {\n        StrategyController controller = StrategyController(strategyController);\n\n        controller.setStrategies(_strategies, _ratios);\n\n        emit PortfolioConfigUpdated(_strategies, _ratios);\n    }\n\n    function updateProposal(address _proposal) external onlyProposal {\n        proposal = _proposal;\n    }\n\n    function migrateVault(address _vault) external onlyProposal {\n        Minter(minter).setNewVault(_vault);\n        AssetsVault(assetsVault).setNewVault(_vault);\n        StrategyController(strategyController).setNewVault(_vault);\n    }\n\n    function currentSharePrice() public returns (uint256 price) {\n        Stone stoneToken = Stone(stone);\n        uint256 totalStone = stoneToken.totalSupply();\n        if (\n            latestRoundID == 0 ||\n            totalStone == 0 ||\n            totalStone == withdrawingSharesInPast\n        ) {\n            return MULTIPLIER;\n        }\n\n        uint256 etherAmount = AssetsVault(assetsVault).getBalance() +\n            StrategyController(strategyController).getAllStrategiesValue() -\n            withdrawableAmountInPast;\n        uint256 activeShare = totalStone - withdrawingSharesInPast;\n\n        return (etherAmount * MULTIPLIER) / activeShare;\n    }\n\n    function getVaultAvailableAmount()\n        public\n        returns (uint256 idleAmount, uint256 investedAmount)\n    {\n        AssetsVault vault = AssetsVault(assetsVault);\n\n        if (vault.getBalance() > withdrawableAmountInPast) {\n            idleAmount = vault.getBalance() - withdrawableAmountInPast;\n        }\n\n        investedAmount = StrategyController(strategyController)\n            .getAllStrategyValidValue();\n    }\n\n    function setWithdrawFeeRate(uint256 _withdrawFeeRate) external onlyOwner {\n        require(_withdrawFeeRate <= MAXMIUM_FEE_RATE, "exceed maximum");\n\n        emit SetWithdrawFeeRate(withdrawFeeRate, _withdrawFeeRate);\n\n        withdrawFeeRate = _withdrawFeeRate;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), "zero address");\n\n        emit SetFeeRecipient(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    function setRebaseInterval(uint256 _interval) external onlyOwner {\n        require(_interval <= MINIMUM_REBASE_INTERVAL, "invalid");\n\n        rebaseTimeInterval = _interval;\n        emit SetRebaseInterval(rebaseTimeInterval);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.send', 'start_line': 1816, 'end_line': 1816, 'offset_start': 59619, 'offset_end': 59814, 'content': 'function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.receivePayload', 'start_line': 1825, 'end_line': 1825, 'offset_start': 60298, 'offset_end': 60455, 'content': 'function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getInboundNonce', 'start_line': 1830, 'end_line': 1830, 'offset_start': 60683, 'offset_end': 60786, 'content': 'function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getOutboundNonce', 'start_line': 1834, 'end_line': 1834, 'offset_start': 60953, 'offset_end': 61050, 'content': 'function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.estimateFees', 'start_line': 1842, 'end_line': 1842, 'offset_start': 61565, 'offset_end': 61755, 'content': 'function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getChainId', 'start_line': 1845, 'end_line': 1845, 'offset_start': 61825, 'offset_end': 61877, 'content': 'function getChainId() external view returns (uint16);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.retryPayload', 'start_line': 1851, 'end_line': 1851, 'offset_start': 62135, 'offset_end': 62238, 'content': 'function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.hasStoredPayload', 'start_line': 1856, 'end_line': 1856, 'offset_start': 62442, 'offset_end': 62544, 'content': 'function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getSendLibraryAddress', 'start_line': 1860, 'end_line': 1860, 'offset_start': 62694, 'offset_end': 62782, 'content': 'function getSendLibraryAddress(address _userApplication) external view returns (address);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getReceiveLibraryAddress', 'start_line': 1864, 'end_line': 1864, 'offset_start': 62934, 'offset_end': 63025, 'content': 'function getReceiveLibraryAddress(address _userApplication) external view returns (address);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.isSendingPayload', 'start_line': 1868, 'end_line': 1868, 'offset_start': 63154, 'offset_end': 63210, 'content': 'function isSendingPayload() external view returns (bool);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.isReceivingPayload', 'start_line': 1872, 'end_line': 1872, 'offset_start': 63342, 'offset_end': 63400, 'content': 'function isReceivingPayload() external view returns (bool);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getConfig', 'start_line': 1879, 'end_line': 1879, 'offset_start': 63799, 'offset_end': 63932, 'content': 'function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getSendVersion', 'start_line': 1883, 'end_line': 1883, 'offset_start': 64083, 'offset_end': 64163, 'content': 'function getSendVersion(address _userApplication) external view returns (uint16);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroEndpoint.getReceiveVersion', 'start_line': 1887, 'end_line': 1887, 'offset_start': 64319, 'offset_end': 64402, 'content': 'function getReceiveVersion(address _userApplication) external view returns (uint16);', 'contract_name': 'ILayerZeroEndpoint', 'contract_code': "{\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BasedOFT.tor', 'start_line': 1897, 'end_line': 1897, 'offset_start': 64518, 'offset_end': 64629, 'content': 'constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}', 'contract_name': 'BasedOFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        unchecked {\n            return totalSupply() - balanceOf(address(this));\n        }\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, address(this), _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _transfer(address(this), _toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BasedOFT.circulatingSupply', 'start_line': 1899, 'end_line': 1903, 'offset_start': 64636, 'offset_end': 64806, 'content': 'function circulatingSupply() public view virtual override returns (uint) {\n        unchecked {\n            return totalSupply() - balanceOf(address(this));\n        }\n    }', 'contract_name': 'BasedOFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        unchecked {\n            return totalSupply() - balanceOf(address(this));\n        }\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, address(this), _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _transfer(address(this), _toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BasedOFT._debitFrom', 'start_line': 1905, 'end_line': 1910, 'offset_start': 64813, 'offset_end': 65116, 'content': 'function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, address(this), _amount);\n        return _amount;\n    }', 'contract_name': 'BasedOFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        unchecked {\n            return totalSupply() - balanceOf(address(this));\n        }\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, address(this), _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _transfer(address(this), _toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'BasedOFT._creditTo', 'start_line': 1912, 'end_line': 1915, 'offset_start': 65123, 'offset_end': 65309, 'content': 'function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _transfer(address(this), _toAddress, _amount);\n        return _amount;\n    }', 'contract_name': 'BasedOFT', 'contract_code': '{\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\n\n    function circulatingSupply() public view virtual override returns (uint) {\n        unchecked {\n            return totalSupply() - balanceOf(address(this));\n        }\n    }\n\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override returns(uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, address(this), _amount);\n        return _amount;\n    }\n\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override returns(uint) {\n        _transfer(address(this), _toAddress, _amount);\n        return _amount;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 1955, 'end_line': 1955, 'offset_start': 66317, 'offset_end': 66392, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.tor', 'start_line': 2011, 'end_line': 2014, 'offset_start': 68377, 'offset_end': 68489, 'content': 'constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.name', 'start_line': 2019, 'end_line': 2021, 'offset_start': 68555, 'offset_end': 68652, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.symbol', 'start_line': 2027, 'end_line': 2029, 'offset_start': 68766, 'offset_end': 68867, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.decimals', 'start_line': 2044, 'end_line': 2046, 'offset_start': 69501, 'offset_end': 69591, 'content': 'function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.totalSupply', 'start_line': 2051, 'end_line': 2053, 'offset_start': 69652, 'offset_end': 69757, 'content': 'function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.balanceOf', 'start_line': 2058, 'end_line': 2060, 'offset_start': 69816, 'offset_end': 69940, 'content': 'function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transfer', 'start_line': 2070, 'end_line': 2074, 'offset_start': 70137, 'offset_end': 70325, 'content': 'function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.allowance', 'start_line': 2079, 'end_line': 2081, 'offset_start': 70384, 'offset_end': 70532, 'content': 'function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.approve', 'start_line': 2093, 'end_line': 2097, 'offset_start': 70841, 'offset_end': 71037, 'content': 'function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transferFrom', 'start_line': 2115, 'end_line': 2120, 'offset_start': 71600, 'offset_end': 71855, 'content': 'function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.increaseAllowance', 'start_line': 2134, 'end_line': 2138, 'offset_start': 72251, 'offset_end': 72484, 'content': 'function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.decreaseAllowance', 'start_line': 2154, 'end_line': 2163, 'offset_start': 72972, 'offset_end': 73398, 'content': 'function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._transfer', 'start_line': 2179, 'end_line': 2197, 'offset_start': 73853, 'offset_end': 74640, 'content': 'function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._mint', 'start_line': 2208, 'end_line': 2221, 'offset_start': 74917, 'offset_end': 75451, 'content': 'function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._burn', 'start_line': 2234, 'end_line': 2250, 'offset_start': 75772, 'offset_end': 76430, 'content': 'function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._approve', 'start_line': 2265, 'end_line': 2271, 'offset_start': 76854, 'offset_end': 77193, 'content': 'function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._spendAllowance', 'start_line': 2281, 'end_line': 2289, 'offset_start': 77475, 'offset_end': 77885, 'content': 'function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._beforeTokenTransfer', 'start_line': 2305, 'end_line': 2305, 'offset_start': 78470, 'offset_end': 78560, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._afterTokenTransfer', 'start_line': 2321, 'end_line': 2321, 'offset_start': 79149, 'offset_end': 79238, 'content': 'function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}', 'contract_name': 'ERC20', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it\'s overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroUserApplicationConfig.setConfig', 'start_line': 2334, 'end_line': 2334, 'offset_start': 79746, 'offset_end': 79849, 'content': 'function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;', 'contract_name': 'ILayerZeroUserApplicationConfig', 'contract_code': '{\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroUserApplicationConfig.setSendVersion', 'start_line': 2338, 'end_line': 2338, 'offset_start': 79989, 'offset_end': 80038, 'content': 'function setSendVersion(uint16 _version) external;', 'contract_name': 'ILayerZeroUserApplicationConfig', 'contract_code': '{\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroUserApplicationConfig.setReceiveVersion', 'start_line': 2342, 'end_line': 2342, 'offset_start': 80183, 'offset_end': 80235, 'content': 'function setReceiveVersion(uint16 _version) external;', 'contract_name': 'ILayerZeroUserApplicationConfig', 'contract_code': '{\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroUserApplicationConfig.forceResumeReceive', 'start_line': 2347, 'end_line': 2347, 'offset_start': 80505, 'offset_end': 80589, 'content': 'function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;', 'contract_name': 'ILayerZeroUserApplicationConfig', 'contract_code': '{\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'TransferHelper.safeTransferFrom', 'start_line': 2362, 'end_line': 2371, 'offset_start': 81155, 'offset_end': 81512, 'content': "function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }", 'contract_name': 'TransferHelper', 'contract_code': "{\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'TransferHelper.safeTransfer', 'start_line': 2378, 'end_line': 2385, 'offset_start': 81805, 'offset_end': 82113, 'content': "function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }", 'contract_name': 'TransferHelper', 'contract_code': "{\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'TransferHelper.safeApprove', 'start_line': 2392, 'end_line': 2399, 'offset_start': 82467, 'offset_end': 82773, 'content': "function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }", 'contract_name': 'TransferHelper', 'contract_code': "{\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'TransferHelper.safeTransferETH', 'start_line': 2405, 'end_line': 2408, 'offset_start': 82964, 'offset_end': 83128, 'content': "function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }", 'contract_name': 'TransferHelper', 'contract_code': "{\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Minter.tor', 'start_line': 2427, 'end_line': 2430, 'offset_start': 83483, 'offset_end': 83589, 'content': 'constructor(address _stone, address payable _vault) {\n        stone = _stone;\n        vault = _vault;\n    }', 'contract_name': 'Minter', 'contract_code': '{\n    // TODO: governable upgrade\n    address public stone;\n    address payable public vault;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, "not vault");\n        _;\n    }\n\n    constructor(address _stone, address payable _vault) {\n        stone = _stone;\n        vault = _vault;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyVault {\n        Stone(stone).mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyVault {\n        Stone(stone).burn(_from, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        vault = payable(_vault);\n    }\n\n    function getTokenPrice() public returns (uint256 price) {\n        price = StoneVault(vault).currentSharePrice();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Minter.mint', 'start_line': 2432, 'end_line': 2434, 'offset_start': 83596, 'offset_end': 83706, 'content': 'function mint(address _to, uint256 _amount) external onlyVault {\n        Stone(stone).mint(_to, _amount);\n    }', 'contract_name': 'Minter', 'contract_code': '{\n    // TODO: governable upgrade\n    address public stone;\n    address payable public vault;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, "not vault");\n        _;\n    }\n\n    constructor(address _stone, address payable _vault) {\n        stone = _stone;\n        vault = _vault;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyVault {\n        Stone(stone).mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyVault {\n        Stone(stone).burn(_from, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        vault = payable(_vault);\n    }\n\n    function getTokenPrice() public returns (uint256 price) {\n        price = StoneVault(vault).currentSharePrice();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Minter.burn', 'start_line': 2436, 'end_line': 2438, 'offset_start': 83713, 'offset_end': 83827, 'content': 'function burn(address _from, uint256 _amount) external onlyVault {\n        Stone(stone).burn(_from, _amount);\n    }', 'contract_name': 'Minter', 'contract_code': '{\n    // TODO: governable upgrade\n    address public stone;\n    address payable public vault;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, "not vault");\n        _;\n    }\n\n    constructor(address _stone, address payable _vault) {\n        stone = _stone;\n        vault = _vault;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyVault {\n        Stone(stone).mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyVault {\n        Stone(stone).burn(_from, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        vault = payable(_vault);\n    }\n\n    function getTokenPrice() public returns (uint256 price) {\n        price = StoneVault(vault).currentSharePrice();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Minter.setNewVault', 'start_line': 2440, 'end_line': 2442, 'offset_start': 83834, 'offset_end': 83929, 'content': 'function setNewVault(address _vault) external onlyVault {\n        vault = payable(_vault);\n    }', 'contract_name': 'Minter', 'contract_code': '{\n    // TODO: governable upgrade\n    address public stone;\n    address payable public vault;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, "not vault");\n        _;\n    }\n\n    constructor(address _stone, address payable _vault) {\n        stone = _stone;\n        vault = _vault;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyVault {\n        Stone(stone).mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyVault {\n        Stone(stone).burn(_from, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        vault = payable(_vault);\n    }\n\n    function getTokenPrice() public returns (uint256 price) {\n        price = StoneVault(vault).currentSharePrice();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Minter.getTokenPrice', 'start_line': 2444, 'end_line': 2446, 'offset_start': 83936, 'offset_end': 84053, 'content': 'function getTokenPrice() public returns (uint256 price) {\n        price = StoneVault(vault).currentSharePrice();\n    }', 'contract_name': 'Minter', 'contract_code': '{\n    // TODO: governable upgrade\n    address public stone;\n    address payable public vault;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, "not vault");\n        _;\n    }\n\n    constructor(address _stone, address payable _vault) {\n        stone = _stone;\n        vault = _vault;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyVault {\n        Stone(stone).mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyVault {\n        Stone(stone).burn(_from, _amount);\n    }\n\n    function setNewVault(address _vault) external onlyVault {\n        vault = payable(_vault);\n    }\n\n    function getTokenPrice() public returns (uint256 price) {\n        price = StoneVault(vault).currentSharePrice();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet._add', 'start_line': 2513, 'end_line': 2523, 'offset_start': 86272, 'offset_end': 86675, 'content': 'function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet._remove', 'start_line': 2531, 'end_line': 2563, 'offset_start': 86844, 'offset_end': 88231, 'content': "function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }", 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet._contains', 'start_line': 2568, 'end_line': 2570, 'offset_start': 88313, 'offset_end': 88439, 'content': 'function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet._length', 'start_line': 2575, 'end_line': 2577, 'offset_start': 88521, 'offset_end': 88627, 'content': 'function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet._at', 'start_line': 2589, 'end_line': 2591, 'offset_start': 88970, 'offset_end': 89087, 'content': 'function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet._values', 'start_line': 2601, 'end_line': 2603, 'offset_start': 89628, 'offset_end': 89736, 'content': 'function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.add', 'start_line': 2617, 'end_line': 2619, 'offset_start': 89977, 'offset_end': 90099, 'content': 'function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.remove', 'start_line': 2627, 'end_line': 2629, 'offset_start': 90268, 'offset_end': 90396, 'content': 'function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.contains', 'start_line': 2634, 'end_line': 2636, 'offset_start': 90478, 'offset_end': 90615, 'content': 'function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.length', 'start_line': 2641, 'end_line': 2643, 'offset_start': 90697, 'offset_end': 90811, 'content': 'function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.at', 'start_line': 2655, 'end_line': 2657, 'offset_start': 91154, 'offset_end': 91282, 'content': 'function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.values', 'start_line': 2667, 'end_line': 2677, 'offset_start': 91823, 'offset_end': 92122, 'content': 'function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.add', 'start_line': 2691, 'end_line': 2693, 'offset_start': 92363, 'offset_end': 92512, 'content': 'function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.remove', 'start_line': 2701, 'end_line': 2703, 'offset_start': 92681, 'offset_end': 92836, 'content': 'function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.contains', 'start_line': 2708, 'end_line': 2710, 'offset_start': 92918, 'offset_end': 93082, 'content': 'function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.length', 'start_line': 2715, 'end_line': 2717, 'offset_start': 93164, 'offset_end': 93278, 'content': 'function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.at', 'start_line': 2729, 'end_line': 2731, 'offset_start': 93621, 'offset_end': 93776, 'content': 'function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.values', 'start_line': 2741, 'end_line': 2751, 'offset_start': 94317, 'offset_end': 94616, 'content': 'function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.add', 'start_line': 2765, 'end_line': 2767, 'offset_start': 94851, 'offset_end': 94979, 'content': 'function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.remove', 'start_line': 2775, 'end_line': 2777, 'offset_start': 95148, 'offset_end': 95282, 'content': 'function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.contains', 'start_line': 2782, 'end_line': 2784, 'offset_start': 95364, 'offset_end': 95507, 'content': 'function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.length', 'start_line': 2789, 'end_line': 2791, 'offset_start': 95589, 'offset_end': 95700, 'content': 'function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.at', 'start_line': 2803, 'end_line': 2805, 'offset_start': 96043, 'offset_end': 96177, 'content': 'function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'EnumerableSet.values', 'start_line': 2815, 'end_line': 2825, 'offset_start': 96718, 'offset_end': 97014, 'content': 'function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }', 'contract_name': 'EnumerableSet', 'contract_code': "{\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IOFTCore.estimateSendFee', 'start_line': 2846, 'end_line': 2846, 'offset_start': 97694, 'offset_end': 97876, 'content': 'function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);', 'contract_name': 'IOFTCore', 'contract_code': '{\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IOFTCore.sendFrom', 'start_line': 2858, 'end_line': 2858, 'offset_start': 98452, 'offset_end': 98653, 'content': 'function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;', 'contract_name': 'IOFTCore', 'contract_code': '{\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IOFTCore.circulatingSupply', 'start_line': 2863, 'end_line': 2863, 'offset_start': 98746, 'offset_end': 98803, 'content': 'function circulatingSupply() external view returns (uint);', 'contract_name': 'IOFTCore', 'contract_code': '{\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'IOFTCore.token', 'start_line': 2868, 'end_line': 2868, 'offset_start': 98877, 'offset_end': 98925, 'content': 'function token() external view returns (address);', 'contract_name': 'IOFTCore', 'contract_code': '{\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ILayerZeroReceiver.lzReceive', 'start_line': 2895, 'end_line': 2895, 'offset_start': 99998, 'offset_end': 100113, 'content': 'function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;', 'contract_name': 'ILayerZeroReceiver', 'contract_code': '{\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.tor', 'start_line': 2917, 'end_line': 2923, 'offset_start': 100566, 'offset_end': 100784, 'content': 'constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.deposit', 'start_line': 2930, 'end_line': 2930, 'offset_start': 100902, 'offset_end': 100960, 'content': 'function deposit() public payable virtual onlyController {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.withdraw', 'start_line': 2932, 'end_line': 2934, 'offset_start': 100967, 'offset_end': 101078, 'content': 'function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.instantWithdraw', 'start_line': 2936, 'end_line': 2938, 'offset_start': 101085, 'offset_end': 101203, 'content': 'function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.clear', 'start_line': 2940, 'end_line': 2940, 'offset_start': 101210, 'offset_end': 101283, 'content': 'function clear() public virtual onlyController returns (uint256 amount) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.execPendingRequest', 'start_line': 2942, 'end_line': 2944, 'offset_start': 101290, 'offset_end': 101390, 'content': 'function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.getAllValue', 'start_line': 2946, 'end_line': 2946, 'offset_start': 101397, 'offset_end': 101460, 'content': 'function getAllValue() public virtual returns (uint256 value) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.getPendingValue', 'start_line': 2948, 'end_line': 2948, 'offset_start': 101467, 'offset_end': 101534, 'content': 'function getPendingValue() public virtual returns (uint256 value) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.getInvestedValue', 'start_line': 2950, 'end_line': 2950, 'offset_start': 101541, 'offset_end': 101609, 'content': 'function getInvestedValue() public virtual returns (uint256 value) {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.checkPendingStatus', 'start_line': 2952, 'end_line': 2956, 'offset_start': 101616, 'offset_end': 101736, 'content': 'function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strategy.setGovernance', 'start_line': 2958, 'end_line': 2961, 'offset_start': 101743, 'offset_end': 101909, 'content': 'function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }', 'contract_name': 'Strategy', 'contract_code': '{\n    address payable public immutable controller;\n\n    address public governance;\n\n    string public name;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, "not governace");\n        _;\n    }\n\n    event TransferGovernance(address oldOwner, address newOwner);\n\n    constructor(address payable _controller, string memory _name) {\n        require(_controller != address(0), "ZERO ADDRESS");\n\n        governance = msg.sender;\n        controller = _controller;\n        name = _name;\n    }\n\n    modifier onlyController() {\n        require(controller == msg.sender, "not controller");\n        _;\n    }\n\n    function deposit() public payable virtual onlyController {}\n\n    function withdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function instantWithdraw(\n        uint256 _amount\n    ) public virtual onlyController returns (uint256 actualAmount) {}\n\n    function clear() public virtual onlyController returns (uint256 amount) {}\n\n    function execPendingRequest(\n        uint256 _amount\n    ) public virtual returns (uint256 amount) {}\n\n    function getAllValue() public virtual returns (uint256 value) {}\n\n    function getPendingValue() public virtual returns (uint256 value) {}\n\n    function getInvestedValue() public virtual returns (uint256 value) {}\n\n    function checkPendingStatus()\n        public\n        virtual\n        returns (uint256 pending, uint256 executable)\n    {}\n\n    function setGovernance(address governance_) external onlyGovernance {\n        emit TransferGovernance(governance, governance_);\n        governance = governance_;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ExcessivelySafeCall.excessivelySafeCall', 'start_line': 2986, 'end_line': 3021, 'offset_start': 103032, 'offset_end': 104271, 'content': 'function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }', 'contract_name': 'ExcessivelySafeCall', 'contract_code': '{\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don\'t trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don\'t trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ExcessivelySafeCall.excessivelySafeStaticCall', 'start_line': 3038, 'end_line': 3072, 'offset_start': 105182, 'offset_end': 106408, 'content': 'function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }', 'contract_name': 'ExcessivelySafeCall', 'contract_code': '{\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don\'t trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don\'t trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ExcessivelySafeCall.swapSelector', 'start_line': 3083, 'end_line': 3098, 'offset_start': 106862, 'offset_end': 107316, 'content': 'function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }', 'contract_name': 'ExcessivelySafeCall', 'contract_code': '{\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don\'t trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don\'t trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling "handle" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165.supportsInterface', 'start_line': 3126, 'end_line': 3128, 'offset_start': 108150, 'offset_end': 108304, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165', 'contract_code': '{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard.tor', 'start_line': 3169, 'end_line': 3171, 'offset_start': 110106, 'offset_end': 110158, 'content': 'constructor() {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._nonReentrantBefore', 'start_line': 3186, 'end_line': 3192, 'offset_start': 110645, 'offset_end': 110931, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._nonReentrantAfter', 'start_line': 3194, 'end_line': 3198, 'offset_start': 110938, 'offset_end': 111146, 'content': 'function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._reentrancyGuardEntered', 'start_line': 3204, 'end_line': 3206, 'offset_start': 111326, 'offset_end': 111432, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore.tor', 'start_line': 3227, 'end_line': 3227, 'offset_start': 111875, 'offset_end': 111939, 'content': 'constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore.supportsInterface', 'start_line': 3229, 'end_line': 3231, 'offset_start': 111946, 'offset_end': 112158, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore.estimateSendFee', 'start_line': 3233, 'end_line': 3237, 'offset_start': 112165, 'offset_end': 112587, 'content': 'function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore.sendFrom', 'start_line': 3239, 'end_line': 3241, 'offset_start': 112594, 'offset_end': 112925, 'content': 'function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore.setUseCustomAdapterParams', 'start_line': 3243, 'end_line': 3246, 'offset_start': 112932, 'offset_end': 113151, 'content': 'function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore._nonblockingLzReceive', 'start_line': 3248, 'end_line': 3259, 'offset_start': 113158, 'offset_end': 113595, 'content': 'function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore._send', 'start_line': 3261, 'end_line': 3270, 'offset_start': 113602, 'offset_end': 114206, 'content': 'function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore._sendAck', 'start_line': 3272, 'end_line': 3279, 'offset_start': 114213, 'offset_end': 114580, 'content': 'function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore._checkAdapterParams', 'start_line': 3281, 'end_line': 3287, 'offset_start': 114587, 'offset_end': 114953, 'content': 'function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore._debitFrom', 'start_line': 3289, 'end_line': 3289, 'offset_start': 114960, 'offset_end': 115084, 'content': 'function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'OFTCore._creditTo', 'start_line': 3291, 'end_line': 3291, 'offset_start': 115091, 'offset_end': 115194, 'content': 'function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);', 'contract_name': 'OFTCore', 'contract_code': '{\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert("OFTCore: unknown packet type");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, "OFTCore: _adapterParams must be empty.");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'VaultMath.assetToShares', 'start_line': 3300, 'end_line': 3306, 'offset_start': 115326, 'offset_end': 115595, 'content': 'function assetToShares(\n        uint256 _assetAmount,\n        uint256 _assetPerShare\n    ) internal pure returns (uint256) {\n        require(_assetPerShare > 1, "Vault Lib: invalid assetPerShare");\n        return (_assetAmount * (10 ** DECIMALS)) / _assetPerShare;\n    }', 'contract_name': 'VaultMath', 'contract_code': '{\n    uint256 internal constant DECIMALS = 18;\n\n    function assetToShares(\n        uint256 _assetAmount,\n        uint256 _assetPerShare\n    ) internal pure returns (uint256) {\n        require(_assetPerShare > 1, "Vault Lib: invalid assetPerShare");\n        return (_assetAmount * (10 ** DECIMALS)) / _assetPerShare;\n    }\n\n    function sharesToAsset(\n        uint256 _shares,\n        uint256 _assetPerShare\n    ) internal pure returns (uint256) {\n        require(_assetPerShare > 1, "Vault Lib: invalid assetPerShare");\n        return (_shares * _assetPerShare) / (10 ** DECIMALS);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'VaultMath.sharesToAsset', 'start_line': 3308, 'end_line': 3314, 'offset_start': 115602, 'offset_end': 115861, 'content': 'function sharesToAsset(\n        uint256 _shares,\n        uint256 _assetPerShare\n    ) internal pure returns (uint256) {\n        require(_assetPerShare > 1, "Vault Lib: invalid assetPerShare");\n        return (_shares * _assetPerShare) / (10 ** DECIMALS);\n    }', 'contract_name': 'VaultMath', 'contract_code': '{\n    uint256 internal constant DECIMALS = 18;\n\n    function assetToShares(\n        uint256 _assetAmount,\n        uint256 _assetPerShare\n    ) internal pure returns (uint256) {\n        require(_assetPerShare > 1, "Vault Lib: invalid assetPerShare");\n        return (_assetAmount * (10 ** DECIMALS)) / _assetPerShare;\n    }\n\n    function sharesToAsset(\n        uint256 _shares,\n        uint256 _assetPerShare\n    ) internal pure returns (uint256) {\n        require(_assetPerShare > 1, "Vault Lib: invalid assetPerShare");\n        return (_shares * _assetPerShare) / (10 ** DECIMALS);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.tor', 'start_line': 3347, 'end_line': 3349, 'offset_start': 117024, 'offset_end': 117113, 'content': 'constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.lzReceive', 'start_line': 3351, 'end_line': 3360, 'offset_start': 117120, 'offset_end': 117872, 'content': 'function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp._blockingLzReceive', 'start_line': 3363, 'end_line': 3363, 'offset_start': 118022, 'offset_end': 118150, 'content': 'function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp._lzSend', 'start_line': 3365, 'end_line': 3370, 'offset_start': 118157, 'offset_end': 118704, 'content': 'function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp._checkGasLimit', 'start_line': 3372, 'end_line': 3377, 'offset_start': 118711, 'offset_end': 119125, 'content': 'function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp._getGasLimit', 'start_line': 3379, 'end_line': 3384, 'offset_start': 119132, 'offset_end': 119397, 'content': 'function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp._checkPayloadSize', 'start_line': 3386, 'end_line': 3392, 'offset_start': 119404, 'offset_end': 119786, 'content': 'function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.getConfig', 'start_line': 3395, 'end_line': 3397, 'offset_start': 119889, 'offset_end': 120097, 'content': 'function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setConfig', 'start_line': 3400, 'end_line': 3402, 'offset_start': 120157, 'offset_end': 120358, 'content': 'function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setSendVersion', 'start_line': 3404, 'end_line': 3406, 'offset_start': 120365, 'offset_end': 120485, 'content': 'function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setReceiveVersion', 'start_line': 3408, 'end_line': 3410, 'offset_start': 120492, 'offset_end': 120618, 'content': 'function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.forceResumeReceive', 'start_line': 3412, 'end_line': 3414, 'offset_start': 120625, 'offset_end': 120800, 'content': 'function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setTrustedRemote', 'start_line': 3418, 'end_line': 3421, 'offset_start': 120944, 'offset_end': 121147, 'content': 'function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setTrustedRemoteAddress', 'start_line': 3423, 'end_line': 3426, 'offset_start': 121154, 'offset_end': 121431, 'content': 'function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.getTrustedRemoteAddress', 'start_line': 3428, 'end_line': 3432, 'offset_start': 121438, 'offset_end': 121763, 'content': 'function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setPrecrime', 'start_line': 3434, 'end_line': 3437, 'offset_start': 121770, 'offset_end': 121902, 'content': 'function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setMinDstGas', 'start_line': 3439, 'end_line': 3443, 'offset_start': 121909, 'offset_end': 122188, 'content': 'function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.setPayloadSizeLimit', 'start_line': 3446, 'end_line': 3448, 'offset_start': 122248, 'offset_end': 122387, 'content': 'function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'LzApp.isTrustedRemote', 'start_line': 3451, 'end_line': 3454, 'offset_start': 122483, 'offset_end': 122729, 'content': 'function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }', 'contract_name': 'LzApp', 'contract_code': '{\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), "LzApp: invalid endpoint caller");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), "LzApp: invalid source sending contract");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, "LzApp: destination chain is not a trusted source");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, "LzApp: minGasLimit not set");\n        require(providedGasLimit >= minGasLimit, "LzApp: gas limit is too low");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, "LzApp: invalid adapterParams");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, "LzApp: payload size is too large");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, "LzApp: no trusted path record");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, "LzApp: invalid minGas");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 3484, 'end_line': 3486, 'offset_start': 123646, 'offset_end': 123708, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 3499, 'end_line': 3501, 'offset_start': 123935, 'offset_end': 124019, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 3506, 'end_line': 3508, 'offset_start': 124093, 'offset_end': 124222, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 3517, 'end_line': 3519, 'offset_start': 124558, 'offset_end': 124658, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 3525, 'end_line': 3528, 'offset_start': 124808, 'offset_end': 125005, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 3534, 'end_line': 3538, 'offset_start': 125160, 'offset_end': 125346, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x7122985656e38bdc0302db86685bb972b145bd3c/0x7122985656e38bdc0302db86685bb972b145bd3c.sol'}
