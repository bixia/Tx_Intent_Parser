{'type': 'FunctionDefinition', 'name': 'MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init', 'start_line': 15, 'end_line': 17, 'offset_start': 548, 'offset_end': 692, 'content': 'function __MemecoinDelegatable_init(address delegate_) internal onlyInitializing {\n        __MemecoinDelegatable_init_unchained(delegate_);\n    }', 'contract_name': 'MemecoinDelegatableUpgradeable', 'contract_code': '{\n    error NotDelegatable();\n\n    IMemecoinDelegate private _delegate;\n\n    function __MemecoinDelegatable_init(address delegate_) internal onlyInitializing {\n        __MemecoinDelegatable_init_unchained(delegate_);\n    }\n\n    function __MemecoinDelegatable_init_unchained(address delegate_) internal onlyInitializing {\n        _delegate = IMemecoinDelegate(delegate_);\n    }\n\n    function delegate() external view returns (address) {\n        return address(_delegate);\n    }\n\n    function _delegateTransfer(address to, uint256 amount) internal returns (bool) {\n        return _delegate.transferFrom(_msgSender(), to, amount);\n    }\n\n    function _delegatePermit(bytes calldata _permit) internal {\n        (uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(_permit, (uint256, uint256, uint8, bytes32, bytes32));\n        try IERC20Permit(_delegate.memecoin()).permit(_msgSender(), address(_delegate), value, deadline, v, r, s) {}\n            catch {}\n    }\n\n    modifier onlyDelegatable() {\n        if (!_delegate.isAuthorized(_msgSender())) revert NotDelegatable();\n        _;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init_unchained', 'start_line': 19, 'end_line': 21, 'offset_start': 699, 'offset_end': 846, 'content': 'function __MemecoinDelegatable_init_unchained(address delegate_) internal onlyInitializing {\n        _delegate = IMemecoinDelegate(delegate_);\n    }', 'contract_name': 'MemecoinDelegatableUpgradeable', 'contract_code': '{\n    error NotDelegatable();\n\n    IMemecoinDelegate private _delegate;\n\n    function __MemecoinDelegatable_init(address delegate_) internal onlyInitializing {\n        __MemecoinDelegatable_init_unchained(delegate_);\n    }\n\n    function __MemecoinDelegatable_init_unchained(address delegate_) internal onlyInitializing {\n        _delegate = IMemecoinDelegate(delegate_);\n    }\n\n    function delegate() external view returns (address) {\n        return address(_delegate);\n    }\n\n    function _delegateTransfer(address to, uint256 amount) internal returns (bool) {\n        return _delegate.transferFrom(_msgSender(), to, amount);\n    }\n\n    function _delegatePermit(bytes calldata _permit) internal {\n        (uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(_permit, (uint256, uint256, uint8, bytes32, bytes32));\n        try IERC20Permit(_delegate.memecoin()).permit(_msgSender(), address(_delegate), value, deadline, v, r, s) {}\n            catch {}\n    }\n\n    modifier onlyDelegatable() {\n        if (!_delegate.isAuthorized(_msgSender())) revert NotDelegatable();\n        _;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinDelegatableUpgradeable.delegate', 'start_line': 23, 'end_line': 25, 'offset_start': 853, 'offset_end': 946, 'content': 'function delegate() external view returns (address) {\n        return address(_delegate);\n    }', 'contract_name': 'MemecoinDelegatableUpgradeable', 'contract_code': '{\n    error NotDelegatable();\n\n    IMemecoinDelegate private _delegate;\n\n    function __MemecoinDelegatable_init(address delegate_) internal onlyInitializing {\n        __MemecoinDelegatable_init_unchained(delegate_);\n    }\n\n    function __MemecoinDelegatable_init_unchained(address delegate_) internal onlyInitializing {\n        _delegate = IMemecoinDelegate(delegate_);\n    }\n\n    function delegate() external view returns (address) {\n        return address(_delegate);\n    }\n\n    function _delegateTransfer(address to, uint256 amount) internal returns (bool) {\n        return _delegate.transferFrom(_msgSender(), to, amount);\n    }\n\n    function _delegatePermit(bytes calldata _permit) internal {\n        (uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(_permit, (uint256, uint256, uint8, bytes32, bytes32));\n        try IERC20Permit(_delegate.memecoin()).permit(_msgSender(), address(_delegate), value, deadline, v, r, s) {}\n            catch {}\n    }\n\n    modifier onlyDelegatable() {\n        if (!_delegate.isAuthorized(_msgSender())) revert NotDelegatable();\n        _;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinDelegatableUpgradeable._delegateTransfer', 'start_line': 27, 'end_line': 29, 'offset_start': 953, 'offset_end': 1103, 'content': 'function _delegateTransfer(address to, uint256 amount) internal returns (bool) {\n        return _delegate.transferFrom(_msgSender(), to, amount);\n    }', 'contract_name': 'MemecoinDelegatableUpgradeable', 'contract_code': '{\n    error NotDelegatable();\n\n    IMemecoinDelegate private _delegate;\n\n    function __MemecoinDelegatable_init(address delegate_) internal onlyInitializing {\n        __MemecoinDelegatable_init_unchained(delegate_);\n    }\n\n    function __MemecoinDelegatable_init_unchained(address delegate_) internal onlyInitializing {\n        _delegate = IMemecoinDelegate(delegate_);\n    }\n\n    function delegate() external view returns (address) {\n        return address(_delegate);\n    }\n\n    function _delegateTransfer(address to, uint256 amount) internal returns (bool) {\n        return _delegate.transferFrom(_msgSender(), to, amount);\n    }\n\n    function _delegatePermit(bytes calldata _permit) internal {\n        (uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(_permit, (uint256, uint256, uint8, bytes32, bytes32));\n        try IERC20Permit(_delegate.memecoin()).permit(_msgSender(), address(_delegate), value, deadline, v, r, s) {}\n            catch {}\n    }\n\n    modifier onlyDelegatable() {\n        if (!_delegate.isAuthorized(_msgSender())) revert NotDelegatable();\n        _;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinDelegatableUpgradeable._delegatePermit', 'start_line': 31, 'end_line': 36, 'offset_start': 1110, 'offset_end': 1465, 'content': 'function _delegatePermit(bytes calldata _permit) internal {\n        (uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(_permit, (uint256, uint256, uint8, bytes32, bytes32));\n        try IERC20Permit(_delegate.memecoin()).permit(_msgSender(), address(_delegate), value, deadline, v, r, s) {}\n            catch {}\n    }', 'contract_name': 'MemecoinDelegatableUpgradeable', 'contract_code': '{\n    error NotDelegatable();\n\n    IMemecoinDelegate private _delegate;\n\n    function __MemecoinDelegatable_init(address delegate_) internal onlyInitializing {\n        __MemecoinDelegatable_init_unchained(delegate_);\n    }\n\n    function __MemecoinDelegatable_init_unchained(address delegate_) internal onlyInitializing {\n        _delegate = IMemecoinDelegate(delegate_);\n    }\n\n    function delegate() external view returns (address) {\n        return address(_delegate);\n    }\n\n    function _delegateTransfer(address to, uint256 amount) internal returns (bool) {\n        return _delegate.transferFrom(_msgSender(), to, amount);\n    }\n\n    function _delegatePermit(bytes calldata _permit) internal {\n        (uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(_permit, (uint256, uint256, uint8, bytes32, bytes32));\n        try IERC20Permit(_delegate.memecoin()).permit(_msgSender(), address(_delegate), value, deadline, v, r, s) {}\n            catch {}\n    }\n\n    modifier onlyDelegatable() {\n        if (!_delegate.isAuthorized(_msgSender())) revert NotDelegatable();\n        _;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 86, 'end_line': 88, 'offset_start': 3191, 'offset_end': 3350, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 94, 'end_line': 96, 'offset_start': 3590, 'offset_end': 3777, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 102, 'end_line': 105, 'offset_start': 3969, 'offset_end': 4193, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 111, 'end_line': 119, 'offset_start': 4397, 'offset_end': 4864, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 126, 'end_line': 133, 'offset_start': 5184, 'offset_end': 5563, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 141, 'end_line': 150, 'offset_start': 5947, 'offset_end': 6575, 'content': "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 160, 'end_line': 167, 'offset_start': 7077, 'offset_end': 7654, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeacon.implementation', 'start_line': 184, 'end_line': 184, 'offset_start': 8070, 'offset_end': 8127, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeacon', 'contract_code': '{\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verify', 'start_line': 218, 'end_line': 220, 'offset_start': 9397, 'offset_end': 9550, 'content': 'function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verifyCalldata', 'start_line': 225, 'end_line': 227, 'offset_start': 9614, 'offset_end': 9785, 'content': 'function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProof', 'start_line': 235, 'end_line': 241, 'offset_start': 10099, 'offset_end': 10388, 'content': 'function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProofCalldata', 'start_line': 246, 'end_line': 252, 'offset_start': 10458, 'offset_end': 10757, 'content': 'function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerify', 'start_line': 260, 'end_line': 267, 'offset_start': 11081, 'offset_end': 11338, 'content': 'function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerifyCalldata', 'start_line': 274, 'end_line': 281, 'offset_start': 11512, 'offset_end': 11789, 'content': 'function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProof', 'start_line': 293, 'end_line': 342, 'offset_start': 12531, 'offset_end': 14812, 'content': 'function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProofCalldata', 'start_line': 349, 'end_line': 398, 'offset_start': 14988, 'offset_end': 17281, 'content': 'function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._hashPair', 'start_line': 403, 'end_line': 405, 'offset_start': 17361, 'offset_end': 17507, 'content': 'function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._efficientHash', 'start_line': 410, 'end_line': 417, 'offset_start': 17628, 'offset_end': 17888, 'content': 'function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinDelegate.memecoin', 'start_line': 424, 'end_line': 424, 'offset_start': 17986, 'offset_end': 18037, 'content': 'function memecoin() external view returns (address);', 'contract_name': 'IMemecoinDelegate', 'contract_code': '{\n    function memecoin() external view returns (address);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function allowance(address user) external view returns (uint256);\n    function isAuthorized(address addr) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinDelegate.transferFrom', 'start_line': 425, 'end_line': 425, 'offset_start': 18043, 'offset_end': 18130, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IMemecoinDelegate', 'contract_code': '{\n    function memecoin() external view returns (address);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function allowance(address user) external view returns (uint256);\n    function isAuthorized(address addr) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinDelegate.allowance', 'start_line': 426, 'end_line': 426, 'offset_start': 18136, 'offset_end': 18200, 'content': 'function allowance(address user) external view returns (uint256);', 'contract_name': 'IMemecoinDelegate', 'contract_code': '{\n    function memecoin() external view returns (address);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function allowance(address user) external view returns (uint256);\n    function isAuthorized(address addr) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinDelegate.isAuthorized', 'start_line': 427, 'end_line': 427, 'offset_start': 18206, 'offset_end': 18270, 'content': 'function isAuthorized(address addr) external view returns (bool);', 'contract_name': 'IMemecoinDelegate', 'contract_code': '{\n    function memecoin() external view returns (address);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function allowance(address user) external view returns (uint256);\n    function isAuthorized(address addr) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20TokenTracker.name', 'start_line': 439, 'end_line': 439, 'offset_start': 18545, 'offset_end': 18598, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC20TokenTracker', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address user) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20TokenTracker.symbol', 'start_line': 440, 'end_line': 440, 'offset_start': 18604, 'offset_end': 18659, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC20TokenTracker', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address user) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20TokenTracker.decimals', 'start_line': 441, 'end_line': 441, 'offset_start': 18665, 'offset_end': 18714, 'content': 'function decimals() external view returns (uint8);', 'contract_name': 'IERC20TokenTracker', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address user) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20TokenTracker.balanceOf', 'start_line': 442, 'end_line': 442, 'offset_start': 18720, 'offset_end': 18784, 'content': 'function balanceOf(address user) external view returns (uint256);', 'contract_name': 'IERC20TokenTracker', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address user) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20TokenTracker.totalSupply', 'start_line': 443, 'end_line': 443, 'offset_start': 18790, 'offset_end': 18844, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20TokenTracker', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address user) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 463, 'end_line': 464, 'offset_start': 19597, 'offset_end': 19655, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 466, 'end_line': 467, 'offset_start': 19662, 'offset_end': 19730, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 468, 'end_line': 470, 'offset_start': 19736, 'offset_end': 19831, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 472, 'end_line': 474, 'offset_start': 19838, 'offset_end': 19936, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 476, 'end_line': 478, 'offset_start': 19943, 'offset_end': 20039, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getImplementation', 'start_line': 542, 'end_line': 544, 'offset_start': 22001, 'offset_end': 22138, 'content': 'function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setImplementation', 'start_line': 549, 'end_line': 554, 'offset_start': 22230, 'offset_end': 22510, 'content': 'function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeToAndCall', 'start_line': 563, 'end_line': 572, 'offset_start': 22823, 'offset_end': 23157, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getAdmin', 'start_line': 588, 'end_line': 590, 'offset_start': 23836, 'offset_end': 23955, 'content': 'function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setAdmin', 'start_line': 595, 'end_line': 600, 'offset_start': 24038, 'offset_end': 24254, 'content': 'function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.changeAdmin', 'start_line': 607, 'end_line': 610, 'offset_start': 24375, 'offset_end': 24507, 'content': 'function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getBeacon', 'start_line': 622, 'end_line': 624, 'offset_start': 24954, 'offset_end': 25075, 'content': 'function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setBeacon', 'start_line': 629, 'end_line': 640, 'offset_start': 25158, 'offset_end': 25594, 'content': 'function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeBeaconToAndCall', 'start_line': 653, 'end_line': 662, 'offset_start': 26120, 'offset_end': 26452, 'content': 'function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._checkNonPayable', 'start_line': 668, 'end_line': 672, 'offset_start': 26642, 'offset_end': 26763, 'content': 'function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking._authorizeUpgrade', 'start_line': 716, 'end_line': 716, 'offset_start': 28483, 'offset_end': 28551, 'content': 'function _authorizeUpgrade(address) internal override onlyUpgrader {}', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.tor', 'start_line': 719, 'end_line': 721, 'offset_start': 28611, 'offset_end': 28663, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.initialize', 'start_line': 723, 'end_line': 732, 'offset_start': 28670, 'offset_end': 29130, 'content': 'function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.stake', 'start_line': 739, 'end_line': 747, 'offset_start': 29253, 'offset_end': 29562, 'content': 'function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.stakeFor', 'start_line': 750, 'end_line': 758, 'offset_start': 29606, 'offset_end': 29849, 'content': 'function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None, None, None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.unstake', 'start_line': 761, 'end_line': 769, 'offset_start': 29893, 'offset_end': 30175, 'content': 'function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking._stake', 'start_line': 775, 'end_line': 785, 'offset_start': 30291, 'offset_end': 30653, 'content': 'function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking._unstake', 'start_line': 787, 'end_line': 797, 'offset_start': 30660, 'offset_end': 31070, 'content': 'function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking._redeemRewards', 'start_line': 804, 'end_line': 821, 'offset_start': 31293, 'offset_end': 32020, 'content': 'function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking._verifyProof', 'start_line': 830, 'end_line': 838, 'offset_start': 32297, 'offset_end': 32631, 'content': 'function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.stakeRewards', 'start_line': 864, 'end_line': 872, 'offset_start': 33257, 'offset_end': 33711, 'content': 'function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.setStakingActive', 'start_line': 875, 'end_line': 879, 'offset_start': 33755, 'offset_end': 33901, 'content': 'function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.setStakingStartDate', 'start_line': 882, 'end_line': 887, 'offset_start': 33945, 'offset_end': 34143, 'content': 'function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.setUpgrader', 'start_line': 893, 'end_line': 899, 'offset_start': 34299, 'offset_end': 34557, 'content': 'function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.renounceUpgrader', 'start_line': 904, 'end_line': 911, 'offset_start': 34676, 'offset_end': 34897, 'content': 'function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.totalSupply', 'start_line': 920, 'end_line': 922, 'offset_start': 35023, 'offset_end': 35134, 'content': 'function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.stakeOf', 'start_line': 925, 'end_line': 939, 'offset_start': 35178, 'offset_end': 35791, 'content': 'function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'MemecoinStaking.getRewardRedeemedAt', 'start_line': 942, 'end_line': 944, 'offset_start': 35835, 'offset_end': 35989, 'content': 'function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }', 'contract_name': 'MemecoinStaking', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant _MINIMUM_AMOUNT = 1e18;\n\n    IERC20 public memecoin;\n    bool public stakingActive;\n    bool public upgraderRenounced;\n    uint64 public stakingStartDate;\n\n    address public upgrader; // to be set\n\n    mapping(address user => uint256 balance) public balanceOf;\n    mapping(uint256 rewardId => bytes32 merkleRoot) public rewardsMerkleRoots;\n    mapping(address user => mapping(uint256 rewardId => uint256 redeemedAt)) private _usersRewardRedeemedAt;\n\n    string public constant name = "Staked Memecoin";\n    string public constant symbol = "";\n    uint8 public constant decimals = 18;\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _memecoin, address _delegate) external initializer {\n        if (_memecoin == address(0) || _delegate == address(0)) revert InvalidAddress();\n\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        MemecoinDelegatableUpgradeable.__MemecoinDelegatable_init(_delegate);\n\n        memecoin = IERC20(_memecoin);\n    }\n\n    // ==================\n    // External Functions\n    // ==================\n\n    /// @inheritdoc IMemecoinStaking\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _stake(_msgSender(), amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeFor(address user, uint256 amount, bytes calldata permit)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n        onlyDelegatable\n    {\n        _stake(user, amount, permit);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function unstake(uint256 amount, Reward[] calldata rewards)\n        external\n        nonReentrant\n        onlyValidStakingSetup\n        onlyValidAmount(amount)\n    {\n        if (rewards.length != 0) _redeemRewards(_msgSender(), rewards);\n        _unstake(_msgSender(), amount);\n    }\n\n    // ============================\n    // Internal & Private Functions\n    // ============================\n\n    function _stake(address user, uint256 amount, bytes calldata permit) private {\n        if (permit.length != 0) _delegatePermit(permit);\n\n        unchecked {\n            balanceOf[user] += amount;\n        }\n        _delegateTransfer(address(this), amount);\n        emit Transfer(address(0), user, amount);\n\n        emit Staked(user, amount, block.timestamp);\n    }\n\n    function _unstake(address user, uint256 amount) private {\n        uint256 userBalance = balanceOf[user];\n        if (userBalance < amount) revert InsufficientStakedBalance();\n        unchecked {\n            balanceOf[user] = userBalance - amount;\n        }\n        memecoin.safeTransfer(user, amount);\n        emit Transfer(user, address(0), amount);\n\n        emit Unstaked(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeem and stake user\'s unredeemed rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards\n     */\n    function _redeemRewards(address user, Reward[] calldata rewards) private {\n        for (uint256 i; i < rewards.length; i++) {\n            Reward calldata reward = rewards[i];\n            uint256 rewardId = reward.rewardId;\n\n            if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n\n            uint256 amount = reward.amount;\n            if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n            unchecked {\n                balanceOf[user] += amount;\n            }\n            emit Transfer(address(this), user, amount);\n            _usersRewardRedeemedAt[user][rewardId] = block.timestamp;\n            emit RewardRedeemed(user, rewardId, amount, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified rewardId\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     * @param amount The amount of reward\n     * @param merkleProof The Merkle proof to be verified\n     */\n    function _verifyProof(address user, uint256 rewardId, uint256 amount, bytes32[] calldata merkleProof)\n        private\n        view\n        returns (bool)\n    {\n        return MerkleProof.verifyCalldata(\n            merkleProof, rewardsMerkleRoots[rewardId], keccak256(bytes.concat(keccak256(abi.encode(user, amount))))\n        );\n    }\n\n    // ====================\n    // Validation Modifiers\n    // ====================\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyValidStakingSetup() {\n        if (!stakingActive || stakingStartDate == 0 || block.timestamp < stakingStartDate) revert StakingNotAvailable();\n        _;\n    }\n\n    modifier onlyValidAmount(uint256 amount) {\n        if (amount == 0 || amount < _MINIMUM_AMOUNT) revert InvalidAmount();\n        _;\n    }\n\n    // ==============\n    // Admin Functions\n    // ==============\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external onlyOwner {\n        if (depositor == address(0) || amount == 0 || root == bytes32(0)) revert InvalidStakingSetup();\n\n        rewardsMerkleRoots[rewardId] = root;\n        memecoin.safeTransferFrom(depositor, address(this), amount);\n        emit Transfer(address(0), address(this), amount);\n\n        emit RewardStaked(rewardId, amount, block.timestamp);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingActive(bool isActive) external onlyOwner {\n        stakingActive = isActive;\n\n        emit StakingStatusUpdated(isActive);\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function setStakingStartDate(uint64 _stakingStartDate) external onlyOwner {\n        stakingActive = true;\n        stakingStartDate = _stakingStartDate;\n\n        emit StakingStatusUpdated(true);\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param _upgrader The address of new upgrader\n     */\n    function setUpgrader(address _upgrader) external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n        if (_upgrader == address(0)) revert InvalidAddress();\n        upgrader = _upgrader;\n\n        emit UpgraderUpdated(_upgrader);\n    }\n\n    /**\n     * @notice Renounce the upgradibility of staking contract. Can only be called by the owner.\n     */\n    function renounceUpgrader() external onlyOwner {\n        if (upgraderRenounced) revert UpgraderRenounced();\n\n        upgraderRenounced = true;\n        upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n\n    // ==============\n    // Getters\n    // ==============\n\n    /**\n     * @notice Get the total staked amount\n     */\n    function totalSupply() external view returns (uint256) {\n        return memecoin.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance) {\n        balance = balanceOf[user];\n        if (rewards.length != 0) {\n            for (uint256 i; i < rewards.length; i++) {\n                Reward calldata reward = rewards[i];\n                uint256 amount = reward.amount;\n                uint256 rewardId = reward.rewardId;\n\n                if (_usersRewardRedeemedAt[user][rewardId] > 0) continue;\n                if (!_verifyProof(user, rewardId, amount, reward.proof)) revert InvalidProof();\n\n                balance += amount;\n            }\n        }\n    }\n\n    /// @inheritdoc IMemecoinStaking\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256) {\n        return _usersRewardRedeemedAt[user][rewardId];\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 1012, 'end_line': 1020, 'offset_start': 38991, 'offset_end': 39173, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 1029, 'end_line': 1029, 'offset_start': 39479, 'offset_end': 39541, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 1035, 'end_line': 1035, 'offset_start': 39734, 'offset_end': 39793, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1078, 'end_line': 1087, 'offset_start': 41329, 'offset_end': 41659, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1107, 'end_line': 1109, 'offset_start': 42503, 'offset_end': 42653, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1120, 'end_line': 1126, 'offset_start': 42978, 'offset_end': 43369, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1132, 'end_line': 1135, 'offset_start': 43509, 'offset_end': 43762, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1141, 'end_line': 1144, 'offset_start': 43904, 'offset_end': 44156, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1151, 'end_line': 1166, 'offset_start': 44423, 'offset_end': 45004, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1172, 'end_line': 1178, 'offset_start': 45205, 'offset_end': 45428, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1183, 'end_line': 1195, 'offset_start': 45541, 'offset_end': 46056, 'content': 'function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.stake', 'start_line': 1232, 'end_line': 1232, 'offset_start': 47384, 'offset_end': 47473, 'content': 'function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.stakeFor', 'start_line': 1240, 'end_line': 1240, 'offset_start': 47701, 'offset_end': 47780, 'content': 'function stakeFor(address user, uint256 amount, bytes calldata permit) external;', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.unstake', 'start_line': 1247, 'end_line': 1247, 'offset_start': 48173, 'offset_end': 48241, 'content': 'function unstake(uint256 amount, Reward[] calldata rewards) external;', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.stakeRewards', 'start_line': 1256, 'end_line': 1256, 'offset_start': 48575, 'offset_end': 48672, 'content': 'function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.setStakingActive', 'start_line': 1262, 'end_line': 1262, 'offset_start': 48827, 'offset_end': 48876, 'content': 'function setStakingActive(bool isActive) external;', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.setStakingStartDate', 'start_line': 1268, 'end_line': 1268, 'offset_start': 49029, 'offset_end': 49092, 'content': 'function setStakingStartDate(uint64 _stakingStartDate) external;', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.stakeOf', 'start_line': 1275, 'end_line': 1275, 'offset_start': 49351, 'offset_end': 49448, 'content': 'function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IMemecoinStaking.getRewardRedeemedAt', 'start_line': 1282, 'end_line': 1282, 'offset_start': 49655, 'offset_end': 49747, 'content': 'function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);', 'contract_name': 'IMemecoinStaking', 'contract_code': "{\n    struct Reward {\n        uint256 rewardId;\n        uint256 amount;\n        bytes32[] proof;\n    }\n\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidProof();\n    error InvalidStakingSetup();\n    error InsufficientStakedBalance();\n    error StakingNotAvailable();\n    error Unauthorized();\n    error UpgraderRenounced();\n\n    event Staked(address indexed user, uint256 amount, uint256 stakedAt);\n    event Unstaked(address indexed user, uint256 amount, uint256 unstakedAt);\n    event RewardRedeemed(address user, uint256 rewardId, uint256 amount, uint256 redeemedAt);\n    event RewardStaked(uint256 rewardId, uint256 amount, uint256 stakedAt);\n    event StakingStatusUpdated(bool isActive);\n    event UpgraderUpdated(address _upgrader);\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be staked. Input an empty array if no rewards are intended to be redeemed and staked\n     * @param permit Encoded permit data\n     */\n    function stake(uint256 amount, Reward[] calldata rewards, bytes calldata permit) external;\n\n    /**\n     * @notice Stake MEME into staking contract\n     * @param user The address to stake MEME to\n     * @param amount The amount of MEME to stake from user's wallet\n     * @param permit Encoded permit data\n     */\n    function stakeFor(address user, uint256 amount, bytes calldata permit) external;\n\n    /**\n     * @notice Unstake MEME from staking contract\n     * @param amount The total amount of MEME to unstake from staked balance and any unredeemed rewards\n     * @param rewards Array of Rewards (rewardId, amount, and proof) for verifying any unredeemed rewards that are intended to be unstaked. Input an empty array if no rewards are intended to be redeemed and unstaked\n     */\n    function unstake(uint256 amount, Reward[] calldata rewards) external;\n\n    /**\n     * @notice Stake rewards with specified address of depositor. Can only be called by the owner.\n     * @param depositor The address to stake MEME as rewards\n     * @param rewardId The ID of reward\n     * @param amount The amount of rewards to stake\n     * @param root The Merkle root to verify users' reward\n     */\n    function stakeRewards(address depositor, uint256 rewardId, uint256 amount, bytes32 root) external;\n\n    /**\n     * @notice Pause/unpause staking. Can only be called by the owner.\n     * @param isActive New boolean to indicate active or not\n     */\n    function setStakingActive(bool isActive) external;\n\n    /**\n     * @notice Set the staking start date and set staking as active\n     * @param _stakingStartDate The date where staking starts\n     */\n    function setStakingStartDate(uint64 _stakingStartDate) external;\n\n    /**\n     * @notice Get user staked balance plus any unredeemed rewards, given valid proofs of rewards\n     * @param user The address of user\n     * @param rewards Array of Rewards (rewardId, amount and proof) to verify any undeemed rewards\n     */\n    function stakeOf(address user, Reward[] calldata rewards) external view returns (uint256 balance);\n\n    /**\n     * @notice Get the timestamp of when the reward was redeemed. Returns 0 if it has not been redeemed.\n     * @param user The address of user\n     * @param rewardId The ID of reward\n     */\n    function getRewardRedeemedAt(address user, uint256 rewardId) external view returns (uint256);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822Proxiable.proxiableUUID', 'start_line': 1303, 'end_line': 1303, 'offset_start': 50572, 'offset_end': 50628, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822Proxiable', 'contract_code': '{\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1332, 'end_line': 1332, 'offset_start': 51407, 'offset_end': 51461, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1337, 'end_line': 1337, 'offset_start': 51544, 'offset_end': 51611, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1346, 'end_line': 1346, 'offset_start': 51836, 'offset_end': 51904, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1355, 'end_line': 1355, 'offset_start': 52180, 'offset_end': 52262, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 1372, 'end_line': 1372, 'offset_start': 52941, 'offset_end': 53013, 'content': 'function approve(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 1383, 'end_line': 1383, 'offset_start': 53322, 'offset_end': 53408, 'content': 'function transferFrom(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 1444, 'end_line': 1449, 'offset_start': 55097, 'offset_end': 55286, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 1454, 'end_line': 1459, 'offset_start': 55385, 'offset_end': 55574, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 1464, 'end_line': 1469, 'offset_start': 55673, 'offset_end': 55862, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 1474, 'end_line': 1479, 'offset_start': 55961, 'offset_end': 56150, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1484, 'end_line': 1489, 'offset_start': 56248, 'offset_end': 56435, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1494, 'end_line': 1499, 'offset_start': 56548, 'offset_end': 56749, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1504, 'end_line': 1509, 'offset_start': 56846, 'offset_end': 57031, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1514, 'end_line': 1519, 'offset_start': 57142, 'offset_end': 57340, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._getOwnableStorage', 'start_line': 1551, 'end_line': 1555, 'offset_start': 58537, 'offset_end': 58695, 'content': 'function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 1572, 'end_line': 1574, 'offset_start': 59192, 'offset_end': 59318, 'content': 'function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 1576, 'end_line': 1581, 'offset_start': 59325, 'offset_end': 59559, 'content': 'function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 1594, 'end_line': 1597, 'offset_start': 59786, 'offset_end': 59929, 'content': 'function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 1602, 'end_line': 1606, 'offset_start': 60003, 'offset_end': 60164, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 1615, 'end_line': 1617, 'offset_start': 60500, 'offset_end': 60600, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 1623, 'end_line': 1628, 'offset_start': 60750, 'offset_end': 60964, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 1634, 'end_line': 1639, 'offset_start': 61119, 'offset_end': 61366, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 1706, 'end_line': 1707, 'offset_start': 64341, 'offset_end': 64407, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 1709, 'end_line': 1710, 'offset_start': 64414, 'offset_end': 64490, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 1719, 'end_line': 1721, 'offset_start': 65078, 'offset_end': 65211, 'content': 'function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 1733, 'end_line': 1736, 'offset_start': 65531, 'offset_end': 65744, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkProxy', 'start_line': 1743, 'end_line': 1750, 'offset_start': 65972, 'offset_end': 66283, 'content': 'function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkNotDelegated', 'start_line': 1756, 'end_line': 1761, 'offset_start': 66401, 'offset_end': 66613, 'content': 'function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 1773, 'end_line': 1773, 'offset_start': 66997, 'offset_end': 67067, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._upgradeToAndCallUUPS', 'start_line': 1783, 'end_line': 1793, 'offset_start': 67425, 'offset_end': 67962, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._getReentrancyGuardStorage', 'start_line': 1841, 'end_line': 1845, 'offset_start': 70218, 'offset_end': 70400, 'content': 'function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1852, 'end_line': 1854, 'offset_start': 70507, 'offset_end': 70617, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1856, 'end_line': 1859, 'offset_start': 70624, 'offset_end': 70806, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1874, 'end_line': 1883, 'offset_start': 71293, 'offset_end': 71676, 'content': 'function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1885, 'end_line': 1890, 'offset_start': 71683, 'offset_end': 71965, 'content': 'function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1896, 'end_line': 1899, 'offset_start': 72145, 'offset_end': 72325, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 2079, 'end_line': 2083, 'offset_start': 79414, 'offset_end': 79554, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 2093, 'end_line': 2104, 'offset_start': 80041, 'offset_end': 80462, 'content': 'function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 2109, 'end_line': 2111, 'offset_start': 80573, 'offset_end': 80700, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 2116, 'end_line': 2118, 'offset_start': 80817, 'offset_end': 80936, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 2124, 'end_line': 2128, 'offset_start': 81067, 'offset_end': 81236, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce/0xc059a531b4234d05e9ef4ac51028f7e6156e2cce.sol'}
