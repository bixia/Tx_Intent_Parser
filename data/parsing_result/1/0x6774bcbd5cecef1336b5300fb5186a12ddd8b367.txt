{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.tor', 'start_line': 93, 'end_line': 106, 'offset_start': 3615, 'offset_end': 3974, 'content': 'constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.initialize', 'start_line': 116, 'end_line': 129, 'offset_start': 4452, 'offset_end': 4836, 'content': 'function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.sendMessage', 'start_line': 136, 'end_line': 143, 'offset_start': 4987, 'offset_end': 5233, 'content': 'function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.sendMessage', 'start_line': 146, 'end_line': 154, 'offset_start': 5277, 'offset_end': 5559, 'content': 'function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.relayMessageWithProof', 'start_line': 157, 'end_line': 195, 'offset_start': 5605, 'offset_end': 7270, 'content': 'function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.replayMessage', 'start_line': 198, 'end_line': 259, 'offset_start': 7316, 'offset_end': 10159, 'content': 'function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None, None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.dropMessage', 'start_line': 262, 'end_line': 311, 'offset_start': 10205, 'offset_end': 12445, 'content': 'function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger.updateMaxReplayTimes', 'start_line': 320, 'end_line': 325, 'offset_start': 12707, 'offset_end': 12964, 'content': 'function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ScrollMessenger._sendMessage', 'start_line': 331, 'end_line': 370, 'offset_start': 13057, 'offset_end': 14836, 'content': 'function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }', 'contract_name': 'L1ScrollMessenger', 'contract_code': '{\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of Rollup contract.\n    address public immutable rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to the timestamp when the message is sent.\n    mapping(bytes32 => uint256) public messageSendTimestamp;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @dev The storage slot used as Rollup contract, which is deprecated now.\n    address private __rollup;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _counterpart,\n        address _rollup,\n        address _messageQueue\n    ) ScrollMessengerBase(_counterpart) {\n        if (_rollup == address(0) || _messageQueue == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    ///\n    /// @dev The parameters `_counterpart`, `_rollup` and `_messageQueue` are no longer used.\n    ///\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        ScrollMessengerBase.__ScrollMessengerBase_init(_counterpart, _feeVault);\n\n        __rollup = _rollup;\n        __messageQueue = _messageQueue;\n\n        maxReplayTimes = 3;\n        emit UpdateMaxReplayTimes(0, 3);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], "Message was already successfully executed");\n\n        {\n            require(IScrollChain(rollup).isBatchFinalized(_proof.batchIndex), "Batch is not finalized");\n            bytes32 _messageRoot = IScrollChain(rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                "Invalid proof"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, "Forbid to call message queue");\n        _validateTargetAddress(_to);\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, "Invalid message sender");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` on layer 2 to avoid duplicated execution.\n        // So, only one message will succeed on layer 2. If one of the message is executed successfully, the other one\n        // will revert with "Message was already successfully executed".\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, "Insufficient msg.value for fee");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, "Exceed maximum replay times");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(messageSendTimestamp[_xDomainCalldataHash] > 0, "Provided message has not been enqueued");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], "Message already dropped");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _newMaxReplayTimes) external onlyOwner {\n        uint256 _oldMaxReplayTimes = maxReplayTimes;\n        maxReplayTimes = _newMaxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_oldMaxReplayTimes, _newMaxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_msgSender(), _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, "Insufficient msg.value");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}("");\n            require(_success, "Failed to deduct the fee");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(messageQueue).appendCrossDomainMessage(counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won\'t happen, since each message has different nonce, but just in case.\n        require(messageSendTimestamp[_xDomainCalldataHash] == 0, "Duplicated message");\n        messageSendTimestamp[_xDomainCalldataHash] = block.timestamp;\n\n        emit SentMessage(_msgSender(), _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}("");\n                require(_success, "Failed to refund the fee");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init', 'start_line': 406, 'end_line': 408, 'offset_start': 15904, 'offset_end': 16000, 'content': 'function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init_unchained', 'start_line': 410, 'end_line': 412, 'offset_start': 16007, 'offset_end': 16101, 'content': 'function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.paused', 'start_line': 441, 'end_line': 443, 'offset_start': 16699, 'offset_end': 16782, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requireNotPaused', 'start_line': 448, 'end_line': 450, 'offset_start': 16851, 'offset_end': 16956, 'content': 'function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requirePaused', 'start_line': 455, 'end_line': 457, 'offset_start': 17029, 'offset_end': 17134, 'content': 'function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._pause', 'start_line': 466, 'end_line': 469, 'offset_start': 17270, 'offset_end': 17384, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._unpause', 'start_line': 478, 'end_line': 481, 'offset_start': 17517, 'offset_end': 17633, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 635, 'end_line': 641, 'offset_start': 23868, 'offset_end': 24147, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 646, 'end_line': 648, 'offset_start': 24258, 'offset_end': 24357, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 653, 'end_line': 655, 'offset_start': 24474, 'offset_end': 24566, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollMessenger.xDomainMessageSender', 'start_line': 703, 'end_line': 703, 'offset_start': 26035, 'offset_end': 26098, 'content': 'function xDomainMessageSender() external view returns (address);', 'contract_name': 'IScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollMessenger.sendMessage', 'start_line': 714, 'end_line': 719, 'offset_start': 26573, 'offset_end': 26721, 'content': 'function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;', 'contract_name': 'IScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollMessenger.sendMessage', 'start_line': 727, 'end_line': 733, 'offset_start': 27176, 'offset_end': 27355, 'content': 'function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;', 'contract_name': 'IScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase.tor', 'start_line': 819, 'end_line': 825, 'offset_start': 29976, 'offset_end': 30144, 'content': 'constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase.__ScrollMessengerBase_init', 'start_line': 827, 'end_line': 838, 'offset_start': 30151, 'offset_end': 30605, 'content': 'function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase.', 'start_line': 841, 'end_line': 841, 'offset_start': 30702, 'offset_end': 30740, 'content': 'receive() external payable onlyOwner {}', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase.updateFeeVault', 'start_line': 850, 'end_line': 855, 'offset_start': 31011, 'offset_end': 31214, 'content': 'function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase.setPause', 'start_line': 860, 'end_line': 866, 'offset_start': 31369, 'offset_end': 31522, 'content': 'function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase._encodeXDomainCalldata', 'start_line': 879, 'end_line': 895, 'offset_start': 32029, 'offset_end': 32514, 'content': 'function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ScrollMessengerBase._validateTargetAddress', 'start_line': 899, 'end_line': 903, 'offset_start': 32682, 'offset_end': 32931, 'content': 'function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }', 'contract_name': 'ScrollMessengerBase', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public immutable counterpart;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @dev The storage slot used as counterpart ScrollMessenger contract, which is deprecated now.\n    address private __counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    /// @dev The storage slot used as ETH rate limiter contract, which is deprecated now.\n    address private __rateLimiter;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            "Message is already in execution"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _counterpart) {\n        if (_counterpart == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        counterpart = _counterpart;\n    }\n\n    function __ScrollMessengerBase_init(address, address _feeVault) internal onlyInitializing {\n        OwnableUpgradeable.__Ownable_init();\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (_feeVault != address(0)) {\n            feeVault = _feeVault;\n        }\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                "relayMessage(address,address,uint256,uint256,bytes)",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n\n    /// @dev Internal function to check whether the `_target` address is allowed to avoid attack.\n    /// @param _target The address of target address to check.\n    function _validateTargetAddress(address _target) internal view {\n        // @note check more `_target` address to avoid attack in the future when we add more external contracts.\n\n        require(_target != address(this), "Forbid to call self");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IMessageDropCallback.onDropMessage', 'start_line': 911, 'end_line': 911, 'offset_start': 33032, 'offset_end': 33093, 'content': 'function onDropMessage(bytes memory message) external payable;', 'contract_name': 'IMessageDropCallback', 'contract_code': '{\n    function onDropMessage(bytes memory message) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'WithdrawTrieVerifier.verifyMerkleProof', 'start_line': 935, 'end_line': 957, 'offset_start': 34132, 'offset_end': 34826, 'content': 'function verifyMerkleProof(\n        bytes32 _root,\n        bytes32 _hash,\n        uint256 _nonce,\n        bytes memory _proof\n    ) internal pure returns (bool) {\n        require(_proof.length % 32 == 0, "Invalid proof");\n        uint256 _length = _proof.length / 32;\n\n        for (uint256 i = 0; i < _length; i++) {\n            bytes32 item;\n            assembly {\n                item := mload(add(add(_proof, 0x20), mul(i, 0x20)))\n            }\n            if (_nonce % 2 == 0) {\n                _hash = _efficientHash(_hash, item);\n            } else {\n                _hash = _efficientHash(item, _hash);\n            }\n            _nonce /= 2;\n        }\n        return _hash == _root;\n    }', 'contract_name': 'WithdrawTrieVerifier', 'contract_code': '{\n    /// @dev Verify the merkle proof given root, leaf node and proof.\n    ///\n    /// Vulnerability:\n    ///   The initially provided message hash can be hashed with the first hash of the proof,\n    ///   thereby giving an intermediate node of the trie. This can then be used with a shortened\n    ///   proof to pass the verification, which may lead to replayability.\n    ///\n    ///   However, it is designed to verify the withdraw trie in `L2MessageQueue`. The `_hash` given\n    ///   in the parameter is always a leaf node. So we assume the length of proof is correct and\n    ///   cannot be shortened.\n    /// @param _root The expected root node hash of the withdraw trie.\n    /// @param _hash The leaf node hash of the withdraw trie.\n    /// @param _nonce The index of the leaf node from left to right, starting from 0.\n    /// @param _proof The concatenated merkle proof verified the leaf node.\n    function verifyMerkleProof(\n        bytes32 _root,\n        bytes32 _hash,\n        uint256 _nonce,\n        bytes memory _proof\n    ) internal pure returns (bool) {\n        require(_proof.length % 32 == 0, "Invalid proof");\n        uint256 _length = _proof.length / 32;\n\n        for (uint256 i = 0; i < _length; i++) {\n            bytes32 item;\n            assembly {\n                item := mload(add(add(_proof, 0x20), mul(i, 0x20)))\n            }\n            if (_nonce % 2 == 0) {\n                _hash = _efficientHash(_hash, item);\n            } else {\n                _hash = _efficientHash(item, _hash);\n            }\n            _nonce /= 2;\n        }\n        return _hash == _root;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'WithdrawTrieVerifier._efficientHash', 'start_line': 959, 'end_line': 966, 'offset_start': 34833, 'offset_end': 35106, 'content': 'function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'WithdrawTrieVerifier', 'contract_code': '{\n    /// @dev Verify the merkle proof given root, leaf node and proof.\n    ///\n    /// Vulnerability:\n    ///   The initially provided message hash can be hashed with the first hash of the proof,\n    ///   thereby giving an intermediate node of the trie. This can then be used with a shortened\n    ///   proof to pass the verification, which may lead to replayability.\n    ///\n    ///   However, it is designed to verify the withdraw trie in `L2MessageQueue`. The `_hash` given\n    ///   in the parameter is always a leaf node. So we assume the length of proof is correct and\n    ///   cannot be shortened.\n    /// @param _root The expected root node hash of the withdraw trie.\n    /// @param _hash The leaf node hash of the withdraw trie.\n    /// @param _nonce The index of the leaf node from left to right, starting from 0.\n    /// @param _proof The concatenated merkle proof verified the leaf node.\n    function verifyMerkleProof(\n        bytes32 _root,\n        bytes32 _hash,\n        uint256 _nonce,\n        bytes memory _proof\n    ) internal pure returns (bool) {\n        require(_proof.length % 32 == 0, "Invalid proof");\n        uint256 _length = _proof.length / 32;\n\n        for (uint256 i = 0; i < _length; i++) {\n            bytes32 item;\n            assembly {\n                item := mload(add(add(_proof, 0x20), mul(i, 0x20)))\n            }\n            if (_nonce % 2 == 0) {\n                _hash = _efficientHash(_hash, item);\n            } else {\n                _hash = _efficientHash(item, _hash);\n            }\n            _nonce /= 2;\n        }\n        return _hash == _root;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.lastFinalizedBatchIndex', 'start_line': 1007, 'end_line': 1007, 'offset_start': 36394, 'offset_end': 36460, 'content': 'function lastFinalizedBatchIndex() external view returns (uint256);', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.committedBatches', 'start_line': 1011, 'end_line': 1011, 'offset_start': 36577, 'offset_end': 36654, 'content': 'function committedBatches(uint256 batchIndex) external view returns (bytes32);', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.finalizedStateRoots', 'start_line': 1015, 'end_line': 1015, 'offset_start': 36771, 'offset_end': 36851, 'content': 'function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.withdrawRoots', 'start_line': 1019, 'end_line': 1019, 'offset_start': 36970, 'offset_end': 37044, 'content': 'function withdrawRoots(uint256 batchIndex) external view returns (bytes32);', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.isBatchFinalized', 'start_line': 1023, 'end_line': 1023, 'offset_start': 37171, 'offset_end': 37245, 'content': 'function isBatchFinalized(uint256 batchIndex) external view returns (bool);', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.commitBatch', 'start_line': 1035, 'end_line': 1040, 'offset_start': 37768, 'offset_end': 37946, 'content': 'function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.revertBatch', 'start_line': 1046, 'end_line': 1046, 'offset_start': 38240, 'offset_end': 38312, 'content': 'function revertBatch(bytes calldata batchHeader, uint256 count) external;', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IScrollChain.finalizeBatchWithProof', 'start_line': 1054, 'end_line': 1060, 'offset_start': 38734, 'offset_end': 38942, 'content': 'function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;', 'contract_name': 'IScrollChain', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 1091, 'end_line': 1093, 'offset_start': 39950, 'offset_end': 40044, 'content': 'function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 1095, 'end_line': 1097, 'offset_start': 40051, 'offset_end': 40161, 'content': 'function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 1110, 'end_line': 1112, 'offset_start': 40388, 'offset_end': 40472, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 1117, 'end_line': 1119, 'offset_start': 40546, 'offset_end': 40675, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 1128, 'end_line': 1130, 'offset_start': 41011, 'offset_end': 41111, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 1136, 'end_line': 1139, 'offset_start': 41261, 'offset_end': 41458, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 1145, 'end_line': 1149, 'offset_start': 41613, 'offset_end': 41799, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 1176, 'end_line': 1177, 'offset_start': 42806, 'offset_end': 42864, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 1179, 'end_line': 1180, 'offset_start': 42871, 'offset_end': 42939, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 1181, 'end_line': 1183, 'offset_start': 42945, 'offset_end': 43040, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 1185, 'end_line': 1187, 'offset_start': 43047, 'offset_end': 43145, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1236, 'end_line': 1238, 'offset_start': 45309, 'offset_end': 45419, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1240, 'end_line': 1242, 'offset_start': 45426, 'offset_end': 45534, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1257, 'end_line': 1263, 'offset_start': 46021, 'offset_end': 46307, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1265, 'end_line': 1269, 'offset_start': 46314, 'offset_end': 46522, 'content': 'function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1275, 'end_line': 1277, 'offset_start': 46702, 'offset_end': 46808, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 1326, 'end_line': 1332, 'offset_start': 48527, 'offset_end': 48846, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 1350, 'end_line': 1355, 'offset_start': 49762, 'offset_end': 50073, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1375, 'end_line': 1377, 'offset_start': 50816, 'offset_end': 51000, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1385, 'end_line': 1391, 'offset_start': 51223, 'offset_end': 51445, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1404, 'end_line': 1406, 'offset_start': 51808, 'offset_end': 52031, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1414, 'end_line': 1423, 'offset_start': 52280, 'offset_end': 52725, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1431, 'end_line': 1433, 'offset_start': 52903, 'offset_end': 53099, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1441, 'end_line': 1448, 'offset_start': 53284, 'offset_end': 53609, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1456, 'end_line': 1458, 'offset_start': 53789, 'offset_end': 53986, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1466, 'end_line': 1473, 'offset_start': 54173, 'offset_end': 54497, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 1481, 'end_line': 1497, 'offset_start': 54786, 'offset_end': 55413, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 1505, 'end_line': 1515, 'offset_start': 55635, 'offset_end': 55929, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 1517, 'end_line': 1529, 'offset_start': 55936, 'offset_end': 56475, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ScrollMessenger.relayMessageWithProof', 'start_line': 1570, 'end_line': 1577, 'offset_start': 57921, 'offset_end': 58121, 'content': 'function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;', 'contract_name': 'IL1ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ScrollMessenger.replayMessage', 'start_line': 1587, 'end_line': 1595, 'offset_start': 58633, 'offset_end': 58862, 'content': 'function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;', 'contract_name': 'IL1ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ScrollMessenger.dropMessage', 'start_line': 1603, 'end_line': 1609, 'offset_start': 59211, 'offset_end': 59371, 'content': 'function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;', 'contract_name': 'IL1ScrollMessenger', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.pendingQueueIndex', 'start_line': 1669, 'end_line': 1669, 'offset_start': 61563, 'offset_end': 61623, 'content': 'function pendingQueueIndex() external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.nextCrossDomainMessageIndex', 'start_line': 1673, 'end_line': 1673, 'offset_start': 61746, 'offset_end': 61816, 'content': 'function nextCrossDomainMessageIndex() external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.getCrossDomainMessage', 'start_line': 1677, 'end_line': 1677, 'offset_start': 61924, 'offset_end': 62006, 'content': 'function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.estimateCrossDomainMessageFee', 'start_line': 1681, 'end_line': 1681, 'offset_start': 62171, 'offset_end': 62259, 'content': 'function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.calculateIntrinsicGasFee', 'start_line': 1685, 'end_line': 1685, 'offset_start': 62425, 'offset_end': 62516, 'content': 'function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.computeTransactionHash', 'start_line': 1694, 'end_line': 1701, 'offset_start': 62889, 'offset_end': 63112, 'content': 'function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.isMessageSkipped', 'start_line': 1705, 'end_line': 1705, 'offset_start': 63241, 'offset_end': 63315, 'content': 'function isMessageSkipped(uint256 queueIndex) external view returns (bool);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.isMessageDropped', 'start_line': 1709, 'end_line': 1709, 'offset_start': 63444, 'offset_end': 63518, 'content': 'function isMessageDropped(uint256 queueIndex) external view returns (bool);', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.appendCrossDomainMessage', 'start_line': 1719, 'end_line': 1723, 'offset_start': 63907, 'offset_end': 64034, 'content': 'function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.appendEnforcedTransaction', 'start_line': 1732, 'end_line': 1738, 'offset_start': 64494, 'offset_end': 64669, 'content': 'function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.popCrossDomainMessage', 'start_line': 1748, 'end_line': 1752, 'offset_start': 65068, 'offset_end': 65195, 'content': 'function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1MessageQueue.dropCrossDomainMessage', 'start_line': 1755, 'end_line': 1755, 'offset_start': 65257, 'offset_end': 65312, 'content': 'function dropCrossDomainMessage(uint256 index) external;', 'contract_name': 'IL1MessageQueue', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new L1 => L2 transaction is appended to the queue.\n    /// @param sender The address of account who initiates the transaction.\n    /// @param target The address of account who will receive the transaction.\n    /// @param value The value passed with the transaction.\n    /// @param queueIndex The index of this transaction in the queue.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    /// @param data The calldata of the transaction.\n    event QueueTransaction(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint64 queueIndex,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /// @notice Emitted when some L1 => L2 transactions are included in L1.\n    /// @param startIndex The start index of messages popped.\n    /// @param count The number of messages popped.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    event DequeueTransaction(uint256 startIndex, uint256 count, uint256 skippedBitmap);\n\n    /// @notice Emitted when a message is dropped from L1.\n    /// @param index The index of message dropped.\n    event DropTransaction(uint256 index);\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address indexed _oldGasOracle, address indexed _newGasOracle);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The start index of all pending inclusion messages.\n    function pendingQueueIndex() external view returns (uint256);\n\n    /// @notice Return the index of next appended message.\n    /// @dev Also the total number of appended messages.\n    function nextCrossDomainMessageIndex() external view returns (uint256);\n\n    /// @notice Return the message of in `queueIndex`.\n    /// @param queueIndex The index to query.\n    function getCrossDomainMessage(uint256 queueIndex) external view returns (bytes32);\n\n    /// @notice Return the amount of ETH should pay for cross domain message.\n    /// @param gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 gasLimit) external view returns (uint256);\n\n    /// @notice Return the amount of intrinsic gas fee should pay for cross domain message.\n    /// @param _calldata The calldata of L1-initiated transaction.\n    function calculateIntrinsicGasFee(bytes calldata _calldata) external view returns (uint256);\n\n    /// @notice Return the hash of a L1 message.\n    /// @param sender The address of sender.\n    /// @param queueIndex The queue index of this message.\n    /// @param value The amount of Ether transfer to target.\n    /// @param target The address of target.\n    /// @param gasLimit The gas limit provided.\n    /// @param data The calldata passed to target address.\n    function computeTransactionHash(\n        address sender,\n        uint256 queueIndex,\n        uint256 value,\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /// @notice Return whether the message is skipped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageSkipped(uint256 queueIndex) external view returns (bool);\n\n    /// @notice Return whether the message is dropped.\n    /// @param queueIndex The queue index of the message to check.\n    function isMessageDropped(uint256 queueIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Append a L1 to L2 message into this contract.\n    /// @param target The address of target contract to call in L2.\n    /// @param gasLimit The maximum gas should be used for relay this message in L2.\n    /// @param data The calldata passed to target contract.\n    function appendCrossDomainMessage(\n        address target,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Append an enforced transaction to this contract.\n    /// @dev The address of sender should be an EOA.\n    /// @param sender The address of sender who will initiate this transaction in L2.\n    /// @param target The address of target contract to call in L2.\n    /// @param value The value passed\n    /// @param gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param data The calldata passed to target contract.\n    function appendEnforcedTransaction(\n        address sender,\n        address target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external;\n\n    /// @notice Pop finalized messages from queue.\n    ///\n    /// @dev We can pop at most 256 messages each time. And if the message is not skipped,\n    ///      the corresponding entry will be cleared.\n    ///\n    /// @param startIndex The start index to pop.\n    /// @param count The number of messages to pop.\n    /// @param skippedBitmap A bitmap indicates whether a message is skipped.\n    function popCrossDomainMessage(\n        uint256 startIndex,\n        uint256 count,\n        uint256 skippedBitmap\n    ) external;\n\n    /// @notice Drop a skipped message from the queue.\n    function dropCrossDomainMessage(uint256 index) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367/0x6774bcbd5cecef1336b5300fb5186a12ddd8b367.sol'}
