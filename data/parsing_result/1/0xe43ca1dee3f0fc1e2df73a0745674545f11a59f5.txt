{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.tor', 'start_line': 70, 'end_line': 77, 'offset_start': 2354, 'offset_end': 2642, 'content': 'constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.setPriviledge', 'start_line': 79, 'end_line': 81, 'offset_start': 2647, 'offset_end': 2765, 'content': 'function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.pause', 'start_line': 83, 'end_line': 85, 'offset_start': 2770, 'offset_end': 2848, 'content': 'function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.resume', 'start_line': 87, 'end_line': 89, 'offset_start': 2853, 'offset_end': 2936, 'content': 'function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.', 'start_line': 92, 'end_line': 92, 'offset_start': 2977, 'offset_end': 3005, 'content': 'receive() external payable {}', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processRoute', 'start_line': 100, 'end_line': 109, 'offset_start': 3341, 'offset_end': 3639, 'content': 'function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.transferValueAndprocessRoute', 'start_line': 119, 'end_line': 136, 'offset_start': 4129, 'offset_end': 4722, 'content': "function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}('');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }", 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processRouteInternal', 'start_line': 144, 'end_line': 188, 'offset_start': 5046, 'offset_end': 6947, 'content': "function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert('RouteProcessor: Unknown command code');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, 'RouteProcessor: Minimal input balance violation');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }", 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.applyPermit', 'start_line': 193, 'end_line': 200, 'offset_start': 7064, 'offset_end': 7412, 'content': 'function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processNative', 'start_line': 204, 'end_line': 207, 'offset_start': 7542, 'offset_end': 7739, 'content': 'function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processMyERC20', 'start_line': 212, 'end_line': 219, 'offset_start': 7909, 'offset_end': 8255, 'content': 'function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processUserERC20', 'start_line': 225, 'end_line': 228, 'offset_start': 8490, 'offset_end': 8670, 'content': 'function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processOnePool', 'start_line': 234, 'end_line': 237, 'offset_start': 8951, 'offset_end': 9096, 'content': 'function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.processInsideBento', 'start_line': 242, 'end_line': 249, 'offset_start': 9240, 'offset_end': 9570, 'content': 'function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.distributeAndSwap', 'start_line': 256, 'end_line': 266, 'offset_start': 9866, 'offset_end': 10278, 'content': 'function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.swap', 'start_line': 273, 'end_line': 282, 'offset_start': 10486, 'offset_end': 11104, 'content': "function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert('RouteProcessor: Unknown pool type');\n  }", 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.wrapNative', 'start_line': 289, 'end_line': 305, 'offset_start': 11353, 'offset_end': 12173, 'content': 'function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.bentoBridge', 'start_line': 312, 'end_line': 333, 'offset_start': 12413, 'offset_end': 13502, 'content': 'function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.swapUniV2', 'start_line': 340, 'end_line': 358, 'offset_start': 13736, 'offset_end': 14847, 'content': "function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, 'Wrong pool reserves');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }", 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.swapTrident', 'start_line': 365, 'end_line': 374, 'offset_start': 15062, 'offset_end': 15390, 'content': 'function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.swapUniV3', 'start_line': 381, 'end_line': 397, 'offset_start': 15619, 'offset_end': 16283, 'content': "function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, 'RouteProcessor.swapUniV3: unexpected'); // Just to be sure\n  }", 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.uniswapV3SwapCallback', 'start_line': 408, 'end_line': 420, 'offset_start': 17173, 'offset_end': 17724, 'content': "function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, 'RouteProcessor.uniswapV3SwapCallback: call from unknown source');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, 'RouteProcessor.uniswapV3SwapCallback: not positive amount');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }", 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.algebraSwapCallback', 'start_line': 431, 'end_line': 437, 'offset_start': 18608, 'offset_end': 18790, 'content': 'function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.pancakeV3SwapCallback', 'start_line': 446, 'end_line': 452, 'offset_start': 19480, 'offset_end': 19664, 'content': 'function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RouteProcessor4.swapCurve', 'start_line': 459, 'end_line': 490, 'offset_start': 20004, 'offset_end': 21377, 'content': 'function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }', 'contract_name': 'RouteProcessor4', 'contract_code': '{\n  using SafeERC20 for IERC20;\n  using Approve for IERC20;\n  using SafeERC20 for IERC20Permit;\n  using InputStream for uint256;\n\n  event Route(\n    address indexed from, \n    address to, \n    address indexed tokenIn, \n    address indexed tokenOut, \n    uint256 amountIn, \n    uint256 amountOutMin,\n    uint256 amountOut\n  );\n\n  error MinimalOutputBalanceViolation(uint256 amountOut);\n\n  IBentoBoxMinimal public immutable bentoBox;\n  mapping (address => bool) public priviledgedUsers;\n  address private lastCalledPool;\n\n  uint8 private unlocked = NOT_LOCKED;\n  uint8 private paused = NOT_PAUSED;\n  modifier lock() {\n      require(unlocked == NOT_LOCKED, \'RouteProcessor is locked\');\n      require(paused == NOT_PAUSED, \'RouteProcessor is paused\');\n      unlocked = LOCKED;\n      _;\n      unlocked = NOT_LOCKED;\n  }\n\n  modifier onlyOwnerOrPriviledgedUser() {\n    require(msg.sender == owner() || priviledgedUsers[msg.sender], "RP: caller is not the owner or a privileged user");\n    _;\n  }\n\n  constructor(address _bentoBox, address[] memory priviledgedUserList) {\n    bentoBox = IBentoBoxMinimal(_bentoBox);\n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n    for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n      priviledgedUsers[priviledgedUserList[i]] = true;\n    }\n  }\n\n  function setPriviledge(address user, bool priviledge) external onlyOwner {\n    priviledgedUsers[user] = priviledge;\n  }\n\n  function pause() external onlyOwnerOrPriviledgedUser {\n    paused = PAUSED;\n  }\n\n  function resume() external onlyOwnerOrPriviledgedUser {\n    paused = NOT_PAUSED;\n  }\n\n  /// @notice For native unwrapping\n  receive() external payable {}\n\n  /// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Transfers some value to <transferValueTo> and then processes the route\n  /// @param transferValueTo Address where the value should be transferred\n  /// @param amountValueTransfer How much value to transfer\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function transferValueAndprocessRoute(\n    address payable transferValueTo,\n    uint256 amountValueTransfer,\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) external payable lock returns (uint256 amountOut) {\n    (bool success, bytes memory returnBytes) = transferValueTo.call{value: amountValueTransfer}(\'\');\n    if (!success) {\n      assembly {\n        revert(add(32, returnBytes), mload(returnBytes))\n      }\n    }\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n\n  /// @notice Processes the route generated off-chain\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRouteInternal(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route\n  ) private returns (uint256 amountOut) {\n    uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n\n    uint256 realAmountIn = amountIn;\n    {\n      uint256 step = 0;\n      uint256 stream = InputStream.createStream(route);\n      while (stream.isNotEmpty()) {\n        uint8 commandCode = stream.readUint8();\n        if (commandCode == 1) {\n          uint256 usedAmount = processMyERC20(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 2) processUserERC20(stream, amountIn);\n        else if (commandCode == 3) {\n          uint256 usedAmount = processNative(stream); \n          if (step == 0) realAmountIn = usedAmount;\n        } \n        else if (commandCode == 4) processOnePool(stream);\n        else if (commandCode == 5) processInsideBento(stream);\n        else if (commandCode == 6) applyPermit(tokenIn, stream);\n        else revert(\'RouteProcessor: Unknown command code\');\n        ++step;\n      }\n    }\n\n    uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS ? 0 : IERC20(tokenIn).balanceOf(msg.sender);\n    require(balanceInFinal + amountIn >= balanceInInitial, \'RouteProcessor: Minimal input balance violation\');\n    \n    uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);\n    if (balanceOutFinal < balanceOutInitial + amountOutMin)\n      revert MinimalOutputBalanceViolation(balanceOutFinal - balanceOutInitial);\n\n    amountOut = balanceOutFinal - balanceOutInitial;\n\n    emit Route(msg.sender, to, tokenIn, tokenOut, realAmountIn, amountOutMin, amountOut);\n  }\n\n  /// @notice Applies ERC-2612 permit\n  /// @param tokenIn permitted token\n  /// @param stream Streamed program\n  function applyPermit(address tokenIn, uint256 stream) private {\n    uint256 value = stream.readUint();\n    uint256 deadline = stream.readUint();\n    uint8 v = stream.readUint8();\n    bytes32 r = stream.readBytes32();\n    bytes32 s = stream.readBytes32();\n    IERC20Permit(tokenIn).safePermit(msg.sender, address(this), value, deadline, v, r, s);\n  }\n\n  /// @notice Processes native coin: call swap for all pools that swap from native coin\n  /// @param stream Streamed program\n  function processNative(uint256 stream) private returns (uint256 amountTotal) {\n    amountTotal = address(this).balance;\n    distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token from this contract balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processMyERC20(uint256 stream) private returns (uint256 amountTotal) {\n    address token = stream.readAddress();\n    amountTotal = IERC20(token).balanceOf(address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n  \n  /// @notice Processes ERC20 token from msg.sender balance:\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  /// @param amountTotal Amount of tokens to take from msg.sender\n  function processUserERC20(uint256 stream, uint256 amountTotal) private {\n    address token = stream.readAddress();\n    distributeAndSwap(stream, msg.sender, token, amountTotal);\n  }\n\n  /// @notice Processes ERC20 token for cases when the token has only one output pool\n  /// @notice In this case liquidity is already at pool balance. This is an optimization\n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processOnePool(uint256 stream) private {\n    address token = stream.readAddress();\n    swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n  }\n\n  /// @notice Processes Bento tokens \n  /// @notice Call swap for all pools that swap from this token\n  /// @param stream Streamed program\n  function processInsideBento(uint256 stream) private {\n    address token = stream.readAddress();\n    uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n    unchecked {\n      if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection\n    }\n    distributeAndSwap(stream, address(this), token, amountTotal);\n  }\n\n  /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountTotal Total amount of tokenIn for swaps \n  function distributeAndSwap(uint256 stream, address from, address tokenIn, uint256 amountTotal) private {\n    uint8 num = stream.readUint8();\n    unchecked {\n      for (uint256 i = 0; i < num; ++i) {\n        uint16 share = stream.readUint16();\n        uint256 amount = (amountTotal * share) / type(uint16).max /*65535*/;\n        amountTotal -= amount;\n        swap(stream, from, tokenIn, amount);\n      }\n    }\n  }\n\n  /// @notice Makes swap\n  /// @param stream Streamed program\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swap(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 poolType = stream.readUint8();\n    if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n    else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n    else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n    else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n    else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n    else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n    else revert(\'RouteProcessor: Unknown pool type\');\n  }\n\n  /// @notice Wraps/unwraps native token\n  /// @param stream [direction & fake, recipient, wrapToken?]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function wrapNative(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 directionAndFake = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (directionAndFake & 1 == 1) {  // wrap native\n      address wrapToken = stream.readAddress();\n      if (directionAndFake & 2 == 0) IWETH(wrapToken).deposit{value: amountIn}();\n      if (to != address(this)) IERC20(wrapToken).safeTransfer(to, amountIn);\n    } else { // unwrap native\n      if (directionAndFake & 2 == 0) {\n        if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IWETH(tokenIn).withdraw(amountIn);\n      }\n      (bool success,)= payable(to).call{value: amountIn}("");\n      require(success, "RouteProcessor.wrapNative: Native token transfer failed");\n    }\n  }\n\n  /// @notice Bridge/unbridge tokens to/from Bento\n  /// @param stream [direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function bentoBridge(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n\n    if (direction > 0) {  // outside to Bento\n      // deposit to arbitrary recipient is possible only from address(bentoBox)\n      if (from == address(this)) IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n      else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(bentoBox), amountIn);\n      else {\n        // tokens already are at address(bentoBox)\n        amountIn = IERC20(tokenIn).balanceOf(address(bentoBox)) +\n        bentoBox.strategyData(tokenIn).balance -\n        bentoBox.totals(tokenIn).elastic;\n      }\n      bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n    } else { // Bento to outside\n      if (from != INTERNAL_INPUT_SOURCE) {\n        bentoBox.transfer(tokenIn, from, address(this), amountIn);\n      } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n      bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n    }\n  }\n\n  /// @notice UniswapV2 pool swap\n  /// @param stream [pool, direction, recipient, fee]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV2(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 direction = stream.readUint8();\n    address to = stream.readAddress();\n    uint24 fee = stream.readUint24();   // pool fee in 1/1_000_000\n\n    if (from == address(this)) IERC20(tokenIn).safeTransfer(pool, amountIn);\n    else if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n    (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n    require(r0 > 0 && r1 > 0, \'Wrong pool reserves\');\n    (uint256 reserveIn, uint256 reserveOut) = direction == 1 ? (r0, r1) : (r1, r0);\n    amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn;  // tokens already were transferred\n\n    uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n    uint256 amountOut = (amountInWithFee * reserveOut) / (reserveIn * 1_000_000 + amountInWithFee);\n    (uint256 amount0Out, uint256 amount1Out) = direction == 1 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n    IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n  }\n\n  /// @notice Trident pool swap\n  /// @param stream [pool, swapData]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapTrident(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bytes memory swapData = stream.readBytes();\n\n    if (from != INTERNAL_INPUT_SOURCE) {\n      bentoBox.transfer(tokenIn, from, pool, amountIn);\n    }\n    \n    IPool(pool).swap(swapData);\n  }\n\n  /// @notice UniswapV3 pool swap\n  /// @param stream [pool, direction, recipient]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    bool zeroForOne = stream.readUint8() > 0;\n    address recipient = stream.readAddress();\n\n    if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), uint256(amountIn));\n\n    lastCalledPool = pool;\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      zeroForOne,\n      int256(amountIn),\n      zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n      abi.encode(tokenIn)\n    );\n    require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, \'RouteProcessor.swapUniV3: unexpected\'); // Just to be sure\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) public {\n    require(msg.sender == lastCalledPool, \'RouteProcessor.uniswapV3SwapCallback: call from unknown source\');\n    int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n    require(amount > 0, \'RouteProcessor.uniswapV3SwapCallback: not positive amount\');\n    \n    lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n    (address tokenIn) = abi.decode(data, (address));\n    IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n  function pancakeV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external {\n    uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n  }\n\n  /// @notice Curve pool swap. Legacy pools that don\'t return amountOut and have native coins are not supported\n  /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n  /// @param from Where to take liquidity for swap\n  /// @param tokenIn Input token\n  /// @param amountIn Amount of tokenIn to take for swap\n  function swapCurve(uint256 stream, address from, address tokenIn, uint256 amountIn) private {\n    address pool = stream.readAddress();\n    uint8 poolType = stream.readUint8();\n    int128 fromIndex = int8(stream.readUint8());\n    int128 toIndex = int8(stream.readUint8());\n    address to = stream.readAddress();\n    address tokenOut = stream.readAddress();\n\n    uint256 amountOut;\n    if (tokenIn == NATIVE_ADDRESS) {\n      amountOut = ICurve(pool).exchange{value: amountIn}(fromIndex, toIndex, amountIn, 0);\n    } else {\n      if (from == msg.sender) IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n      IERC20(tokenIn).approveSafe(pool, amountIn);\n      if (poolType == 0) amountOut = ICurve(pool).exchange(fromIndex, toIndex, amountIn, 0);\n      else {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        amountOut = balanceAfter - balanceBefore;\n      }\n    }\n\n    if (to != address(this)) {      \n      if(tokenOut == NATIVE_ADDRESS) {\n        (bool success,)= payable(to).call{value: amountOut}("");\n        require(success, "RouteProcessor.swapCurve: Native token transfer failed");\n      } else {\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n      }\n    }\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.createStream', 'start_line': 503, 'end_line': 511, 'offset_start': 21573, 'offset_end': 21850, 'content': 'function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.isNotEmpty', 'start_line': 516, 'end_line': 524, 'offset_start': 21931, 'offset_end': 22149, 'content': 'function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readUint8', 'start_line': 529, 'end_line': 536, 'offset_start': 22228, 'offset_end': 22428, 'content': 'function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readUint16', 'start_line': 541, 'end_line': 548, 'offset_start': 22508, 'offset_end': 22710, 'content': 'function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readUint24', 'start_line': 553, 'end_line': 560, 'offset_start': 22790, 'offset_end': 22992, 'content': 'function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readUint32', 'start_line': 565, 'end_line': 572, 'offset_start': 23072, 'offset_end': 23274, 'content': 'function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readUint', 'start_line': 577, 'end_line': 584, 'offset_start': 23355, 'offset_end': 23557, 'content': 'function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readBytes32', 'start_line': 589, 'end_line': 596, 'offset_start': 23638, 'offset_end': 23843, 'content': 'function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readAddress', 'start_line': 601, 'end_line': 608, 'offset_start': 23924, 'offset_end': 24129, 'content': 'function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'InputStream.readBytes', 'start_line': 613, 'end_line': 620, 'offset_start': 24208, 'offset_end': 24436, 'content': 'function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }', 'contract_name': 'InputStream', 'contract_code': '{\n\n  /** @notice Creates stream from data\n   * @param data data\n   */\n  function createStream(bytes memory data) internal pure returns (uint256 stream) {\n    assembly {\n      stream := mload(0x40)\n      mstore(0x40, add(stream, 64))\n      mstore(stream, data)\n      let length := mload(data)\n      mstore(add(stream, 32), add(data, length))\n    }\n  }\n\n  /** @notice Checks if stream is not empty\n   * @param stream stream\n   */\n  function isNotEmpty(uint256 stream) internal pure returns (bool) {\n    uint256 pos;\n    uint256 finish;\n    assembly {\n      pos := mload(stream)\n      finish := mload(add(stream, 32))\n    }\n    return pos < finish;\n  }\n\n  /** @notice Reads uint8 from the stream\n   * @param stream stream\n   */\n  function readUint8(uint256 stream) internal pure returns (uint8 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 1)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint16 from the stream\n   * @param stream stream\n   */\n  function readUint16(uint256 stream) internal pure returns (uint16 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 2)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint24 from the stream\n   * @param stream stream\n   */\n  function readUint24(uint256 stream) internal pure returns (uint24 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 3)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint32 from the stream\n   * @param stream stream\n   */\n  function readUint32(uint256 stream) internal pure returns (uint32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 4)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads uint256 from the stream\n   * @param stream stream\n   */\n  function readUint(uint256 stream) internal pure returns (uint256 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes32 from the stream\n   * @param stream stream\n   */\n  function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 32)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads address from the stream\n   * @param stream stream\n   */\n  function readAddress(uint256 stream) internal pure returns (address res) {\n    assembly {\n      let pos := mload(stream)\n      pos := add(pos, 20)\n      res := mload(pos)\n      mstore(stream, pos)\n    }\n  }\n\n  /** @notice Reads bytes from the stream\n   * @param stream stream\n   */\n  function readBytes(uint256 stream) internal pure returns (bytes memory res) {\n    assembly {\n      let pos := mload(stream)\n      res := add(pos, 32)\n      let length := mload(res)\n      mstore(stream, add(res, length))\n    }\n  }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'ITridentCLPool.token0', 'start_line': 628, 'end_line': 628, 'offset_start': 24541, 'offset_end': 24585, 'content': 'function token0() external returns (address);', 'contract_name': 'ITridentCLPool', 'contract_code': '{\n  function token0() external returns (address);\n  function token1() external returns (address);\n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bool unwrapBento,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'ITridentCLPool.token1', 'start_line': 629, 'end_line': 629, 'offset_start': 24589, 'offset_end': 24633, 'content': 'function token1() external returns (address);', 'contract_name': 'ITridentCLPool', 'contract_code': '{\n  function token0() external returns (address);\n  function token1() external returns (address);\n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bool unwrapBento,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'ITridentCLPool.swap', 'start_line': 631, 'end_line': 638, 'offset_start': 24638, 'offset_end': 24855, 'content': 'function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bool unwrapBento,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);', 'contract_name': 'ITridentCLPool', 'contract_code': '{\n  function token0() external returns (address);\n  function token1() external returns (address);\n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bool unwrapBento,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.token0', 'start_line': 646, 'end_line': 646, 'offset_start': 24960, 'offset_end': 25004, 'content': 'function token0() external returns (address);', 'contract_name': 'IUniswapV3Pool', 'contract_code': '{\n  function token0() external returns (address);\n  function token1() external returns (address);\n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.token1', 'start_line': 647, 'end_line': 647, 'offset_start': 25008, 'offset_end': 25052, 'content': 'function token1() external returns (address);', 'contract_name': 'IUniswapV3Pool', 'contract_code': '{\n  function token0() external returns (address);\n  function token1() external returns (address);\n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.swap', 'start_line': 649, 'end_line': 655, 'offset_start': 25057, 'offset_end': 25252, 'content': 'function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);', 'contract_name': 'IUniswapV3Pool', 'contract_code': '{\n  function token0() external returns (address);\n  function token1() external returns (address);\n\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RebaseLibrary.toBase', 'start_line': 676, 'end_line': 682, 'offset_start': 25693, 'offset_end': 25938, 'content': 'function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }', 'contract_name': 'RebaseLibrary', 'contract_code': '{\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'RebaseLibrary.toElastic', 'start_line': 685, 'end_line': 691, 'offset_start': 26029, 'offset_end': 26274, 'content': 'function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }', 'contract_name': 'RebaseLibrary', 'contract_code': '{\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.balanceOf', 'start_line': 698, 'end_line': 698, 'offset_start': 26493, 'offset_end': 26561, 'content': 'function balanceOf(address, address) external view returns (uint256);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.toShare', 'start_line': 705, 'end_line': 709, 'offset_start': 26854, 'offset_end': 26983, 'content': 'function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.toAmount', 'start_line': 716, 'end_line': 720, 'offset_start': 27283, 'offset_end': 27413, 'content': 'function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.registerProtocol', 'start_line': 723, 'end_line': 723, 'offset_start': 27503, 'offset_end': 27539, 'content': 'function registerProtocol() external;', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.deposit', 'start_line': 733, 'end_line': 739, 'offset_start': 28079, 'offset_end': 28276, 'content': 'function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.withdraw', 'start_line': 747, 'end_line': 753, 'offset_start': 28669, 'offset_end': 28860, 'content': 'function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.transfer', 'start_line': 760, 'end_line': 765, 'offset_start': 29140, 'offset_end': 29260, 'content': 'function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.totals', 'start_line': 768, 'end_line': 768, 'offset_start': 29336, 'offset_end': 29410, 'content': 'function totals(address token) external view returns (Rebase memory total);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.strategyData', 'start_line': 770, 'end_line': 770, 'offset_start': 29417, 'offset_end': 29503, 'content': 'function strategyData(address token) external view returns (StrategyData memory total);', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.setMasterContractApproval', 'start_line': 773, 'end_line': 780, 'offset_start': 29579, 'offset_end': 29760, 'content': 'function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IBentoBoxMinimal.harvest', 'start_line': 782, 'end_line': 786, 'offset_start': 29767, 'offset_end': 29876, 'content': 'function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;', 'contract_name': 'IBentoBoxMinimal', 'contract_code': '{\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(address token) external view returns (StrategyData memory total);\n\n    /// @dev Approves users\' BentoBox assets to a "master" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 805, 'end_line': 807, 'offset_start': 30521, 'offset_end': 30616, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 809, 'end_line': 811, 'offset_start': 30623, 'offset_end': 30721, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 849, 'end_line': 857, 'offset_start': 32172, 'offset_end': 32354, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 866, 'end_line': 866, 'offset_start': 32660, 'offset_end': 32722, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 872, 'end_line': 872, 'offset_start': 32915, 'offset_end': 32974, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 896, 'end_line': 902, 'offset_start': 33742, 'offset_end': 33946, 'content': 'function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 904, 'end_line': 911, 'offset_start': 33953, 'offset_end': 34193, 'content': 'function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeApprove', 'start_line': 920, 'end_line': 933, 'offset_start': 34454, 'offset_end': 35056, 'content': 'function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 935, 'end_line': 942, 'offset_start': 35063, 'offset_end': 35372, 'content': 'function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 944, 'end_line': 955, 'offset_start': 35379, 'offset_end': 35864, 'content': 'function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safePermit', 'start_line': 957, 'end_line': 971, 'offset_start': 35871, 'offset_end': 36342, 'content': 'function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 979, 'end_line': 989, 'offset_start': 36726, 'offset_end': 37431, 'content': 'function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 1027, 'end_line': 1033, 'offset_start': 38611, 'offset_end': 38930, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1051, 'end_line': 1056, 'offset_start': 39848, 'offset_end': 40159, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1076, 'end_line': 1078, 'offset_start': 40902, 'offset_end': 41086, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1086, 'end_line': 1092, 'offset_start': 41309, 'offset_end': 41531, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1105, 'end_line': 1111, 'offset_start': 41894, 'offset_end': 42147, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1119, 'end_line': 1128, 'offset_start': 42396, 'offset_end': 42841, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1136, 'end_line': 1138, 'offset_start': 43019, 'offset_end': 43215, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1146, 'end_line': 1153, 'offset_start': 43400, 'offset_end': 43725, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1161, 'end_line': 1163, 'offset_start': 43905, 'offset_end': 44102, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1171, 'end_line': 1178, 'offset_start': 44289, 'offset_end': 44613, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1186, 'end_line': 1202, 'offset_start': 44902, 'offset_end': 45529, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1210, 'end_line': 1220, 'offset_start': 45751, 'offset_end': 46045, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1222, 'end_line': 1234, 'offset_start': 46052, 'offset_end': 46591, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'ICurve.exchange', 'start_line': 1239, 'end_line': 1239, 'offset_start': 46618, 'offset_end': 46718, 'content': 'function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) payable external returns (uint256);', 'contract_name': 'ICurve', 'contract_code': '{\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) payable external returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'ICurveLegacy.exchange', 'start_line': 1243, 'end_line': 1243, 'offset_start': 46750, 'offset_end': 46832, 'content': 'function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) payable external;', 'contract_name': 'ICurveLegacy', 'contract_code': '{\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) payable external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.swap', 'start_line': 1258, 'end_line': 1258, 'offset_start': 47280, 'offset_end': 47356, 'content': 'function swap(bytes calldata data) external returns (uint256 finalAmountOut);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.flashSwap', 'start_line': 1264, 'end_line': 1264, 'offset_start': 47696, 'offset_end': 47777, 'content': 'function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.mint', 'start_line': 1269, 'end_line': 1269, 'offset_start': 47975, 'offset_end': 48046, 'content': 'function mint(bytes calldata data) external returns (uint256 liquidity);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.burn', 'start_line': 1275, 'end_line': 1275, 'offset_start': 48325, 'offset_end': 48416, 'content': 'function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.burnSingle', 'start_line': 1281, 'end_line': 1281, 'offset_start': 48706, 'offset_end': 48783, 'content': 'function burnSingle(bytes calldata data) external returns (uint256 amountOut);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.poolIdentifier', 'start_line': 1284, 'end_line': 1284, 'offset_start': 48845, 'offset_end': 48902, 'content': 'function poolIdentifier() external pure returns (bytes32);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.getAssets', 'start_line': 1287, 'end_line': 1287, 'offset_start': 48967, 'offset_end': 49028, 'content': 'function getAssets() external view returns (address[] memory);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.getAmountOut', 'start_line': 1293, 'end_line': 1293, 'offset_start': 49388, 'offset_end': 49477, 'content': 'function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IPool.getAmountIn', 'start_line': 1299, 'end_line': 1299, 'offset_start': 49837, 'offset_end': 49924, 'content': 'function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);', 'contract_name': 'IPool', 'contract_code': "{\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.deposit', 'start_line': 1316, 'end_line': 1316, 'offset_start': 50342, 'offset_end': 50377, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH', 'contract_code': '{\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.transfer', 'start_line': 1318, 'end_line': 1318, 'offset_start': 50382, 'offset_end': 50450, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IWETH', 'contract_code': '{\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.withdraw', 'start_line': 1320, 'end_line': 1320, 'offset_start': 50455, 'offset_end': 50490, 'content': 'function withdraw(uint256) external;', 'contract_name': 'IWETH', 'contract_code': '{\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.name', 'start_line': 1331, 'end_line': 1331, 'offset_start': 50744, 'offset_end': 50797, 'content': 'function name() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.symbol', 'start_line': 1332, 'end_line': 1332, 'offset_start': 50803, 'offset_end': 50858, 'content': 'function symbol() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.decimals', 'start_line': 1333, 'end_line': 1333, 'offset_start': 50864, 'offset_end': 50913, 'content': 'function decimals() external pure returns (uint8);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.totalSupply', 'start_line': 1334, 'end_line': 1334, 'offset_start': 50919, 'offset_end': 50970, 'content': 'function totalSupply() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.balanceOf', 'start_line': 1335, 'end_line': 1335, 'offset_start': 50976, 'offset_end': 51038, 'content': 'function balanceOf(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.allowance', 'start_line': 1336, 'end_line': 1336, 'offset_start': 51044, 'offset_end': 51123, 'content': 'function allowance(address owner, address spender) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.approve', 'start_line': 1338, 'end_line': 1338, 'offset_start': 51130, 'offset_end': 51199, 'content': 'function approve(address spender, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transfer', 'start_line': 1339, 'end_line': 1339, 'offset_start': 51205, 'offset_end': 51270, 'content': 'function transfer(address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transferFrom', 'start_line': 1340, 'end_line': 1340, 'offset_start': 51276, 'offset_end': 51359, 'content': 'function transferFrom(address from, address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.DOMAIN_SEPARATOR', 'start_line': 1342, 'end_line': 1342, 'offset_start': 51366, 'offset_end': 51425, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.PERMIT_TYPEHASH', 'start_line': 1343, 'end_line': 1343, 'offset_start': 51431, 'offset_end': 51489, 'content': 'function PERMIT_TYPEHASH() external pure returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.nonces', 'start_line': 1344, 'end_line': 1344, 'offset_start': 51495, 'offset_end': 51554, 'content': 'function nonces(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.permit', 'start_line': 1346, 'end_line': 1346, 'offset_start': 51561, 'offset_end': 51675, 'content': 'function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.MINIMUM_LIQUIDITY', 'start_line': 1360, 'end_line': 1360, 'offset_start': 52071, 'offset_end': 52128, 'content': 'function MINIMUM_LIQUIDITY() external pure returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.factory', 'start_line': 1361, 'end_line': 1361, 'offset_start': 52134, 'offset_end': 52184, 'content': 'function factory() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token0', 'start_line': 1362, 'end_line': 1362, 'offset_start': 52190, 'offset_end': 52239, 'content': 'function token0() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token1', 'start_line': 1363, 'end_line': 1363, 'offset_start': 52245, 'offset_end': 52294, 'content': 'function token1() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.getReserves', 'start_line': 1364, 'end_line': 1364, 'offset_start': 52300, 'offset_end': 52408, 'content': 'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price0CumulativeLast', 'start_line': 1365, 'end_line': 1365, 'offset_start': 52414, 'offset_end': 52474, 'content': 'function price0CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price1CumulativeLast', 'start_line': 1366, 'end_line': 1366, 'offset_start': 52480, 'offset_end': 52540, 'content': 'function price1CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.kLast', 'start_line': 1367, 'end_line': 1367, 'offset_start': 52546, 'offset_end': 52591, 'content': 'function kLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.mint', 'start_line': 1369, 'end_line': 1369, 'offset_start': 52598, 'offset_end': 52657, 'content': 'function mint(address to) external returns (uint liquidity);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.burn', 'start_line': 1370, 'end_line': 1370, 'offset_start': 52663, 'offset_end': 52734, 'content': 'function burn(address to) external returns (uint amount0, uint amount1);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.swap', 'start_line': 1371, 'end_line': 1371, 'offset_start': 52740, 'offset_end': 52829, 'content': 'function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.skim', 'start_line': 1372, 'end_line': 1372, 'offset_start': 52835, 'offset_end': 52869, 'content': 'function skim(address to) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.sync', 'start_line': 1373, 'end_line': 1373, 'offset_start': 52875, 'offset_end': 52899, 'content': 'function sync() external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.initialize', 'start_line': 1375, 'end_line': 1375, 'offset_start': 52906, 'offset_end': 52952, 'content': 'function initialize(address, address) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1403, 'end_line': 1403, 'offset_start': 53730, 'offset_end': 53784, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1408, 'end_line': 1408, 'offset_start': 53868, 'offset_end': 53935, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1417, 'end_line': 1417, 'offset_start': 54149, 'offset_end': 54218, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1426, 'end_line': 1426, 'offset_start': 54494, 'offset_end': 54576, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 1442, 'end_line': 1442, 'offset_start': 55230, 'offset_end': 55303, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 1453, 'end_line': 1457, 'offset_start': 55602, 'offset_end': 55719, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 1487, 'end_line': 1489, 'offset_start': 56636, 'offset_end': 56698, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 1502, 'end_line': 1504, 'offset_start': 56925, 'offset_end': 57009, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 1509, 'end_line': 1511, 'offset_start': 57083, 'offset_end': 57212, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 1520, 'end_line': 1522, 'offset_start': 57555, 'offset_end': 57655, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 1528, 'end_line': 1531, 'offset_start': 57805, 'offset_end': 58002, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 1537, 'end_line': 1541, 'offset_start': 58157, 'offset_end': 58343, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Approve.approveStable', 'start_line': 1558, 'end_line': 1563, 'offset_start': 58731, 'offset_end': 59037, 'content': 'function approveStable(IERC20 token, address spender, uint256 amount) internal returns (bool) {\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(token.approve.selector, spender, amount)\n    );\n    return success && (data.length == 0 || abi.decode(data, (bool)));\n  }', 'contract_name': 'Approve', 'contract_code': '{\n\n  /**\n   * @dev ERC20 approve that correct works with token.approve which returns bool or nothing (USDT for example)\n   * @param token The token targeted by the call.\n   * @param spender token spender\n   * @param amount token amount\n   */\n  function approveStable(IERC20 token, address spender, uint256 amount) internal returns (bool) {\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(token.approve.selector, spender, amount)\n    );\n    return success && (data.length == 0 || abi.decode(data, (bool)));\n  }\n\n  /**\n   * @dev ERC20 approve that correct works with token.approve which reverts if amount and \n   *      current allowance are not zero simultaniously (USDT for example). \n   *      In second case it tries to set allowance to 0, and then back to amount.\n   * @param token The token targeted by the call.\n   * @param spender token spender\n   * @param amount token amount\n   */\n  function approveSafe(IERC20 token, address spender, uint256 amount) internal returns (bool) {\n    return approveStable(token, spender, amount) \n      || (approveStable(token, spender, 0) && approveStable(token, spender, amount));\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
{'type': 'FunctionDefinition', 'name': 'Approve.approveSafe', 'start_line': 1573, 'end_line': 1576, 'offset_start': 59420, 'offset_end': 59652, 'content': 'function approveSafe(IERC20 token, address spender, uint256 amount) internal returns (bool) {\n    return approveStable(token, spender, amount) \n      || (approveStable(token, spender, 0) && approveStable(token, spender, amount));\n  }', 'contract_name': 'Approve', 'contract_code': '{\n\n  /**\n   * @dev ERC20 approve that correct works with token.approve which returns bool or nothing (USDT for example)\n   * @param token The token targeted by the call.\n   * @param spender token spender\n   * @param amount token amount\n   */\n  function approveStable(IERC20 token, address spender, uint256 amount) internal returns (bool) {\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(token.approve.selector, spender, amount)\n    );\n    return success && (data.length == 0 || abi.decode(data, (bool)));\n  }\n\n  /**\n   * @dev ERC20 approve that correct works with token.approve which reverts if amount and \n   *      current allowance are not zero simultaniously (USDT for example). \n   *      In second case it tries to set allowance to 0, and then back to amount.\n   * @param token The token targeted by the call.\n   * @param spender token spender\n   * @param amount token amount\n   */\n  function approveSafe(IERC20 token, address spender, uint256 amount) internal returns (bool) {\n    return approveStable(token, spender, amount) \n      || (approveStable(token, spender, 0) && approveStable(token, spender, amount));\n  }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5/0xe43ca1dee3f0fc1e2df73a0745674545f11a59f5.sol'}
