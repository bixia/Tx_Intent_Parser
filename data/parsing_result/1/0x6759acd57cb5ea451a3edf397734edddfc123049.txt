{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 36, 'end_line': 38, 'offset_start': 1303, 'offset_end': 1462, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 44, 'end_line': 46, 'offset_start': 1702, 'offset_end': 1889, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 52, 'end_line': 55, 'offset_start': 2081, 'offset_end': 2305, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 61, 'end_line': 69, 'offset_start': 2509, 'offset_end': 2976, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 76, 'end_line': 83, 'offset_start': 3296, 'offset_end': 3675, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.transferAndCallRelaxed', 'start_line': 92, 'end_line': 98, 'offset_start': 4020, 'offset_end': 4341, 'content': 'function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.transferFromAndCallRelaxed', 'start_line': 107, 'end_line': 119, 'offset_start': 4694, 'offset_end': 5099, 'content': 'function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.approveAndCallRelaxed', 'start_line': 132, 'end_line': 138, 'offset_start': 5765, 'offset_end': 6084, 'content': 'function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 146, 'end_line': 155, 'offset_start': 6468, 'offset_end': 7096, 'content': "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 165, 'end_line': 172, 'offset_start': 7598, 'offset_end': 8175, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 240, 'end_line': 248, 'offset_start': 11179, 'offset_end': 11361, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 257, 'end_line': 257, 'offset_start': 11667, 'offset_end': 11729, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 263, 'end_line': 263, 'offset_start': 11922, 'offset_end': 11981, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1363.transferAndCall', 'start_line': 300, 'end_line': 300, 'offset_start': 13509, 'offset_end': 13584, 'content': 'function transferAndCall(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC1363', 'contract_code': "{\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1363.transferAndCall', 'start_line': 310, 'end_line': 310, 'offset_start': 14049, 'offset_end': 14145, 'content': 'function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);', 'contract_name': 'IERC1363', 'contract_code': "{\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1363.transferFromAndCall', 'start_line': 320, 'end_line': 320, 'offset_start': 14610, 'offset_end': 14703, 'content': 'function transferFromAndCall(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC1363', 'contract_code': "{\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1363.transferFromAndCall', 'start_line': 331, 'end_line': 331, 'offset_start': 15251, 'offset_end': 15365, 'content': 'function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);', 'contract_name': 'IERC1363', 'contract_code': "{\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1363.approveAndCall', 'start_line': 340, 'end_line': 340, 'offset_start': 15767, 'offset_end': 15846, 'content': 'function approveAndCall(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC1363', 'contract_code': "{\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1363.approveAndCall', 'start_line': 350, 'end_line': 350, 'offset_start': 16336, 'offset_end': 16436, 'content': 'function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);', 'contract_name': 'IERC1363', 'contract_code': "{\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IClaim.claim', 'start_line': 401, 'end_line': 406, 'offset_start': 18154, 'offset_end': 18295, 'content': 'function claim(\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external;', 'contract_name': 'IClaim', 'contract_code': '{\n    function claim(\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ITokenShop.purchaseFromStake', 'start_line': 415, 'end_line': 419, 'offset_start': 18479, 'offset_end': 18670, 'content': 'function purchaseFromStake(\n        address purchaser,\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external returns (uint256 purchaseId, uint256 total);', 'contract_name': 'ITokenShop', 'contract_code': '{\n    function purchaseFromStake(\n        address purchaser,\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external returns (uint256 purchaseId, uint256 total);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.initialize', 'start_line': 490, 'end_line': 498, 'offset_start': 21267, 'offset_end': 21629, 'content': 'function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.pause', 'start_line': 503, 'end_line': 505, 'offset_start': 21678, 'offset_end': 21738, 'content': 'function pause() external onlyOwner {\n        _pause();\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.unpause', 'start_line': 510, 'end_line': 512, 'offset_start': 21787, 'offset_end': 21851, 'content': 'function unpause() external onlyOwner {\n        _unpause();\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.setStartDateAndMaxMultiplier', 'start_line': 517, 'end_line': 528, 'offset_start': 22064, 'offset_end': 22451, 'content': 'function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.setShopContract', 'start_line': 534, 'end_line': 542, 'offset_start': 22574, 'offset_end': 22982, 'content': "function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }", 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.setBonusMultiplier', 'start_line': 548, 'end_line': 553, 'offset_start': 23148, 'offset_end': 23360, 'content': 'function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.claimAndDepositPermit', 'start_line': 563, 'end_line': 586, 'offset_start': 23819, 'offset_end': 24504, 'content': 'function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.claimAndDeposit', 'start_line': 593, 'end_line': 600, 'offset_start': 24869, 'offset_end': 25166, 'content': 'function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.depositPermit', 'start_line': 608, 'end_line': 626, 'offset_start': 25498, 'offset_end': 25934, 'content': 'function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.deposit', 'start_line': 631, 'end_line': 633, 'offset_start': 26144, 'offset_end': 26248, 'content': 'function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.withdraw', 'start_line': 638, 'end_line': 655, 'offset_start': 26449, 'offset_end': 27087, 'content': 'function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.purchase', 'start_line': 662, 'end_line': 695, 'offset_start': 27279, 'offset_end': 28262, 'content': 'function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.currentMultiplier', 'start_line': 699, 'end_line': 719, 'offset_start': 28408, 'offset_end': 29144, 'content': 'function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.getMultiplier', 'start_line': 728, 'end_line': 730, 'offset_start': 29327, 'offset_end': 29441, 'content': 'function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.getErc20Balance', 'start_line': 735, 'end_line': 737, 'offset_start': 29625, 'offset_end': 29743, 'content': 'function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake.getPointsBalance', 'start_line': 742, 'end_line': 744, 'offset_start': 29901, 'offset_end': 30021, 'content': 'function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake._deposit', 'start_line': 754, 'end_line': 773, 'offset_start': 30344, 'offset_end': 31039, 'content': 'function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake._basePoints', 'start_line': 778, 'end_line': 784, 'offset_start': 31204, 'offset_end': 31417, 'content': 'function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PirateStake._totalPoints', 'start_line': 789, 'end_line': 798, 'offset_start': 31584, 'offset_end': 32025, 'content': 'function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }', 'contract_name': 'PirateStake', 'contract_code': "{\n    using SafeERC20 for IERC20;\n    // @notice UserStakeInfo struct to store user's staking information\n    // @param erc20balance The amount of ERC20 tokens staked by the user\n    // @param accumulatedPoints The total points earned by the user over time\n    // @param multiplier The multiplier applied to the user's points\n    // @param lastUpdatedTime The timestamp of the last update\n    struct UserStakeInfo {\n        uint256 erc20balance;\n        uint256 erc20initial;\n        uint256 accumulatedPoints;\n        uint64 lastUpdatedTime;\n        uint16 multiplier;\n    }\n\n    // @notice the user's staking information\n    mapping(address => UserStakeInfo) public users;\n\n    // @notice The ERC20 token that can be staked\n    IERC20 public token;\n\n    // @notice The claim contract that allows users to claim tokens\n    IClaim public claim;\n\n    // @notice The packed value of the start date and the maximum multiplier\n    uint256 public packedStartDateAndMaxMultiplier;\n\n    // @notice\n    uint256 public bonusMultiplier;\n\n    // @notice The address of the approved purchase contract\n    ITokenShop public shopContract;\n\n    // @notice Event emitted when the start date and maximum multiplier are set\n    event SetGlobals(uint192 maxMultiplier, uint64 startDate);\n\n    // @notice Event emitted when a user deposits tokens\n    event Deposit(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Event emitted when a user withdraws tokens\n    event Withdraw(address indexed user, uint256 amount, uint256 multiplier);\n\n    // @notice Initialize the contract with the ERC20 token and the claim contract\n    // @param _token The address of the ERC20 token\n    // @param _claim The address of the claim contract\n    function initialize(address _token, address _claim) public initializer {\n        __Ownable_init(_msgSender());\n        __Pausable_init();\n        token = IERC20(_token);\n        claim = IClaim(_claim);\n        packedStartDateAndMaxMultiplier = (block.timestamp << 192) | 500; // two decimals in max multiplier\n        bonusMultiplier = 50;\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Pause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // @notice Set the start date and maximum multiplier\n    // @param _startDate The start date of the staking program\n    // @param _maxMultiplier The maximum multiplier that can be applied to the points\n    function setStartDateAndMaxMultiplier(\n        uint64 _startDate,\n        uint192 _maxMultiplier\n    ) external onlyOwner {\n        // no reason to have a multiplier more than 100x\n        if (_maxMultiplier > 10_000) {\n            revert InvalidMultiplier();\n        }\n        packedStartDateAndMaxMultiplier =\n            (uint256(_startDate) << 192) |\n            _maxMultiplier;\n    }\n\n    /**\n     * @notice Set the Store Contract\n     * @param _shopContract The address of the Store Contract\n     */\n    function setShopContract(address _shopContract) external onlyOwner {\n        if (address(shopContract) != address(0)) {\n            // Revoke the approval of the old contract\n            token.approve(address(shopContract), 0);\n        }\n        shopContract = ITokenShop(_shopContract);\n        //ensure we don't need to approve every tx\n        token.approve(address(shopContract), type(uint256).max);\n    }\n\n    /**\n     * @notice setBonusMultiplier\n     * @param _bonusMultiplier The bonus multiplier to apply to the user's points (Cannot be more then 1000)\n     */\n    function setBonusMultiplier(uint256 _bonusMultiplier) external onlyOwner {\n        if (_bonusMultiplier > 1000) {\n            revert InvalidMultiplier();\n        }\n        bonusMultiplier = _bonusMultiplier;\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param index The index of the claim\n    // @param amount The amount of tokens to deposit\n    // @param merkleProof The Merkle proof for the claim\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function claimAndDepositPermit(\n        uint256 index,\n        uint256 amount,\n        uint256 permitAmount,\n        bytes32[] calldata merkleProof,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        // Use ERC20Permit to allow the contract to spend the tokens\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Claim from Claim Contract and deposit for an increased multiplier\n    // @param amount The amount of tokens to deposit\n    // @param account The address of the account to deposit the tokens\n    // @param merkleProof The Merkle proof for the claim\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function claimAndDeposit(\n        uint256 index,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external nonReentrant whenNotPaused {\n        claim.claim(index, _msgSender(), amount, merkleProof);\n        _deposit(amount, bonusMultiplier); //deposit with 0.5x multiplier\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param deadline The timestamp until which the permit is valid\n    // @param v The recovery byte of the signature\n    // @param r Half of the ECDSA signature pair\n    // @param s Half of the ECDSA signature pair\n    function depositPermit(\n        uint256 amount,\n        uint256 permitAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(address(token)).permit(\n            _msgSender(),\n            address(this),\n            permitAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n        _deposit(amount, 0);\n    }\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        _deposit(amount, 0);\n    }\n\n    // @notice Withdraw ERC20 tokens from the contract\n    // @param amount The amount of tokens to withdraw\n    // @dev The user must have enough tokens staked to withdraw the specified amount\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        if (user.erc20balance < amount) {\n            revert InsufficientBalance();\n        }\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance - amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n        user.multiplier = uint16(currentMultiplier());\n\n        token.safeTransfer(_msgSender(), amount);\n        emit Withdraw(_msgSender(), amount, user.multiplier);\n    }\n\n    /**\n     * @notice Purchase items from Shop using Staked tokens without losing multiplier\n     * @param skuEntities listingId\n     * @param quantities amount per listing id\n     */\n    function purchase(\n        uint256[] calldata skuEntities,\n        uint256[] calldata quantities\n    ) external nonReentrant whenNotPaused {\n        if (skuEntities.length != quantities.length) {\n            revert InvalidPurchase();\n        }\n\n        if (shopContract == ITokenShop(address(0))) {\n            revert InvalidPurchaseContract();\n        }\n\n        UserStakeInfo storage user = users[_msgSender()];\n\n        user.accumulatedPoints = _totalPoints(user);\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        (uint256 purchaseId, uint256 total) = shopContract.purchaseFromStake(\n            _msgSender(),\n            skuEntities,\n            quantities\n        );\n\n        if (user.erc20balance < total) {\n            revert InsufficientBalance();\n        }\n\n        if (purchaseId == 0) {\n            revert InvalidPurchase();\n        }\n\n        user.erc20balance = user.erc20balance - total;\n        emit Withdraw(_msgSender(), total, user.multiplier);\n    }\n\n    // @notice Returns the current global multiplier value\n    // @dev The multiplier decays linearly over time from the start date to 100\n    function currentMultiplier() public view returns (uint256) {\n        uint256 packedValue = packedStartDateAndMaxMultiplier;\n        uint256 startDate = packedValue >> 192;\n        uint256 multiplier = packedValue & 0xFFFFFFFFFFFFFFFFFFFFFFFF;\n\n        uint256 daysPassed = (block.timestamp - startDate) / 1 days; // Number of days passed since the start date\n        unchecked {\n            uint256 decay = daysPassed * 10; // Calculate the total decay\n\n            if (decay < multiplier) {\n                multiplier -= decay;\n                if (multiplier < 100) {\n                    multiplier = 100;\n                }\n            } else {\n                multiplier = 100;\n            }\n        }\n\n        return multiplier;\n    }\n\n    /**\n     * Getters\n     */\n\n    // @notice Returns the multiplier for a specific user\n    // @param user The address of the user\n    // @return The multiplier for the user\n    function getMultiplier(address user) external view returns (uint256) {\n        return users[user].multiplier;\n    }\n\n    // @notice Returns the how many ERC20 Tokens are staked for a user\n    // @param user The address of the user\n    // @return The ERC20 balance of tokens staked for the user\n    function getErc20Balance(address user) external view returns (uint256) {\n        return users[user].erc20balance;\n    }\n\n    // @notice Returns the total points earned by a user\n    // @param user The address of the user\n    // @return The total points earned by the user\n    function getPointsBalance(address user) external view returns (uint256) {\n        return _totalPoints(users[user]);\n    }\n\n    /**\n     * Private\n     */\n\n    // @notice Deposit ERC20 tokens into the contract\n    // @param amount The amount of tokens to deposit\n    // @param bonusMultiplier The bonus multiplier to apply to the user's points\n    // @dev The user must approve the contract to spend the tokens before calling this function\n    function _deposit(uint256 amount, uint256 bonus) private {\n        if (amount == 0) {\n            revert IncorrectAmount();\n        }\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        UserStakeInfo storage user = users[_msgSender()];\n        user.accumulatedPoints = _totalPoints(user);\n        user.erc20balance = user.erc20balance + amount;\n        user.lastUpdatedTime = uint64(block.timestamp);\n\n        if (user.erc20initial == 0) {\n            user.erc20initial = amount;\n        }\n\n        if (user.multiplier == 0) {\n            user.multiplier = uint16(currentMultiplier() + bonus);\n        }\n        emit Deposit(_msgSender(), amount, user.multiplier);\n    }\n\n    // @notice Calculate the base points earned by a user\n    // @param user The user's staking information\n    // @return The base points earned by the user\n    function _basePoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        return\n            (user.erc20balance * (block.timestamp - user.lastUpdatedTime)) /\n            1 hours;\n    }\n\n    // @notice Calculate the total points earned by a user\n    // @param user The user's staking information\n    // @return The total points earned by the user\n    function _totalPoints(\n        UserStakeInfo storage user\n    ) private view returns (uint256) {\n        unchecked {\n            // This is a max multiplier value is maxMultiplier * token max ~ 100 bits for a token capped at 10M 1e18 decimal tokens multipled by a 64 bit number, so 164 bits, no overflow\n            return\n                ((_basePoints(user) * user.multiplier) / 100) +\n                user.accumulatedPoints;\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 818, 'end_line': 819, 'offset_start': 32778, 'offset_end': 32836, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 821, 'end_line': 822, 'offset_start': 32843, 'offset_end': 32911, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 823, 'end_line': 825, 'offset_start': 32917, 'offset_end': 33012, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 827, 'end_line': 829, 'offset_start': 33019, 'offset_end': 33117, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 831, 'end_line': 833, 'offset_start': 33124, 'offset_end': 33220, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 1013, 'end_line': 1017, 'offset_start': 40309, 'offset_end': 40449, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 1027, 'end_line': 1038, 'offset_start': 40936, 'offset_end': 41357, 'content': 'function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 1043, 'end_line': 1045, 'offset_start': 41468, 'offset_end': 41595, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 1050, 'end_line': 1052, 'offset_start': 41712, 'offset_end': 41831, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 1058, 'end_line': 1062, 'offset_start': 41962, 'offset_end': 42131, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardTransient._nonReentrantBefore', 'start_line': 1108, 'end_line': 1116, 'offset_start': 43498, 'offset_end': 43843, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(true);\n    }', 'contract_name': 'ReentrancyGuardTransient', 'contract_code': '{\n    using StorageSlot for *;\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(true);\n    }\n\n    function _nonReentrantAfter() private {\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(false);\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return REENTRANCY_GUARD_STORAGE.asBoolean().tload();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardTransient._nonReentrantAfter', 'start_line': 1118, 'end_line': 1120, 'offset_start': 43850, 'offset_end': 43954, 'content': 'function _nonReentrantAfter() private {\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(false);\n    }', 'contract_name': 'ReentrancyGuardTransient', 'contract_code': '{\n    using StorageSlot for *;\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(true);\n    }\n\n    function _nonReentrantAfter() private {\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(false);\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return REENTRANCY_GUARD_STORAGE.asBoolean().tload();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardTransient._reentrancyGuardEntered', 'start_line': 1126, 'end_line': 1128, 'offset_start': 44134, 'offset_end': 44265, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return REENTRANCY_GUARD_STORAGE.asBoolean().tload();\n    }', 'contract_name': 'ReentrancyGuardTransient', 'contract_code': '{\n    using StorageSlot for *;\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(true);\n    }\n\n    function _nonReentrantAfter() private {\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(false);\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return REENTRANCY_GUARD_STORAGE.asBoolean().tload();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._getPausableStorage', 'start_line': 1157, 'end_line': 1161, 'offset_start': 45417, 'offset_end': 45578, 'content': 'function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init', 'start_line': 1186, 'end_line': 1188, 'offset_start': 46106, 'offset_end': 46202, 'content': 'function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init_unchained', 'start_line': 1190, 'end_line': 1193, 'offset_start': 46209, 'offset_end': 46364, 'content': 'function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.paused', 'start_line': 1222, 'end_line': 1225, 'offset_start': 46962, 'offset_end': 47106, 'content': 'function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requireNotPaused', 'start_line': 1230, 'end_line': 1234, 'offset_start': 47175, 'offset_end': 47302, 'content': 'function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requirePaused', 'start_line': 1239, 'end_line': 1243, 'offset_start': 47375, 'offset_end': 47500, 'content': 'function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._pause', 'start_line': 1252, 'end_line': 1256, 'offset_start': 47636, 'offset_end': 47811, 'content': 'function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._unpause', 'start_line': 1265, 'end_line': 1269, 'offset_start': 47944, 'offset_end': 48121, 'content': 'function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1298, 'end_line': 1298, 'offset_start': 48901, 'offset_end': 48955, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1303, 'end_line': 1303, 'offset_start': 49038, 'offset_end': 49105, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1312, 'end_line': 1312, 'offset_start': 49330, 'offset_end': 49398, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1321, 'end_line': 1321, 'offset_start': 49674, 'offset_end': 49756, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 1338, 'end_line': 1338, 'offset_start': 50435, 'offset_end': 50507, 'content': 'function approve(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 1349, 'end_line': 1349, 'offset_start': 50816, 'offset_end': 50902, 'content': 'function transferFrom(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._getOwnableStorage', 'start_line': 1381, 'end_line': 1385, 'offset_start': 52099, 'offset_end': 52257, 'content': 'function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 1402, 'end_line': 1404, 'offset_start': 52754, 'offset_end': 52880, 'content': 'function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 1406, 'end_line': 1411, 'offset_start': 52887, 'offset_end': 53121, 'content': 'function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 1424, 'end_line': 1427, 'offset_start': 53348, 'offset_end': 53491, 'content': 'function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 1432, 'end_line': 1436, 'offset_start': 53565, 'offset_end': 53726, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 1445, 'end_line': 1447, 'offset_start': 54062, 'offset_end': 54162, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 1453, 'end_line': 1458, 'offset_start': 54312, 'offset_end': 54526, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 1464, 'end_line': 1469, 'offset_start': 54681, 'offset_end': 54928, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1504, 'end_line': 1513, 'offset_start': 56223, 'offset_end': 56571, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1533, 'end_line': 1535, 'offset_start': 57417, 'offset_end': 57567, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1546, 'end_line': 1552, 'offset_start': 57892, 'offset_end': 58298, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1558, 'end_line': 1561, 'offset_start': 58438, 'offset_end': 58691, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1567, 'end_line': 1570, 'offset_start': 58833, 'offset_end': 59085, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1577, 'end_line': 1592, 'offset_start': 59354, 'offset_end': 59935, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1598, 'end_line': 1604, 'offset_start': 60138, 'offset_end': 60361, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1609, 'end_line': 1621, 'offset_start': 60476, 'offset_end': 60993, 'content': 'function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 1707, 'end_line': 1712, 'offset_start': 63512, 'offset_end': 63701, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 1717, 'end_line': 1722, 'offset_start': 63800, 'offset_end': 63989, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 1727, 'end_line': 1732, 'offset_start': 64088, 'offset_end': 64277, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 1737, 'end_line': 1742, 'offset_start': 64376, 'offset_end': 64565, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getInt256Slot', 'start_line': 1747, 'end_line': 1752, 'offset_start': 64663, 'offset_end': 64850, 'content': 'function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1757, 'end_line': 1762, 'offset_start': 64948, 'offset_end': 65135, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1767, 'end_line': 1772, 'offset_start': 65248, 'offset_end': 65449, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1777, 'end_line': 1782, 'offset_start': 65546, 'offset_end': 65731, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1787, 'end_line': 1792, 'offset_start': 65842, 'offset_end': 66040, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.asAddress', 'start_line': 1802, 'end_line': 1804, 'offset_start': 66232, 'offset_end': 66354, 'content': 'function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.asBoolean', 'start_line': 1814, 'end_line': 1816, 'offset_start': 66543, 'offset_end': 66665, 'content': 'function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.asBytes32', 'start_line': 1826, 'end_line': 1828, 'offset_start': 66857, 'offset_end': 66979, 'content': 'function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.asUint256', 'start_line': 1838, 'end_line': 1840, 'offset_start': 67171, 'offset_end': 67293, 'content': 'function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.asInt256', 'start_line': 1850, 'end_line': 1852, 'offset_start': 67482, 'offset_end': 67601, 'content': 'function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tload', 'start_line': 1857, 'end_line': 1862, 'offset_start': 67697, 'offset_end': 67883, 'content': 'function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tstore', 'start_line': 1867, 'end_line': 1872, 'offset_start': 67973, 'offset_end': 68145, 'content': 'function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tload', 'start_line': 1877, 'end_line': 1882, 'offset_start': 68241, 'offset_end': 68424, 'content': 'function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tstore', 'start_line': 1887, 'end_line': 1892, 'offset_start': 68514, 'offset_end': 68683, 'content': 'function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tload', 'start_line': 1897, 'end_line': 1902, 'offset_start': 68779, 'offset_end': 68965, 'content': 'function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tstore', 'start_line': 1907, 'end_line': 1912, 'offset_start': 69055, 'offset_end': 69227, 'content': 'function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tload', 'start_line': 1917, 'end_line': 1922, 'offset_start': 69323, 'offset_end': 69509, 'content': 'function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tstore', 'start_line': 1927, 'end_line': 1932, 'offset_start': 69599, 'offset_end': 69771, 'content': 'function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tload', 'start_line': 1937, 'end_line': 1942, 'offset_start': 69867, 'offset_end': 70051, 'content': 'function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.tstore', 'start_line': 1947, 'end_line': 1952, 'offset_start': 70141, 'offset_end': 70311, 'content': 'function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a address.\n     */\n    type AddressSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlotType.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlotType) {\n        return AddressSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bool.\n     */\n    type BooleanSlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlotType.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlotType) {\n        return BooleanSlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a bytes32.\n     */\n    type Bytes32SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32SlotType.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32SlotType) {\n        return Bytes32SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a uint256.\n     */\n    type Uint256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256SlotType.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256SlotType) {\n        return Uint256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represent a slot holding a int256.\n     */\n    type Int256SlotType is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256SlotType.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256SlotType) {\n        return Int256SlotType.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlotType slot) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlotType slot, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlotType slot) internal view returns (bool value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlotType slot, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32SlotType slot) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32SlotType slot, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256SlotType slot) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256SlotType slot, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256SlotType slot) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256SlotType slot, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(slot, value)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 1978, 'end_line': 1978, 'offset_start': 71107, 'offset_end': 71182, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x6759acd57cb5ea451a3edf397734edddfc123049/0x6759acd57cb5ea451a3edf397734edddfc123049.sol'}
