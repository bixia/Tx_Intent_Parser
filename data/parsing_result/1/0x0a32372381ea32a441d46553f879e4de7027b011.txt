{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 59, 'end_line': 64, 'offset_start': 1684, 'offset_end': 1873, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 69, 'end_line': 74, 'offset_start': 1972, 'offset_end': 2161, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 79, 'end_line': 84, 'offset_start': 2260, 'offset_end': 2449, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 89, 'end_line': 94, 'offset_start': 2548, 'offset_end': 2737, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 99, 'end_line': 104, 'offset_start': 2835, 'offset_end': 3022, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 109, 'end_line': 114, 'offset_start': 3135, 'offset_end': 3336, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 119, 'end_line': 124, 'offset_start': 3433, 'offset_end': 3618, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 129, 'end_line': 134, 'offset_start': 3729, 'offset_end': 3927, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 154, 'end_line': 155, 'offset_start': 4680, 'offset_end': 4738, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 157, 'end_line': 158, 'offset_start': 4745, 'offset_end': 4813, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 159, 'end_line': 161, 'offset_start': 4819, 'offset_end': 4914, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 163, 'end_line': 165, 'offset_start': 4921, 'offset_end': 5019, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 167, 'end_line': 169, 'offset_start': 5026, 'offset_end': 5122, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.tor', 'start_line': 223, 'end_line': 225, 'offset_start': 7143, 'offset_end': 7195, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.initialize', 'start_line': 227, 'end_line': 235, 'offset_start': 7202, 'offset_end': 7668, 'content': 'function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.claim', 'start_line': 243, 'end_line': 261, 'offset_start': 8076, 'offset_end': 8856, 'content': 'function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim._getCallerOrVaultIfDelegated', 'start_line': 270, 'end_line': 277, 'offset_start': 9269, 'offset_end': 9576, 'content': 'function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim._checkValidClaim', 'start_line': 279, 'end_line': 290, 'offset_start': 9583, 'offset_end': 10167, 'content': 'function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim._calculateClaim', 'start_line': 292, 'end_line': 318, 'offset_start': 10174, 'offset_end': 11404, 'content': 'function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim._verifyProof', 'start_line': 325, 'end_line': 331, 'offset_start': 11581, 'offset_end': 11935, 'content': 'function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim._checkValidSetup', 'start_line': 333, 'end_line': 345, 'offset_start': 11942, 'offset_end': 12551, 'content': 'function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.initDepositAndSetupTokenConfig', 'start_line': 357, 'end_line': 371, 'offset_start': 13041, 'offset_end': 13705, 'content': 'function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.depositToken', 'start_line': 379, 'end_line': 390, 'offset_start': 13985, 'offset_end': 14449, 'content': 'function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.withdrawExpiredToken', 'start_line': 397, 'end_line': 412, 'offset_start': 14648, 'offset_end': 15368, 'content': 'function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.setTokenMerkleRootById', 'start_line': 419, 'end_line': 427, 'offset_start': 15593, 'offset_end': 15882, 'content': 'function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.setTokenClaimStartTsById', 'start_line': 434, 'end_line': 446, 'offset_start': 16154, 'offset_end': 16694, 'content': 'function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.pauseTokenClaim', 'start_line': 448, 'end_line': 452, 'offset_start': 16701, 'offset_end': 16876, 'content': 'function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.unpauseTokenClaim', 'start_line': 454, 'end_line': 458, 'offset_start': 16883, 'offset_end': 17050, 'content': 'function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.pauseClaim', 'start_line': 460, 'end_line': 464, 'offset_start': 17057, 'offset_end': 17184, 'content': 'function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.unpauseClaim', 'start_line': 466, 'end_line': 470, 'offset_start': 17191, 'offset_end': 17310, 'content': 'function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.getTokenConfigById', 'start_line': 479, 'end_line': 481, 'offset_start': 17596, 'offset_end': 17726, 'content': 'function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.getTokenBalanceById', 'start_line': 487, 'end_line': 490, 'offset_start': 17853, 'offset_end': 18077, 'content': 'function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.getTokensClaimedByUserAndId', 'start_line': 497, 'end_line': 499, 'offset_start': 18235, 'offset_end': 18393, 'content': 'function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'StakelandFarmClaim.getTokensClaimableByClaimInfo', 'start_line': 507, 'end_line': 514, 'offset_start': 18657, 'offset_end': 18981, 'content': 'function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }', 'contract_name': 'StakelandFarmClaim', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");\n    uint256 private constant _BASIS_POINTS = 10000;\n\n    /// @dev farmId is a unique ID used to align off-chain info about each farming campaign\n    mapping(uint16 farmId => TokenConfig) private _tokenConfigs;\n    mapping(address user => mapping(uint16 farmId => uint256 tokensClaimed)) private _usersTokensClaimedById;\n\n    IDelegateRegistry private _dcV2;\n\n    bool public claimPaused;\n\n    modifier onlyClaimNotPaused() {\n        if (claimPaused) revert ClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimNotPausedById(uint16 farmId) {\n        if (_tokenConfigs[farmId].paused) revert TokenClaimPaused();\n        _;\n    }\n\n    modifier onlyClaimPausedById(uint16 farmId) {\n        if (!_tokenConfigs[farmId].paused) revert TokenClaimNotPaused();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address opAdmin, address pauser) public initializer {\n        UUPSUpgrader.__UUPSUpgrader_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        OwnableUpgradeable.__Ownable_init(_msgSender());\n        AccessControlUpgradeable.__AccessControl_init();\n        _dcV2 = IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\n        _grantRole(DEFAULT_ADMIN_ROLE, opAdmin);\n        _grantRole(PAUSER_ROLE, pauser);\n    }\n\n    /**\n     * @notice Claim token based on allocated amount, claim will be expired after started for `TokenConfig.expiryInDays * 1 days` for respective token vest\n     * @dev Transfer token to eligible user if provided sig is valid, emit { Claimed } event\n     * @param vault Address to claim for, could be a delegated wallet\n     * @param tokenClaim TokensClaim to claim by multiple farmIds\n     */\n    function claim(address vault, TokenClaim calldata tokenClaim)\n        external\n        nonReentrant\n        onlyClaimNotPaused\n        onlyClaimNotPausedById(tokenClaim.farmId)\n    {\n        address claimer = _getCallerOrVaultIfDelegated(vault);\n\n        TokenConfig memory tokenConfig = _tokenConfigs[tokenClaim.farmId];\n\n        _checkValidClaim(claimer, tokenConfig, tokenClaim);\n        uint256 amount = _calculateClaim(claimer, tokenConfig, tokenClaim.farmId, tokenClaim.totalAllocated);\n        if (amount == 0) revert ZeroClaimAmount();\n\n        _usersTokensClaimedById[claimer][tokenClaim.farmId] += amount;\n        IERC20(tokenConfig.token).safeTransfer(claimer, amount);\n\n        emit Claimed(claimer, tokenClaim.farmId, tokenConfig.token, amount, block.timestamp);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INTERNALS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @dev Support v2 delegate wallet. Given vault (cold wallet) address, verify whether _msgSender() is a permitted delegate to operate on behalf of it\n     * @param vault Address to verify against _msgSender\n     */\n    function _getCallerOrVaultIfDelegated(address vault) private view returns (address) {\n        if (vault == address(0)) return _msgSender();\n\n        bool isDelegateValid = _dcV2.checkDelegateForAll(_msgSender(), vault, "");\n        if (!isDelegateValid) revert InvalidDelegate();\n\n        return vault;\n    }\n\n    function _checkValidClaim(address user, TokenConfig memory tokenConfig, TokenClaim calldata tokenClaim)\n        internal\n        view\n    {\n        if (tokenConfig.token == address(0)) revert NonExistentFarmClaim();\n        if (block.timestamp < tokenConfig.claimStartTs) revert ClaimNotAvailable();\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        if (block.timestamp > expiryTs) revert TokenClaimExpired();\n\n        if (!_verifyProof(user, tokenClaim)) revert InvalidProof();\n    }\n\n    function _calculateClaim(address user, TokenConfig memory tokenConfig, uint16 farmId, uint240 totalAllocated)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        // instant unlocked\n        uint256 initialUnlocked = totalAllocated * tokenConfig.initialUnlockBP / _BASIS_POINTS;\n        // block.timestamp must be larger than tokenConfig.claimStartTs at this point\n        uint256 daysElapsed = (block.timestamp - tokenConfig.claimStartTs) / 1 days;\n        uint256 userClaimed = _usersTokensClaimedById[user][farmId];\n\n        if (daysElapsed >= tokenConfig.vestDurationInDays) {\n            // fully vested\n            amount = totalAllocated - userClaimed;\n        } else {\n            // totalAllocated must be larger than initialUnlocked at this point\n            uint256 vestedTokensClaimable =\n                (totalAllocated - initialUnlocked) * daysElapsed / tokenConfig.vestDurationInDays;\n            uint256 totalTokensClaimable = initialUnlocked + vestedTokensClaimable;\n\n            amount = totalTokensClaimable > userClaimed ? totalTokensClaimable - userClaimed : 0;\n        }\n\n        if (userClaimed + amount > totalAllocated) {\n            revert ClaimMoreThanAllocated();\n        }\n    }\n\n    /**\n     * @dev Verify the proof against the Merkle root of specified farmId\n     * @param user The address of user\n     * @param tokenClaim Token claim data\n     */\n    function _verifyProof(address user, TokenClaim calldata tokenClaim) private view returns (bool) {\n        return MerkleProof.verifyCalldata(\n            tokenClaim.proof,\n            _tokenConfigs[tokenClaim.farmId].merkleRoot,\n            keccak256(bytes.concat(keccak256(abi.encode(user, tokenClaim.farmId, tokenClaim.totalAllocated))))\n        );\n    }\n\n    function _checkValidSetup(address depositor, uint16 farmId, uint256 amount, TokenConfig calldata tokenConfig)\n        internal\n        pure\n    {\n        // this contract only records farmId starting from season 2, so no 0 and 1 farmId\n        if (\n            depositor == address(0) || farmId == 0 || farmId == 1 || amount == 0 || tokenConfig.token == address(0)\n                || tokenConfig.initialUnlockBP > _BASIS_POINTS || tokenConfig.expiryInDays == 0\n                || tokenConfig.claimStartTs == 0 || tokenConfig.merkleRoot.length == 0\n        ) {\n            revert InvalidSetup();\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADMIN\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Deposit token to contract everytime there is a new token config, from a specified depositor\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     * @param tokenConfig Token config data\n     */\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_tokenConfigs[farmId].token != address(0)) revert AlreadyInitializedDepositAndSetup();\n        _checkValidSetup(depositor, farmId, amount, tokenConfig);\n\n        // just as a general practice to put safeTransferFrom first to cope with ERC777 reentrancy\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n        _tokenConfigs[farmId] = tokenConfig;\n\n        emit InitTokenConfigSetAndDeposited(farmId, amount);\n    }\n\n    /**\n     * @notice Explicit function to deposit token to contract again in case the initial amount deposited is incorrect\n     * @param depositor Address to do the deposit\n     * @param farmId Id of the farm\n     * @param amount Amount of token to be deposited\n     */\n    function depositToken(address depositor, uint16 farmId, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (depositor == address(0) || amount == 0 || tokenConfig.token == address(0)) {\n            revert InvalidDepositSetup();\n        }\n\n        IERC20(tokenConfig.token).safeTransferFrom(depositor, address(this), amount);\n    }\n\n    /**\n     * @notice Withdraw unclaimed token from contract after its claim period is expired\n     * @param farmId Id of the farm\n     * @param receiver Address to receive the token\n     */\n    function withdrawExpiredToken(uint16 farmId, address receiver) external onlyOwner {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        uint256 expiryTs =\n            tokenConfig.claimStartTs + tokenConfig.vestDurationInDays * 1 days + tokenConfig.expiryInDays * 1 days;\n        address token = tokenConfig.token;\n\n        if (block.timestamp <= expiryTs) {\n            revert TokenClaimNotExpired();\n        }\n        if (token == address(0) || receiver == address(0)) revert InvalidWithdrawalSetup();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(receiver, balance);\n\n        emit ExpiredTokenWithdrawn(farmId, token, balance, receiver);\n    }\n\n    /**\n     * @notice Set the new Merkle Root for token by its farmId in case the initial setup is incorrect\n     * @param farmId Id of the farm\n     * @param newMerkleRoot New Merkle Root for the token claim\n     */\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        _tokenConfigs[farmId].merkleRoot = newMerkleRoot;\n\n        emit TokenMerkleRootUpdated(farmId, newMerkleRoot);\n    }\n\n    /**\n     * @notice Set the new claim start timestamp for token by its farmId, cannot be updated once token vesting starts\n     * @param farmId Id of the farm\n     * @param newTokenClaimStartTs New start timestamp for the token claim, can be in the past\n     */\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyClaimPausedById(farmId)\n    {\n        if (newTokenClaimStartTs == 0) revert InvalidClaimStartTs();\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        if (block.timestamp > tokenConfig.claimStartTs) revert TokenClaimAlreadyStarted();\n\n        _tokenConfigs[farmId].claimStartTs = newTokenClaimStartTs;\n\n        emit TokenClaimStartTsUpdated(farmId, newTokenClaimStartTs);\n    }\n\n    function pauseTokenClaim(uint16 farmId) external onlyRole(PAUSER_ROLE) {\n        _tokenConfigs[farmId].paused = true;\n\n        emit TokenClaimStatusUpdated(farmId, true);\n    }\n\n    function unpauseTokenClaim(uint16 farmId) external onlyOwner {\n        _tokenConfigs[farmId].paused = false;\n\n        emit TokenClaimStatusUpdated(farmId, false);\n    }\n\n    function pauseClaim() external onlyRole(PAUSER_ROLE) {\n        claimPaused = true;\n\n        emit ClaimStatusUpdated(true);\n    }\n\n    function unpauseClaim() external onlyOwner {\n        claimPaused = false;\n\n        emit ClaimStatusUpdated(false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEWS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Get the token config by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory) {\n        return _tokenConfigs[farmId];\n    }\n\n    /**\n     * @notice Get the token balance of this contract by its farmId\n     * @param farmId Id of the farm\n     */\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance) {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        balance = IERC20(tokenConfig.token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get the tokens claimed by user by its farmId\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     */\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256) {\n        return _usersTokensClaimedById[user][farmId];\n    }\n\n    /**\n     * @notice Get the tokens claimable by user by its farmId and total allocated amount\n     * @param user Address of the user\n     * @param farmId Id of the farm\n     * @param totalAllocated Total allocated amount for the user of the farm\n     */\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256 tokensClaimable)\n    {\n        TokenConfig memory tokenConfig = _tokenConfigs[farmId];\n        tokensClaimable = _calculateClaim(user, tokenConfig, farmId, totalAllocated);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 694, 'end_line': 698, 'offset_start': 26070, 'offset_end': 26210, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 708, 'end_line': 719, 'offset_start': 26697, 'offset_end': 27118, 'content': 'function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 724, 'end_line': 726, 'offset_start': 27229, 'offset_end': 27356, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 731, 'end_line': 733, 'offset_start': 27473, 'offset_end': 27592, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 739, 'end_line': 743, 'offset_start': 27723, 'offset_end': 27892, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._getReentrancyGuardStorage', 'start_line': 791, 'end_line': 795, 'offset_start': 30148, 'offset_end': 30330, 'content': 'function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 802, 'end_line': 804, 'offset_start': 30437, 'offset_end': 30547, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 806, 'end_line': 809, 'offset_start': 30554, 'offset_end': 30736, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 824, 'end_line': 833, 'offset_start': 31223, 'offset_end': 31606, 'content': 'function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 835, 'end_line': 840, 'offset_start': 31613, 'offset_end': 31895, 'content': 'function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 846, 'end_line': 849, 'offset_start': 32075, 'offset_end': 32255, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 878, 'end_line': 878, 'offset_start': 33034, 'offset_end': 33088, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 883, 'end_line': 883, 'offset_start': 33171, 'offset_end': 33238, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 892, 'end_line': 892, 'offset_start': 33463, 'offset_end': 33531, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 901, 'end_line': 901, 'offset_start': 33807, 'offset_end': 33889, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 918, 'end_line': 918, 'offset_start': 34568, 'offset_end': 34640, 'content': 'function approve(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 929, 'end_line': 929, 'offset_start': 34949, 'offset_end': 35035, 'content': 'function transferFrom(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader._authorizeUpgrade', 'start_line': 940, 'end_line': 940, 'offset_start': 35417, 'offset_end': 35485, 'content': 'function _authorizeUpgrade(address) internal override onlyUpgrader {}', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader._getUUPSUpgraderStorage', 'start_line': 952, 'end_line': 956, 'offset_start': 35901, 'offset_end': 36074, 'content': 'function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader.__UUPSUpgrader_init', 'start_line': 969, 'end_line': 971, 'offset_start': 36379, 'offset_end': 36476, 'content': 'function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader.upgrader', 'start_line': 973, 'end_line': 975, 'offset_start': 36483, 'offset_end': 36599, 'content': 'function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader.upgraderRenounced', 'start_line': 977, 'end_line': 979, 'offset_start': 36606, 'offset_end': 36729, 'content': 'function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader.setUpgrader', 'start_line': 985, 'end_line': 993, 'offset_start': 36887, 'offset_end': 37227, 'content': 'function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgrader.renounceUpgrader', 'start_line': 996, 'end_line': 1004, 'offset_start': 37327, 'offset_end': 37615, 'content': 'function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }', 'contract_name': 'UUPSUpgrader', 'contract_code': '{\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyUpgrader {}\n\n    /// @custom:storage-location erc7201:erc1967.storage.UUPSUpgrader\n    struct UUPSUpgraderStorage {\n        address _upgrader;\n        bool _renounced;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("erc1967.storage.UUPSUpgrader")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant UUPSUpgraderStorageLocation =\n        0x36fe60292965fa39d478b2a95eaaedd2437ced0f0f3be1bee98dff396c747b00;\n\n    function _getUUPSUpgraderStorage() private pure returns (UUPSUpgraderStorage storage $) {\n        assembly {\n            $.slot := UUPSUpgraderStorageLocation\n        }\n    }\n\n    error InvalidUpgrader();\n    error UnauthorizedUpgrader(address upgrader);\n    error UpgraderAlreadyRenounced();\n\n    event UpgraderUpdated(address newUpgrader);\n\n    modifier onlyUpgrader() {\n        if (_msgSender() != upgrader()) revert UnauthorizedUpgrader(_msgSender());\n        _;\n    }\n\n    function __UUPSUpgrader_init() internal onlyInitializing {\n        __UUPSUpgradeable_init();\n    }\n\n    function upgrader() public view virtual returns (address) {\n        return _getUUPSUpgraderStorage()._upgrader;\n    }\n\n    function upgraderRenounced() public view virtual returns (bool) {\n        return _getUUPSUpgraderStorage()._renounced;\n    }\n\n    /**\n     * @notice Set the new UUPS proxy upgrader. Can only be called by the owner.\n     * @param newUpgrader The address of new upgrader\n     */\n    function setUpgrader(address newUpgrader) external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        if (newUpgrader == address(0)) revert InvalidUpgrader();\n        $._upgrader = newUpgrader;\n\n        emit UpgraderUpdated(newUpgrader);\n    }\n\n    /// @notice Renounce the upgradibility of the contract. Can only be called by the owner.\n    function renounceUpgrader() external onlyOwner {\n        UUPSUpgraderStorage storage $ = _getUUPSUpgraderStorage();\n        if ($._renounced) revert UpgraderAlreadyRenounced();\n\n        $._renounced = true;\n        $._upgrader = address(0);\n\n        emit UpgraderUpdated(address(0));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getImplementation', 'start_line': 1068, 'end_line': 1070, 'offset_start': 39577, 'offset_end': 39714, 'content': 'function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setImplementation', 'start_line': 1075, 'end_line': 1080, 'offset_start': 39806, 'offset_end': 40086, 'content': 'function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeToAndCall', 'start_line': 1089, 'end_line': 1098, 'offset_start': 40399, 'offset_end': 40733, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getAdmin', 'start_line': 1114, 'end_line': 1116, 'offset_start': 41412, 'offset_end': 41531, 'content': 'function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setAdmin', 'start_line': 1121, 'end_line': 1126, 'offset_start': 41614, 'offset_end': 41830, 'content': 'function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.changeAdmin', 'start_line': 1133, 'end_line': 1136, 'offset_start': 41951, 'offset_end': 42083, 'content': 'function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getBeacon', 'start_line': 1148, 'end_line': 1150, 'offset_start': 42530, 'offset_end': 42651, 'content': 'function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setBeacon', 'start_line': 1155, 'end_line': 1166, 'offset_start': 42734, 'offset_end': 43170, 'content': 'function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeBeaconToAndCall', 'start_line': 1179, 'end_line': 1188, 'offset_start': 43696, 'offset_end': 44028, 'content': 'function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._checkNonPayable', 'start_line': 1194, 'end_line': 1198, 'offset_start': 44218, 'offset_end': 44339, 'content': 'function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    // We re-declare ERC-1967 events here because they can\'t be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn\'t perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 1266, 'end_line': 1274, 'offset_start': 47341, 'offset_end': 47523, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 1283, 'end_line': 1283, 'offset_start': 47829, 'offset_end': 47891, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 1289, 'end_line': 1289, 'offset_start': 48084, 'offset_end': 48143, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1332, 'end_line': 1341, 'offset_start': 49679, 'offset_end': 50009, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1361, 'end_line': 1363, 'offset_start': 50853, 'offset_end': 51003, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1374, 'end_line': 1380, 'offset_start': 51328, 'offset_end': 51719, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1386, 'end_line': 1389, 'offset_start': 51859, 'offset_end': 52112, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1395, 'end_line': 1398, 'offset_start': 52254, 'offset_end': 52506, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1405, 'end_line': 1420, 'offset_start': 52773, 'offset_end': 53354, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1426, 'end_line': 1432, 'offset_start': 53555, 'offset_end': 53778, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1437, 'end_line': 1449, 'offset_start': 53891, 'offset_end': 54406, 'content': 'function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._getAccessControlStorage', 'start_line': 1518, 'end_line': 1522, 'offset_start': 57199, 'offset_end': 57375, 'content': 'function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 1533, 'end_line': 1534, 'offset_start': 57643, 'offset_end': 57707, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 1536, 'end_line': 1537, 'offset_start': 57714, 'offset_end': 57788, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 1541, 'end_line': 1543, 'offset_start': 57855, 'offset_end': 58056, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 1548, 'end_line': 1551, 'offset_start': 58144, 'offset_end': 58350, 'content': 'function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1557, 'end_line': 1559, 'offset_start': 58560, 'offset_end': 58662, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1565, 'end_line': 1569, 'offset_start': 58793, 'offset_end': 58989, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 1577, 'end_line': 1580, 'offset_start': 59171, 'offset_end': 59361, 'content': 'function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 1594, 'end_line': 1596, 'offset_start': 59658, 'offset_end': 59793, 'content': 'function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 1609, 'end_line': 1611, 'offset_start': 60074, 'offset_end': 60211, 'content': 'function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 1629, 'end_line': 1635, 'offset_start': 60760, 'offset_end': 61004, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 1642, 'end_line': 1647, 'offset_start': 61130, 'offset_end': 61447, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 1656, 'end_line': 1665, 'offset_start': 61682, 'offset_end': 62068, 'content': 'function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 1674, 'end_line': 1683, 'offset_start': 62304, 'offset_end': 62691, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822Proxiable.proxiableUUID', 'start_line': 1704, 'end_line': 1704, 'offset_start': 63516, 'offset_end': 63572, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822Proxiable', 'contract_code': '{\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.multicall', 'start_line': 1783, 'end_line': 1783, 'offset_start': 66036, 'offset_end': 66127, 'content': 'function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.delegateAll', 'start_line': 1792, 'end_line': 1792, 'offset_start': 66578, 'offset_end': 66689, 'content': 'function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.delegateContract', 'start_line': 1802, 'end_line': 1805, 'offset_start': 67216, 'offset_end': 67375, 'content': 'function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.delegateERC721', 'start_line': 1816, 'end_line': 1819, 'offset_start': 67953, 'offset_end': 68127, 'content': 'function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.delegateERC20', 'start_line': 1830, 'end_line': 1833, 'offset_start': 68757, 'offset_end': 68916, 'content': 'function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.delegateERC1155', 'start_line': 1845, 'end_line': 1848, 'offset_start': 69617, 'offset_end': 69795, 'content': 'function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.checkDelegateForAll', 'start_line': 1861, 'end_line': 1861, 'offset_start': 70263, 'offset_end': 70362, 'content': 'function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.checkDelegateForContract', 'start_line': 1871, 'end_line': 1874, 'offset_start': 70911, 'offset_end': 71058, 'content': 'function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.checkDelegateForERC721', 'start_line': 1885, 'end_line': 1888, 'offset_start': 71718, 'offset_end': 71880, 'content': 'function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.checkDelegateForERC20', 'start_line': 1898, 'end_line': 1901, 'offset_start': 72398, 'offset_end': 72545, 'content': 'function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.checkDelegateForERC1155', 'start_line': 1912, 'end_line': 1915, 'offset_start': 73135, 'offset_end': 73301, 'content': 'function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.getIncomingDelegations', 'start_line': 1926, 'end_line': 1926, 'offset_start': 73574, 'offset_end': 73673, 'content': 'function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.getOutgoingDelegations', 'start_line': 1933, 'end_line': 1933, 'offset_start': 73882, 'offset_end': 73983, 'content': 'function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.getIncomingDelegationHashes', 'start_line': 1940, 'end_line': 1940, 'offset_start': 74231, 'offset_end': 74337, 'content': 'function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.getOutgoingDelegationHashes', 'start_line': 1947, 'end_line': 1947, 'offset_start': 74588, 'offset_end': 74696, 'content': 'function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.getDelegationsFromHashes', 'start_line': 1954, 'end_line': 1957, 'offset_start': 74997, 'offset_end': 75147, 'content': 'function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.readSlot', 'start_line': 1966, 'end_line': 1966, 'offset_start': 75306, 'offset_end': 75373, 'content': 'function readSlot(bytes32 location) external view returns (bytes32);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IDelegateRegistry.readSlots', 'start_line': 1971, 'end_line': 1971, 'offset_start': 75481, 'offset_end': 75570, 'content': 'function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);', 'contract_name': 'IDelegateRegistry', 'contract_code': "{\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        ERC721,\n        ERC20,\n        ERC1155\n    }\n\n    /// @notice Struct for returning delegations\n    struct Delegation {\n        DelegationType type_;\n        address to;\n        address from;\n        bytes32 rights;\n        address contract_;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\n\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\n    event DelegateContract(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\n    event DelegateERC721(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        bool enable\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\n    event DelegateERC20(\n        address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount\n    );\n\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\n    event DelegateERC1155(\n        address indexed from,\n        address indexed to,\n        address indexed contract_,\n        uint256 tokenId,\n        bytes32 rights,\n        uint256 amount\n    );\n\n    /// @notice Thrown if multicall calldata is malformed\n    error MulticallFailed();\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n     * @param data The encoded function data for each of the calls to make to this contract\n     * @return results The results from each of the calls passed in via data\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\n     * @param to The address to act as delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\n     * @param to The address to act as delegate\n     * @param contract_ The contract whose rights are being delegated\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address for the fungible token contract\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\n     * @param to The address to act as delegate\n     * @param contract_ The address of the contract that holds the token\n     * @param tokenId The token id to delegate\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\n     * @return delegationHash The unique identifier of the delegation\n     */\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount)\n        external\n        payable\n        returns (bytes32 delegationHash);\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\n     * @param to The potential delegate address\n     * @param from The potential address who delegated rights\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on the from's behalf\n     */\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\n     */\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\n     * @param to The delegated address to check\n     * @param contract_ The specific contract address being checked\n     * @param tokenId The token id for the token to delegating\n     * @param from The wallet that issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\n     */\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\n     * @param to The delegated address to check\n     * @param contract_ The address of the token contract\n     * @param tokenId The token id to check the delegated amount of\n     * @param from The cold wallet who issued the delegation\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\n     */\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /**\n     * @notice Returns all enabled delegations a given delegate has received\n     * @param to The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all enabled delegations an address has given out\n     * @param from The address to retrieve delegations for\n     * @return delegations Array of Delegation structs\n     */\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has received\n     * @param to The address to retrieve incoming delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns all hashes associated with enabled delegations an address has given out\n     * @param from The address to retrieve outgoing delegation hashes for\n     * @return delegationHashes Array of delegation hashes\n     */\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\n\n    /**\n     * @notice Returns the delegations for a given array of delegation hashes\n     * @param delegationHashes is an array of hashes that correspond to delegations\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\n     */\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes)\n        external\n        view\n        returns (Delegation[] memory delegations);\n\n    /**\n     * ----------- STORAGE ACCESS -----------\n     */\n\n    /**\n     * @notice Allows external contracts to read arbitrary storage slots\n     */\n    function readSlot(bytes32 location) external view returns (bytes32);\n\n    /**\n     * @notice Allows external contracts to read an arbitrary array of storage slots\n     */\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.claim', 'start_line': 2020, 'end_line': 2020, 'offset_start': 77128, 'offset_end': 77198, 'content': 'function claim(address vault, TokenClaim calldata tokenClaim) external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.initDepositAndSetupTokenConfig', 'start_line': 2022, 'end_line': 2027, 'offset_start': 77205, 'offset_end': 77375, 'content': 'function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.depositToken', 'start_line': 2028, 'end_line': 2028, 'offset_start': 77381, 'offset_end': 77461, 'content': 'function depositToken(address depositor, uint16 farmId, uint256 amount) external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.withdrawExpiredToken', 'start_line': 2029, 'end_line': 2029, 'offset_start': 77467, 'offset_end': 77538, 'content': 'function withdrawExpiredToken(uint16 farmId, address receiver) external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.setTokenMerkleRootById', 'start_line': 2031, 'end_line': 2031, 'offset_start': 77545, 'offset_end': 77623, 'content': 'function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.setTokenClaimStartTsById', 'start_line': 2032, 'end_line': 2032, 'offset_start': 77629, 'offset_end': 77715, 'content': 'function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.pauseClaim', 'start_line': 2034, 'end_line': 2034, 'offset_start': 77722, 'offset_end': 77752, 'content': 'function pauseClaim() external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.unpauseClaim', 'start_line': 2035, 'end_line': 2035, 'offset_start': 77758, 'offset_end': 77790, 'content': 'function unpauseClaim() external;', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.getTokenConfigById', 'start_line': 2037, 'end_line': 2037, 'offset_start': 77797, 'offset_end': 77882, 'content': 'function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.getTokenBalanceById', 'start_line': 2038, 'end_line': 2038, 'offset_start': 77888, 'offset_end': 77971, 'content': 'function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.getTokensClaimedByUserAndId', 'start_line': 2039, 'end_line': 2039, 'offset_start': 77977, 'offset_end': 78074, 'content': 'function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakelandFarmClaim.getTokensClaimableByClaimInfo', 'start_line': 2040, 'end_line': 2043, 'offset_start': 78080, 'offset_end': 78227, 'content': 'function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);', 'contract_name': 'IStakelandFarmClaim', 'contract_code': '{\n    struct TokenConfig {\n        address token;\n        uint16 initialUnlockBP;\n        uint16 vestDurationInDays;\n        uint16 expiryInDays;\n        uint40 claimStartTs;\n        bool paused;\n        bytes32 merkleRoot;\n    }\n\n    struct TokenClaim {\n        uint16 farmId;\n        uint240 totalAllocated;\n        bytes32[] proof;\n    }\n\n    error ClaimNotAvailable();\n    error ClaimPaused();\n    error TokenClaimAlreadyStarted();\n    error TokenClaimExpired();\n    error TokenClaimPaused();\n    error TokenClaimNotPaused();\n    error TokenClaimNotExpired();\n    error ClaimMoreThanAllocated();\n    error AlreadyInitializedDepositAndSetup();\n    error InvalidProof();\n    error InvalidDelegate();\n    error InvalidSetup();\n    error InvalidDepositSetup();\n    error InvalidWithdrawalSetup();\n    error InvalidClaimStartTs();\n    error NonExistentFarmClaim();\n    error ZeroClaimAmount();\n\n    event Claimed(address indexed user, uint16 farmId, address token, uint256 amount, uint256 claimedAt);\n    event ClaimStatusUpdated(bool paused);\n    event InitTokenConfigSetAndDeposited(uint16 indexed farmId, uint256 amount);\n    event TokenMerkleRootUpdated(uint16 indexed farmId, bytes32 newMerkleRoot);\n    event TokenClaimStartTsUpdated(uint16 indexed farmId, uint256 newTokenClaimStartTs);\n    event TokenClaimStatusUpdated(uint16 farmId, bool paused);\n    event ExpiredTokenWithdrawn(uint16 indexed farmId, address token, uint256 amount, address receiver);\n\n    function claim(address vault, TokenClaim calldata tokenClaim) external;\n\n    function initDepositAndSetupTokenConfig(\n        address depositor,\n        uint16 farmId,\n        uint256 amount,\n        TokenConfig calldata tokenConfig\n    ) external;\n    function depositToken(address depositor, uint16 farmId, uint256 amount) external;\n    function withdrawExpiredToken(uint16 farmId, address receiver) external;\n\n    function setTokenMerkleRootById(uint16 farmId, bytes32 newMerkleRoot) external;\n    function setTokenClaimStartTsById(uint16 farmId, uint40 newTokenClaimStartTs) external;\n\n    function pauseClaim() external;\n    function unpauseClaim() external;\n\n    function getTokenConfigById(uint16 farmId) external view returns (TokenConfig memory);\n    function getTokenBalanceById(uint16 farmId) external view returns (uint256 balance);\n    function getTokensClaimedByUserAndId(address user, uint16 farmId) external view returns (uint256);\n    function getTokensClaimableByClaimInfo(address user, uint16 farmId, uint240 totalAllocated)\n        external\n        view\n        returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.hasRole', 'start_line': 2095, 'end_line': 2095, 'offset_start': 79970, 'offset_end': 80046, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControl', 'contract_code': "{\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.getRoleAdmin', 'start_line': 2103, 'end_line': 2103, 'offset_start': 80242, 'offset_end': 80309, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControl', 'contract_code': "{\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.grantRole', 'start_line': 2115, 'end_line': 2115, 'offset_start': 80560, 'offset_end': 80618, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': "{\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.revokeRole', 'start_line': 2126, 'end_line': 2126, 'offset_start': 80853, 'offset_end': 80912, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': "{\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.renounceRole', 'start_line': 2142, 'end_line': 2142, 'offset_start': 81415, 'offset_end': 81487, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) external;', 'contract_name': 'IAccessControl', 'contract_code': "{\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 2209, 'end_line': 2210, 'offset_start': 84462, 'offset_end': 84528, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 2212, 'end_line': 2213, 'offset_start': 84535, 'offset_end': 84611, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 2222, 'end_line': 2224, 'offset_start': 85199, 'offset_end': 85332, 'content': 'function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 2236, 'end_line': 2239, 'offset_start': 85652, 'offset_end': 85865, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkProxy', 'start_line': 2246, 'end_line': 2253, 'offset_start': 86093, 'offset_end': 86404, 'content': 'function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkNotDelegated', 'start_line': 2259, 'end_line': 2264, 'offset_start': 86522, 'offset_end': 86734, 'content': 'function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 2276, 'end_line': 2276, 'offset_start': 87118, 'offset_end': 87188, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._upgradeToAndCallUUPS', 'start_line': 2286, 'end_line': 2296, 'offset_start': 87546, 'offset_end': 88083, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation\'s compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._getOwnableStorage', 'start_line': 2328, 'end_line': 2332, 'offset_start': 89280, 'offset_end': 89438, 'content': 'function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 2349, 'end_line': 2351, 'offset_start': 89935, 'offset_end': 90061, 'content': 'function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 2353, 'end_line': 2358, 'offset_start': 90068, 'offset_end': 90302, 'content': 'function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 2371, 'end_line': 2374, 'offset_start': 90529, 'offset_end': 90672, 'content': 'function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 2379, 'end_line': 2383, 'offset_start': 90746, 'offset_end': 90907, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 2392, 'end_line': 2394, 'offset_start': 91243, 'offset_end': 91343, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 2400, 'end_line': 2405, 'offset_start': 91493, 'offset_end': 91707, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 2411, 'end_line': 2416, 'offset_start': 91862, 'offset_end': 92109, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verify', 'start_line': 2450, 'end_line': 2452, 'offset_start': 93379, 'offset_end': 93532, 'content': 'function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verifyCalldata', 'start_line': 2457, 'end_line': 2459, 'offset_start': 93596, 'offset_end': 93767, 'content': 'function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProof', 'start_line': 2467, 'end_line': 2473, 'offset_start': 94081, 'offset_end': 94370, 'content': 'function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProofCalldata', 'start_line': 2478, 'end_line': 2484, 'offset_start': 94440, 'offset_end': 94739, 'content': 'function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerify', 'start_line': 2492, 'end_line': 2499, 'offset_start': 95063, 'offset_end': 95320, 'content': 'function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerifyCalldata', 'start_line': 2506, 'end_line': 2513, 'offset_start': 95494, 'offset_end': 95771, 'content': 'function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProof', 'start_line': 2525, 'end_line': 2574, 'offset_start': 96513, 'offset_end': 98794, 'content': 'function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProofCalldata', 'start_line': 2581, 'end_line': 2630, 'offset_start': 98970, 'offset_end': 101263, 'content': 'function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._hashPair', 'start_line': 2635, 'end_line': 2637, 'offset_start': 101343, 'offset_end': 101489, 'content': 'function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._efficientHash', 'start_line': 2642, 'end_line': 2649, 'offset_start': 101610, 'offset_end': 101870, 'content': 'function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn\'t allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 2673, 'end_line': 2674, 'offset_start': 102712, 'offset_end': 102769, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 2676, 'end_line': 2677, 'offset_start': 102776, 'offset_end': 102843, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 2681, 'end_line': 2683, 'offset_start': 102910, 'offset_end': 103055, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeacon.implementation', 'start_line': 2700, 'end_line': 2700, 'offset_start': 103471, 'offset_end': 103528, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeacon', 'contract_code': '{\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 2738, 'end_line': 2740, 'offset_start': 104836, 'offset_end': 104995, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 2746, 'end_line': 2748, 'offset_start': 105235, 'offset_end': 105422, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 2754, 'end_line': 2757, 'offset_start': 105614, 'offset_end': 105838, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 2763, 'end_line': 2771, 'offset_start': 106042, 'offset_end': 106509, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 2778, 'end_line': 2785, 'offset_start': 106829, 'offset_end': 107208, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 2793, 'end_line': 2802, 'offset_start': 107592, 'offset_end': 108220, 'content': "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 2812, 'end_line': 2819, 'offset_start': 108722, 'offset_end': 109299, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 2845, 'end_line': 2845, 'offset_start': 110094, 'offset_end': 110169, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0x0a32372381ea32a441d46553f879e4de7027b011/0x0a32372381ea32a441d46553f879e4de7027b011.sol'}
